{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/ds/双循环2.PNG","path":"img/ds/双循环2.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/图的深度优先搜索.PNG","path":"img/ds/图的深度优先搜索.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/游标逆置.PNG","path":"img/ds/游标逆置.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/Mybatis架构.JPG","path":"img/javaWeb/Mybatis架构.JPG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/OGNL_Struts原理.JPG","path":"img/javaWeb/OGNL_Struts原理.JPG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/OGNL_Struts原理2.JPG","path":"img/javaWeb/OGNL_Struts原理2.JPG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/springMVC架构.JPG","path":"img/javaWeb/springMVC架构.JPG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/struts原理.JPG","path":"img/javaWeb/struts原理.JPG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/磁盘读取时间计算.PNG","path":"img/深入理解计算机系统/磁盘读取时间计算.PNG","modified":0,"renderable":0},{"_id":"source/img/算法/矩阵连乘分析二.JPG","path":"img/算法/矩阵连乘分析二.JPG","modified":0,"renderable":0},{"_id":"source/img/算法/矩阵连乘分解图.JPG","path":"img/算法/矩阵连乘分解图.JPG","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/img/ds/Prim算法.PNG","path":"img/ds/Prim算法.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/Kruskal算法.PNG","path":"img/ds/Kruskal算法.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/中序非.PNG","path":"img/ds/中序非.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/先序.PNG","path":"img/ds/先序.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/先序建立.PNG","path":"img/ds/先序建立.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/先序非.PNG","path":"img/ds/先序非.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/内外路径.PNG","path":"img/ds/内外路径.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/双向单链表.PNG","path":"img/ds/双向单链表.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/双循环1.PNG","path":"img/ds/双循环1.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/后序非.PNG","path":"img/ds/后序非.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/哈夫曼树性质1.PNG","path":"img/ds/哈夫曼树性质1.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/图-拓扑排序.PNG","path":"img/ds/图-拓扑排序.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/图的存储结构.PNG","path":"img/ds/图的存储结构.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/层序遍历.PNG","path":"img/ds/层序遍历.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/已知先序中序构二叉树.PNG","path":"img/ds/已知先序中序构二叉树.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/建立1.PNG","path":"img/ds/建立1.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/快排.PNG","path":"img/ds/快排.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/气泡排序.PNG","path":"img/ds/气泡排序.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/码长计算.PNG","path":"img/ds/码长计算.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/选择排序.PNG","path":"img/ds/选择排序.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/javaWeb体系.PNG","path":"img/javaWeb/javaWeb体系.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/SRAM和DRAM对比.PNG","path":"img/深入理解计算机系统/SRAM和DRAM对比.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/信号处理程序被中断.PNG","path":"img/深入理解计算机系统/信号处理程序被中断.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/存储器层次结构.PNG","path":"img/深入理解计算机系统/存储器层次结构.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/浮点数舍入.PNG","path":"img/深入理解计算机系统/浮点数舍入.PNG","modified":0,"renderable":0},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"source/img/ds/二叉树前序遍历.PNG","path":"img/ds/二叉树前序遍历.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/二叉树先序遍历.PNG","path":"img/ds/二叉树先序遍历.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/二叉树层序遍历.PNG","path":"img/ds/二叉树层序遍历.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/建立非.PNG","path":"img/ds/建立非.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/http请求.PNG","path":"img/javaWeb/http请求.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/jQ.PNG","path":"img/javaWeb/jQ.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/javaWeb体系2.PNG","path":"img/javaWeb/javaWeb体系2.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/javaWeb体系划分.PNG","path":"img/javaWeb/javaWeb体系划分.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/schema约束-命名空间.PNG","path":"img/javaWeb/schema约束-命名空间.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/8.1事件处理.PNG","path":"img/深入理解计算机系统/8.1事件处理.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/set指令.PNG","path":"img/深入理解计算机系统/set指令.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/异常分类.PNG","path":"img/深入理解计算机系统/异常分类.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/异常分类2.PNG","path":"img/深入理解计算机系统/异常分类2.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/栈结构.PNG","path":"img/深入理解计算机系统/栈结构.PNG","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/next-boot.js","path":"js/src/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"source/img/ds/二叉树遍历.PNG","path":"img/ds/二叉树遍历.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/http响应格式.PNG","path":"img/javaWeb/http响应格式.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/6.1.1内存地址取值.PNG","path":"img/深入理解计算机系统/6.1.1内存地址取值.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/特殊的操作指令.PNG","path":"img/深入理解计算机系统/特殊的操作指令.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/算术和逻辑操作指令.PNG","path":"img/深入理解计算机系统/算术和逻辑操作指令.PNG","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/img/ds/后缀表达式计算.PNG","path":"img/ds/后缀表达式计算.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/http头2.PNG","path":"img/javaWeb/http头2.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/web-JDBC原理.PNG","path":"img/javaWeb/web-JDBC原理.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/浮点数标准分类.PNG","path":"img/深入理解计算机系统/浮点数标准分类.PNG","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/muse.js","path":"js/src/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"source/img/javaWeb/MYSQL-table-数据类型.PNG","path":"img/javaWeb/MYSQL-table-数据类型.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/http请求头.PNG","path":"img/javaWeb/http请求头.PNG","modified":0,"renderable":0},{"_id":"source/img/深入理解计算机系统/浮点数规格化的值.PNG","path":"img/深入理解计算机系统/浮点数规格化的值.PNG","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/img/javaWeb/MySQL-table-运算符.PNG","path":"img/javaWeb/MySQL-table-运算符.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/Schema约束.PNG","path":"img/javaWeb/Schema约束.PNG","modified":0,"renderable":0},{"_id":"source/img/ds/中缀转后缀表达式.PNG","path":"img/ds/中缀转后缀表达式.PNG","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/img/深入理解计算机系统/进程地址空间.PNG","path":"img/深入理解计算机系统/进程地址空间.PNG","modified":0,"renderable":0},{"_id":"source/img/javaWeb/MySQL-table-数据类型2.PNG","path":"img/javaWeb/MySQL-table-数据类型2.PNG","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1550977740362},{"_id":"themes/next/.all-contributorsrc","hash":"6e5abe56bd8bbc5e926db941d5c9a79b42cc5049","modified":1551770992222},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1551770992222},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1551770992222},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1551770992222},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1551770992222},{"_id":"themes/next/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1551770992222},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1551770992222},{"_id":"themes/next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1551770992222},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1551770992222},{"_id":"themes/next/README.md","hash":"283621190d680b081376a1ac0997a3175f7ef054","modified":1551770992222},{"_id":"themes/next/_config.yml","hash":"631068ffeb993a29d8994dcc3c766fa059db9d6c","modified":1553347079913},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1551770992237},{"_id":"themes/next/bower.json","hash":"237d0a2bf89418dee4a4e9cdfef0d66dd7a1d18c","modified":1551770992237},{"_id":"themes/next/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1551770992253},{"_id":"themes/next/package.json","hash":"5912233efcabf8c6d7dcd2c2036c77b6631b5677","modified":1551770992324},{"_id":"source/_posts/TwoSum.md","hash":"be4b155b34c713ddaa116a09058621f6d5b83ed1","modified":1554045226686},{"_id":"source/_posts/hibernate.md","hash":"d42a48436f9e8b799261b91e6bc026d82f7cfb0d","modified":1555570684846},{"_id":"source/_posts/struct2.md","hash":"49fda9a76194c751b772bc63bad804f78a997a47","modified":1557111890798},{"_id":"source/_posts/数据结构与算法.md","hash":"e900c687c07c7f16d90ff51594292ad3d6be9f2d","modified":1553079533730},{"_id":"source/_posts/深入理解计算机系统.md","hash":"1380348a2744487523b91563324390e479078421","modified":1553079371825},{"_id":"source/_posts/矩阵连乘——动态规划和贪心.md","hash":"bb72918bb9f07e011a06978e50b16fd719721b6f","modified":1553342634959},{"_id":"source/_posts/软件构造实验一.md","hash":"4ba8674ff649694ec9588fabc5536bf76a2a4286","modified":1558082286538},{"_id":"source/_posts/软件构造实验二.md","hash":"4e09efd733e7e6e36b7fd0685eec4156e3413eb9","modified":1558082257627},{"_id":"source/about/index.md","hash":"ed1dd1c58371cbcb24ad03414991b02fa7ae6b8d","modified":1550977740377},{"_id":"source/archives/index.md","hash":"a9f0b3e5433bcb0efff2faa5709ab44da3bfd146","modified":1550977740377},{"_id":"source/categories/index.md","hash":"da3202f5ea964653571161fdbf536902dbe6eccd","modified":1553079612817},{"_id":"source/tags/index.md","hash":"1b0cec335d453eaf2a1918079624d0f9f1adcf51","modified":1553079487455},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1551770992237},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1551770992237},{"_id":"themes/next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1551770992237},{"_id":"themes/next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1551770992237},{"_id":"themes/next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1551770992237},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"721a1aa9feed1b580ab99af8e69ed22699121e88","modified":1551770992237},{"_id":"themes/next/docs/MATH.md","hash":"0540cd9c961b07931af9f38a83bc9a0f90cd5291","modified":1551770992237},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1551770992237},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1551770992237},{"_id":"themes/next/languages/de.yml","hash":"79b3221344da335743b5ef5a82efa9338d64feb0","modified":1551770992253},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1551770992253},{"_id":"themes/next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1551770992253},{"_id":"themes/next/languages/fr.yml","hash":"0393558717065293bdf732866471cebb0c884f6a","modified":1551770992253},{"_id":"themes/next/languages/id.yml","hash":"f3302a4dfdc9be38a52d6e081411574b1ea01671","modified":1551770992253},{"_id":"themes/next/languages/it.yml","hash":"31eb878b53d60ff47e3e534cdd7a839c8801ac6e","modified":1551770992253},{"_id":"themes/next/languages/ja.yml","hash":"3f25eca504ee5a519987b4402731f1bb7f5191c9","modified":1551770992253},{"_id":"themes/next/languages/ko.yml","hash":"75f2fe142f76bf623e34ed3570598226f55f2b8b","modified":1551770992253},{"_id":"themes/next/languages/nl.yml","hash":"08f16ce395dacc88847fc30dc6b985ce22fb8948","modified":1551770992253},{"_id":"themes/next/languages/pt-BR.yml","hash":"c7de8b77f44e75be4f04423088a1c891537aa601","modified":1551770992253},{"_id":"themes/next/languages/pt.yml","hash":"ca5072c967e5eb1178ffed91827459eda6e4e6e2","modified":1551770992253},{"_id":"themes/next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1551770992253},{"_id":"themes/next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1551770992253},{"_id":"themes/next/languages/uk.yml","hash":"6320439c6e9ff81e5b8f8129ca16e9a744b37032","modified":1551770992253},{"_id":"themes/next/languages/vi.yml","hash":"e2f0dd7f020a36aa6b73ed4d00dcc4259a7e5e9d","modified":1551770992253},{"_id":"themes/next/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1551770992253},{"_id":"themes/next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1551770992253},{"_id":"themes/next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1551770992253},{"_id":"themes/next/layout/_layout.swig","hash":"88c5567cdde8123ef202a7af469df0a2c82a9d55","modified":1551770992269},{"_id":"themes/next/layout/archive.swig","hash":"61bc56e77e653684fc834f63dcbdadf18687c748","modified":1551770992324},{"_id":"themes/next/layout/category.swig","hash":"ad0ac6a1ff341f8eab9570e7fb443962948c5f9d","modified":1551770992324},{"_id":"themes/next/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1551770992324},{"_id":"themes/next/layout/page.swig","hash":"948616c82d80246a3476cd7681aede249dcfc5cc","modified":1551770992324},{"_id":"themes/next/layout/post.swig","hash":"af74e97d57cf00cde6f8dbd4364f27910915454e","modified":1551770992324},{"_id":"themes/next/layout/schedule.swig","hash":"e79f43df0e9a6cf48bbf00882de48c5a58080247","modified":1551770992324},{"_id":"themes/next/layout/tag.swig","hash":"283519d4d5b67814412863a3e0212bac18bcc5a0","modified":1551770992324},{"_id":"themes/next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1551770992339},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1551770992339},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1551770992472},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1551770992472},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1551770992472},{"_id":"themes/next/layout/_custom/head.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551831059293},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992433},{"_id":"source/img/ds/双循环2.PNG","hash":"187e42fe43df786f10a73bd301c0f285661d93eb","modified":1540529025187},{"_id":"source/img/ds/图的深度优先搜索.PNG","hash":"10fb691ded4eeba6740cba6ffcb45fc1e6ce8ada","modified":1542944118106},{"_id":"source/img/ds/游标逆置.PNG","hash":"ddc1a22c686779aef1e2a82d7a93a10597ca02fb","modified":1540528759367},{"_id":"source/img/javaWeb/Mybatis架构.JPG","hash":"f296d1e2223791e3bcf7337bfa6453f38a233829","modified":1555674475156},{"_id":"source/img/javaWeb/OGNL_Struts原理.JPG","hash":"170bc33176a2a07bdee12d4d74054b85916dbcb4","modified":1554217982906},{"_id":"source/img/javaWeb/OGNL_Struts原理2.JPG","hash":"9486e80338e7649933a11c32651db1289b6b1b8d","modified":1554218119779},{"_id":"source/img/javaWeb/springMVC架构.JPG","hash":"2715cea6d31f1a460c8bff52dcb3e8ed7607ebcb","modified":1557058871189},{"_id":"source/img/javaWeb/struts原理.JPG","hash":"61fce5b20e1a310103a4c92401a17a2f11fbcd2e","modified":1553868375111},{"_id":"source/img/深入理解计算机系统/磁盘读取时间计算.PNG","hash":"961f9811f7e87f901aafbbe7dcce9540e845452f","modified":1543995794142},{"_id":"source/img/算法/矩阵连乘分析二.JPG","hash":"2aa3b26d4dfe38c0a7cc72d1ae43da68c5aa2b02","modified":1553094729766},{"_id":"source/img/算法/矩阵连乘分解图.JPG","hash":"0a15a7b9e3a7b58d3119bcf84791b9fc38f003e1","modified":1553092071676},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1551770992237},{"_id":"themes/next/docs/ru/README.md","hash":"3e191bd6b09dee33e6b8931c3bc338db3d04e479","modified":1551770992237},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1551770992237},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"018a259694f4a8c7c384e1f323531442cba5fbf3","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"415aa36be2d985c6ebb1a30a446aaffa1b9e471b","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"b17fc344ff61603f83387c0f9b2b2189aae81d50","modified":1551770992253},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"734b371a0dd910eb9fe087f50c95ce35340bb832","modified":1551770992253},{"_id":"themes/next/docs/zh-CN/README.md","hash":"fe4bfa69bcb16a777d5c5ab5d2b617bff548d6a0","modified":1551770992253},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1551770992253},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1551770992269},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1551770992269},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"891ab67815969dd8736cb22fbbb3f791b8fff4e4","modified":1551770992269},{"_id":"themes/next/layout/_macro/post.swig","hash":"e4123aa3e79012cc4e615e9de55de7612d01e8d5","modified":1551770992269},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b9054a508190ce85560b0dc0578b26f84f6112fc","modified":1551770992269},{"_id":"themes/next/layout/_partials/comments.swig","hash":"54afb7b78509ed8fac5d23daecc147b0fe615d1d","modified":1551770992277},{"_id":"themes/next/layout/_partials/footer.swig","hash":"6d56acdcdc12ebca9c1d90f8a2b52ad17aafca6e","modified":1551770992277},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"94c5d55df7121d73ee0340beac85b9c7c103a3e2","modified":1551770992277},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1551770992277},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"dee345054d564dd56f74bb143942d3edd1cb8150","modified":1551770992277},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"c31d54154eed347f603009d2d65f7bf8d9a6885a","modified":1551770992292},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"28b1cd4c065fcd214a1d6dd06f54bb62c3519aad","modified":1551770992292},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"efb3404a3303622f3be60944d9d1926972c5c248","modified":1551770992292},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"68ad21aef6481d014e7ec0b674e469f2f82ea231","modified":1551770992292},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"87bcb495f7ddd81cc3fe2c2a886e51c08053019b","modified":1551770992308},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"4b93dc7ac0573c402aabcb5c933bbcb893b07c51","modified":1551770992308},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"6b1bd41f6654b5d6577b60859156544a3ca1c037","modified":1551770992308},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"9e00cb9b3fdfe2e2c4877a874d0d3ecb7fd0f3ee","modified":1551770992308},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"7db4ad4a8dd5420dad2f6890f5299945df0af970","modified":1551770992324},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"d66dec72ea7ad5026260914e3545551645e0ab37","modified":1551770992324},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"76f5933925670044ec65b454295ba7e0a8439986","modified":1551770992324},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"c476dc3693a9dd0be2d136a45b0d7fdef55d4d92","modified":1551770992324},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"882cd0b68c493af1b6d945660f9c21085e006ffc","modified":1551770992324},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"f58463133bf8cfef5ff07f686b834ff8cbbe492f","modified":1551770992324},{"_id":"themes/next/scripts/filters/exturl.js","hash":"b19c7c1021e57367b3b3bbf5678381017ed5667d","modified":1551770992324},{"_id":"themes/next/scripts/helpers/engine.js","hash":"cdb6152582313268d970ffeef99b4a8a7850f034","modified":1551770992339},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a40ce6bc852bb4bff8b9f984fa064741dd151e96","modified":1551770992339},{"_id":"themes/next/scripts/tags/button.js","hash":"6ef342a0c4b58000ba11148b4c9b2b599edd86b5","modified":1551770992339},{"_id":"themes/next/scripts/tags/exturl.js","hash":"e9dab948e6327b22b4fc0c66cf97f6600a444dd5","modified":1551770992339},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1551770992339},{"_id":"themes/next/scripts/tags/full-image.js","hash":"755b0d518352ec27354124105b48e302ac84d66f","modified":1551770992339},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"03575b534303f42c81ba6187ec601a5578913a39","modified":1551770992339},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1551770992339},{"_id":"themes/next/scripts/tags/label.js","hash":"4cee94f53fdecc7f9c2d91c06ab9e7a433b5ec5a","modified":1551770992339},{"_id":"themes/next/scripts/tags/note.js","hash":"f1b560d6e63d1b06fd80e12bbac32660125c223c","modified":1551770992339},{"_id":"themes/next/scripts/tags/tabs.js","hash":"ca885c8fa46a76a7b8977730575551622497410b","modified":1551770992339},{"_id":"themes/next/source/css/main.styl","hash":"5e7d28bc539e84f8b03e68df82292f7fc0f2d023","modified":1551770992433},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1551770992433},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1551770992433},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1551770992433},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1551770992433},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1551770992433},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1551770992433},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1551770992433},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551770992433},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1551770992433},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551770992433},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1551770992433},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1551770992433},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551770992433},{"_id":"source/img/ds/Prim算法.PNG","hash":"be94bc823a83c8e303c354d99a1efb8e697794dc","modified":1544274104434},{"_id":"source/img/ds/Kruskal算法.PNG","hash":"af952ae7b5eedb0ef9870187c07699c2a1030c8a","modified":1544274324945},{"_id":"source/img/ds/中序非.PNG","hash":"f4a64d93be2dfe621814bf218b92ae7b59bd0f48","modified":1542727203153},{"_id":"source/img/ds/先序.PNG","hash":"9f1acdcc4e1a8c69d65878fd63a4e5f261cdd335","modified":1542727266841},{"_id":"source/img/ds/先序建立.PNG","hash":"db013c0c6400060a369807c629089ae71f556124","modified":1542727367605},{"_id":"source/img/ds/先序非.PNG","hash":"50795b62f8f0da112fc9edbdd30e09960f4ad66a","modified":1542727234109},{"_id":"source/img/ds/内外路径.PNG","hash":"3fb9280189a7c44e8bd4f11f35d9281c43a26dac","modified":1542760787817},{"_id":"source/img/ds/双向单链表.PNG","hash":"2627c45a03d4e2971fc31284ab370323a714404e","modified":1540528875638},{"_id":"source/img/ds/双循环1.PNG","hash":"55f20c9bc6e5e15b2ce822351202761c33b0795f","modified":1540528988641},{"_id":"source/img/ds/后序非.PNG","hash":"fc6cb567d2c8d21d4b32f4e22eea6210e7850003","modified":1542727172422},{"_id":"source/img/ds/哈夫曼树性质1.PNG","hash":"6b32cedbc27e6b25aa96e565ea86cf13a20112b9","modified":1542760851790},{"_id":"source/img/ds/图-拓扑排序.PNG","hash":"ab5fb0e83412bfb9f156f2e61c3e7b1f2ba2c96c","modified":1544430371906},{"_id":"source/img/ds/图的存储结构.PNG","hash":"6fe99c2bf6dd0a9d7c23f3435e554fa2ab45f650","modified":1542941116975},{"_id":"source/img/ds/层序遍历.PNG","hash":"1c533cab4fd6d5dae1c4d35c8aee0a76a0ba4a08","modified":1542727124893},{"_id":"source/img/ds/已知先序中序构二叉树.PNG","hash":"edda52d2e9fd5cbfcc5338586051f34d45cc49b9","modified":1545919163880},{"_id":"source/img/ds/建立1.PNG","hash":"db63c8bb50e7f147977d0044978f199ecef13351","modified":1542727333155},{"_id":"source/img/ds/快排.PNG","hash":"bd9e6f350f1a9d54c49851e9838ebf27c2252a16","modified":1545052213319},{"_id":"source/img/ds/气泡排序.PNG","hash":"755f231b1473eed0cae3a7d0ab1b15e5245020ed","modified":1545052114867},{"_id":"source/img/ds/码长计算.PNG","hash":"a870d3bafb94447cd7adac4ccaf3b416d13abe84","modified":1542760928530},{"_id":"source/img/ds/选择排序.PNG","hash":"4791878c4a59e96aafe114b5969e7ebb21826475","modified":1545058832477},{"_id":"source/img/javaWeb/javaWeb体系.PNG","hash":"476f535c980ce2b3a83722eb0cee204404e9a958","modified":1543645953939},{"_id":"source/img/深入理解计算机系统/SRAM和DRAM对比.PNG","hash":"fbdc048b712161a07712459483ca38cc2d0cbcae","modified":1543458967149},{"_id":"source/img/深入理解计算机系统/信号处理程序被中断.PNG","hash":"b8d5716226f64a220914c48a75e5397c367bd132","modified":1544796644232},{"_id":"source/img/深入理解计算机系统/存储器层次结构.PNG","hash":"dfff26cbcc2184c78b506f59374087189b4144a4","modified":1543491686499},{"_id":"source/img/深入理解计算机系统/浮点数舍入.PNG","hash":"ab6db20e3b3859e17aaad66d7d01204447143611","modified":1542790108412},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992402},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992417},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992433},{"_id":"themes/next/source/images/avatar.jpg","hash":"ccb8bf930caace55690eb68568b9944761387b03","modified":1552375171425},{"_id":"source/img/ds/二叉树前序遍历.PNG","hash":"ed70c869cbf9ee1749f8c182a390b28393cfc5ab","modified":1541733158786},{"_id":"source/img/ds/二叉树先序遍历.PNG","hash":"d37a44517aeba46c6c6861b7c75f9816c2a92224","modified":1541733208474},{"_id":"source/img/ds/二叉树层序遍历.PNG","hash":"90e288b9c351d6595eb638fcfa232a79d54f3678","modified":1541734376595},{"_id":"source/img/ds/建立非.PNG","hash":"04dc5c76eb5d8fa6b8932f21bd432e0e74263267","modified":1542727402059},{"_id":"source/img/javaWeb/http请求.PNG","hash":"918f5ff73b33d6ab6229267cca8b57300318e251","modified":1543760716425},{"_id":"source/img/javaWeb/jQ.PNG","hash":"51f549929af90ff2c3e677c9eccf10ba8bef2e92","modified":1536737059029},{"_id":"source/img/javaWeb/javaWeb体系2.PNG","hash":"1e966c2937ae60f4e81d65d5ad0852e21d4c0047","modified":1543646093777},{"_id":"source/img/javaWeb/javaWeb体系划分.PNG","hash":"1c16577fa34c0021e5d67b076d4f187175d9f19a","modified":1543651250389},{"_id":"source/img/javaWeb/schema约束-命名空间.PNG","hash":"251ec27872b3819e95804fbb18160dd35ccae392","modified":1540825853697},{"_id":"source/img/深入理解计算机系统/8.1事件处理.PNG","hash":"384ecfbc47d70a1e765ac06b6746a96125848f30","modified":1543457671156},{"_id":"source/img/深入理解计算机系统/set指令.PNG","hash":"82acf2ebbb9ac4ded80acf235c68354ba2ef0669","modified":1543234265561},{"_id":"source/img/深入理解计算机系统/异常分类.PNG","hash":"5df9edc777b72d4d5ceee6214a4411452ea05cdf","modified":1544704475537},{"_id":"source/img/深入理解计算机系统/异常分类2.PNG","hash":"b2f6a60a908b8170e54dee16169f4cf39130b108","modified":1544704555191},{"_id":"source/img/深入理解计算机系统/栈结构.PNG","hash":"0b93110b8e601d16eba62cbe7a248830b0293916","modified":1543317822864},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"25aea3d764b952f3f6d28ab86d7212d138e892df","modified":1551770992269},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1551770992269},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"b57bf9c865bed0f22157176a8085de168a1aef77","modified":1551770992277},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"187316a1d565f98eac138b5ce2180b52a190028c","modified":1551770992277},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"4b53a0659a7e800871d8e9a4bd20f7b892a8e29b","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"03f669356bbaa70144b743f3312178e1981ac3a8","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"39c4ad0e36b7c1260da98ba345f7bd72a2ac0f2e","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"e015c7d9b84062b60b15b36be3ef11929dd10943","modified":1551770992277},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"daa6e5b7dbc409d6bf8a031d5413d8229e9c0995","modified":1551770992277},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"f46699a9daa5fef599733cbab35cb75cf7a05444","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f331ad02beea8990066d32ad6ec9f859672c3615","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"be6683db6a269d83bb0441d7cf74db63a240fa8a","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"fc69f1f3950d9b81b0d474735e512053be169e8e","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"fb7727e8ec63a58238a7206bf70eb273c8879993","modified":1551770992277},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1551770992277},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"f14e9e8c27af82f1bfe794e252dec0d7e521f503","modified":1551770992277},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1551770992292},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"31245e09ce0465b994cebd94223a531585c4eab4","modified":1551770992292},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c609097b95eb6127c2784f47f2230e6e6efc0be2","modified":1551770992292},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"54b43d406cf37932e7b60f46814e864d31b1842c","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a62c93f19429f159bcf0c2e533ffc619aa399755","modified":1551770992292},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"e0f0a753d4920ffb37ddbc8270515654a0b9b92a","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"3c548934b97cc426544947f7a2ae35c270b5e33f","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"84018384d00e4a584d613589adae6674a3060a36","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"23c6d15aa2a305f9d29caee1b60cfae84d32fa09","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"66d562b3778dbc839f7c00103bd0099c5d61602a","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"83dd7df11b100bae38c9faab9a478f92149a0315","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"73576c9683d9ad9b124916dc6c660607fe7cc1fa","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"2e1de38f44af00209129d4051b7ae307cb11ad68","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"335005a9f8b36349f0ad0a7beeba6969c55fc7f7","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"53202062267391353d49f269e7eb74eb87d30921","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"453df3add0e0531950b5ae5b0e09c6b890daf9ee","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"39928f358dd13d9fc1a4641800e57be157ecd815","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"623e73bedef067ac24a398ef27c8197295da872d","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"71fb01bcad43bc9410ab19190373b9f7e59215b5","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"d18c87d7839e7407e39acd2998bcc9e0b34611b0","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"a22d1ea29a5ffe46199ab7d108a291a05af8d5b6","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"4cff8bf5c42c62f7f0ac1f0d70f839dae39ba77a","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"d685df1516cb138d7a83bac5d7878a1e0fa8bc04","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"bc3fc9d053b3d1fc0cd3918bf9a629a6f38f6414","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"0149e803ed7d30163df3b3ba3f578e5584a2e4af","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"bd529bf26f28745eb8ded3be7652d33d55fec8d4","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"4e86e1ace90a70bb8862f5e6de9dbe7bfc046bee","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"1a5d94f5779a2ce13abc886dd78e0617f89c34b9","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"bd6d763c1233cd89512c323ce0992daf7f9fd0e5","modified":1551770992308},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"43a20fa0e9ae2f4254f04813f9c619dd36b49ae5","modified":1551770992308},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"ea1c136f960667a0a13b334db497b9b19c41f629","modified":1551770992308},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"2cbc7a4df451b52da9552aafc0745de17c24c9a4","modified":1551770992308},{"_id":"themes/next/layout/_third-party/quicklink/index.swig","hash":"9297195791600394b1c16234b04498f50a3ad985","modified":1551770992324},{"_id":"themes/next/layout/_third-party/quicklink/quicklink.swig","hash":"58e1abe7b9a4c0260a9a3535540a8f4d0d4ff46f","modified":1551770992324},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"89e41d4c298d8d70b4d1c833c7e599d089f2b3d4","modified":1551770992324},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"078bd2d5815eb23e8c5f74467dc0042babea00ae","modified":1551770992324},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"d45ca53af17d1d83fd27f8ed0917a72f0060e1a9","modified":1551770992324},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"d1deb849e697cfb6258b8ab7bfb47e219210ccd9","modified":1551770992402},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e9b0752f08398709e787546a246baca12b4c557f","modified":1551770992417},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1551770992417},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"da7049f3d9a157abe0ecc62611edcf43605ba84d","modified":1551770992417},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e37aab667be94576f6145b61a78cfe87836c68b6","modified":1551770992433},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1551770992449},{"_id":"themes/next/source/js/src/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1551770992449},{"_id":"themes/next/source/js/src/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1551770992449},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1551770992449},{"_id":"themes/next/source/js/src/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1551770992449},{"_id":"themes/next/source/js/src/next-boot.js","hash":"c7e2a588b679d46379124141bb2f30bc2f3210e2","modified":1551770992449},{"_id":"themes/next/source/js/src/motion.js","hash":"e70f961d24e4e61a2df5bf640ab51acee8f1ffbd","modified":1551770992449},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1551770992457},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1551770992457},{"_id":"themes/next/source/js/src/utils.js","hash":"a6efa988f4f3e16fb55e2f5a2e8e9e7612b3da3b","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1551770992457},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1551770992472},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1551770992472},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1551770992472},{"_id":"source/img/ds/二叉树遍历.PNG","hash":"516ffc9912d2ba54614307d9b094915a73982d80","modified":1541733776325},{"_id":"source/img/javaWeb/http响应格式.PNG","hash":"a1834a2a2443503911affa5f73392cb36442f947","modified":1543762658245},{"_id":"source/img/深入理解计算机系统/6.1.1内存地址取值.PNG","hash":"6fc29016b4f6f86b01d9717c300f00929ed0df7e","modified":1543461895135},{"_id":"source/img/深入理解计算机系统/特殊的操作指令.PNG","hash":"1d30c2d6a99fc945477d7413889bca5d266097aa","modified":1542876954972},{"_id":"source/img/深入理解计算机系统/算术和逻辑操作指令.PNG","hash":"b19cae0bbf9131b8bf610609dfc8dc2708406aec","modified":1542874851207},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1551770992472},{"_id":"source/img/ds/后缀表达式计算.PNG","hash":"ac3ff76073e917e686e35d7c75f160204bc67159","modified":1545797356420},{"_id":"source/img/javaWeb/http头2.PNG","hash":"a07d1b4227c3541591d7118b5681b006f0eb61ec","modified":1543761512857},{"_id":"source/img/javaWeb/web-JDBC原理.PNG","hash":"13528bb09fa35a7eda63ff760049b0a9c3a671a5","modified":1538038549817},{"_id":"source/img/深入理解计算机系统/浮点数标准分类.PNG","hash":"4e3bf7d66d2fc81f0a3c19a24e5d92b8e0221fda","modified":1542786790327},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"bbb788b453236e5b4af7c81df8efcfc6bde08903","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"c97c819a65f6967485184399397601e5133deda6","modified":1551770992386},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"1a4ac0d119f2126ef8951897338706edce112235","modified":1551770992386},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"cb2c0beb69bfc56c0ed86e609bc1c35edb799b99","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"c0e8647244e1ef106e94c3c8ac4a64bca2677159","modified":1551770992386},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"33a74fcd6c38cea356f6d2994a19f46dcfd5d8a4","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"c4bfce1fca9ea5d0fd991d98e08b8e771d33d731","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"5f1e5d7b9d44ef3e6ad442e083753fee76d3b112","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"eecb2081ee1eef1e2152c7fea9310366e33b1eac","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"a80782a6eb3b40da2e14251da49069aff3115d8a","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"06d9d00257abd28414ec0b746f866bf9911cf5ec","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"9f35b95beb344f4eeca5ca584fbe7206f791372e","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"15254414a52f05618c54a2ac7f4635f99077ec30","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"157e6915dcf5990566e463acffa71043b2651c07","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4ed12bf17eeb7cd4f22dd01fdd486cda68d169a8","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"9f35b95beb344f4eeca5ca584fbe7206f791372e","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"30d61fa31e405fcfe3d2ff6174ccad60be1745f9","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"28f0444ccdc85a34ada651d8ee52479e16311167","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"11fcaaf7524445a194801e1048ea2fb84b316414","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"a5395766dfdda81285d0cd3ddebe8e8bc924fa2a","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0d6f0df798449b710e1e5dbd43d470089b2a3c95","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1551770992417},{"_id":"themes/next/source/js/src/schemes/muse.js","hash":"ccc0c5cd4ec6f8159c98990ad83f11a5c0b0234c","modified":1551770992449},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"3eea56cc9ce47bb4760930c4c69cebf847a7fbb2","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1551770992457},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1551770992472},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1551770992472},{"_id":"source/img/javaWeb/MYSQL-table-数据类型.PNG","hash":"14d8f93fad1014189a8fc83625bd0307896a9b2b","modified":1537950056501},{"_id":"source/img/javaWeb/http请求头.PNG","hash":"845c3b919e9f6c57f361389ce5b147985b701d31","modified":1543761261667},{"_id":"source/img/深入理解计算机系统/浮点数规格化的值.PNG","hash":"ab71d12d791a4aaec0423dcf31e0a6d728a95c01","modified":1542786985841},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551770992457},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1551770992472},{"_id":"source/img/javaWeb/MySQL-table-运算符.PNG","hash":"4036921f5dc4332d3d25f5c1277074a6066ab37a","modified":1537975534173},{"_id":"source/img/javaWeb/Schema约束.PNG","hash":"42dd552d4bc53980a70ee222ad68161ae15b2658","modified":1540372365726},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"2df409df04fdb52d7234876a9f6e502edd4e3929","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"48bb741f6bda73b322a25a8fbe37fd3d5e0ff601","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1ec3102ee8f5b8cc0877da1fd109d37470401e7b","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"b8647d6140141b0a160607f6353e4d4594cca92e","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"32bbf059c57677e754a918c927ac63e2d843108f","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"e5a5f8747fdf2ca960e4e73c081b8952afd62224","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fa1cea6fcc3f552d57cc7d28380a304859139bf6","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"db1df0186a4572844d69d0d7bb974bd120cb64d5","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3241c9ae85ca11b6c4e125ac471aa4342ba1ce9c","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"fc94dd09b4245143b452d6cf2fc4c12134d99d6d","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"77da38898bdd99cf8fd3e0ae8cc4d2ac943bcb60","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"8703ff5ebfc76420565b92b1b873e03fb9d9cf15","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"b6a241626783d2ac115d683fd59ec283af68e5bb","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"a0e84b21ecc1f69d8d42c83630c1004d3419e3fd","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"7b69c1ad392f8a386854e318d4c8ddeb9ba8d793","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"2ea91d7b75966d471bf857a9f3fbf87fd01aea90","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"989b7d718914b5242506947aa5767b3f2480d8f9","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"539fc0880b2e035e8316d5d4b423703195c1b7ba","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"2e26e4429c2457b8ca12555426659c2fc65a5cea","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"41858f2dfd34a57d0a2016b1bce08efb61943b7a","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"2994c15172bcc916c64f484ca34c0c45951e95ca","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"7af14846bb8623ef1379575dd6f36c65589e69b4","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"7e2ba73073daaea0a18c3d67ff137dd683af7011","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"dd5f7057680faefc9306fab3172106f762c1a517","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"b9a19654b6a2685b5426afac8b09cdbd80fae00c","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"9da1cd122cd61896760b6f5edaed0be06c17fd6c","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"64148d1d53f4a4a13dfe148fcf698486fc5c72ca","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"72cabf6edfd64697e37950cc3e66fbea6ba47b66","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"2937e566ad0f3d9adc0865b269fdca62b7576fdd","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"30ccc107061dc23943198f087759079161ee24e9","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"f1640253cbbf71d0c04c34c25bd61045894f98bc","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"f26c32a0c3045e5ae826b983abc3a3c139456663","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"a01484e350ad5fc9b1fdfbfafb2ddd9687ad4d20","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"49913bb2b702d52d77528cd9378126aa67c0082c","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"2a1008f1044b450b806adc166754ba9513e68375","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"74412b0bf4ec0d28aedd2e60b27affd4d5cd1452","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3529aae283864fa0f09925ee8217905632e9a930","modified":1551770992386},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1551770992417},{"_id":"source/img/ds/中缀转后缀表达式.PNG","hash":"eed179716750b4ec27f97503eb2be409d7c8c961","modified":1545796511161},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"981795aad232c8bd3f52a0ed8720db696d18a234","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"2e36956c5f8802f703c7ce3893d16323a0e09d4c","modified":1551770992371},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551770992457},{"_id":"source/img/深入理解计算机系统/进程地址空间.PNG","hash":"66f40ecd1f2987980bfdb12b1084f379df6ef336","modified":1544706670826},{"_id":"source/img/javaWeb/MySQL-table-数据类型2.PNG","hash":"459cbf054e70f99440f1339fa358567a3bfdbb63","modified":1537950130589}],"Category":[{"name":"LeetCode","_id":"cjvrtri0y0005tku3rjm3roz2"},{"name":"算法","_id":"cjvrtri160009tku3gspipji1"},{"name":"javaEE framework","_id":"cjvrtri54000ptku3zumq0zus"},{"name":"软件构造","_id":"cjvrtri5d000wtku37pexbdnt"},{"name":"计算机系统","_id":"cjvrtri5f0012tku32jo0psky"},{"name":"数据结构","_id":"cjvrtri8q001jtku3aoybpsfz"}],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2019-02-24T03:19:45.475Z","updated":"2019-02-24T03:09:00.362Z","path":"404.html","title":"","comments":1,"_id":"cjvrtrht50000tku3bpztfqh4","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Hey, this is Kaijun.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Hey, this is Kaijun.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","updated":"2019-02-24T03:09:00.377Z","path":"about/index.html","_id":"cjvrtri0q0002tku3tnfoha6s","content":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"noopener\">李书航 － 什么是「共产中文腔调」？ </a><br></p>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"noopener\">李书航 － 什么是「共产中文腔调」？ </a><br></p>"},{"layout":"archives","title":"Archives","description":"Hey, this is Archives.","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Hey, this is Archives.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2019-02-24T03:09:00.377Z","updated":"2019-02-24T03:09:00.377Z","path":"archives/index.html","comments":1,"_id":"cjvrtri0u0004tku3jxtw5o8s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2019-03-20T10:59:53.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-03-20 18:59:53\ntype: categories\n---\n","updated":"2019-03-20T11:00:12.817Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjvrtri130007tku3bcyz5m0m","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ntype: \"tags\"\n---\n","date":"2019-03-20T10:58:07.455Z","updated":"2019-03-20T10:58:07.455Z","path":"tags/index.html","comments":1,"_id":"cjvrtri150008tku33i2bcn6t","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Two sum","urlname":"LeetCode_TwoSum","mathjax":true,"description":"闲置许久，终于开始写Leetcode啦，兴奋o(*￣▽￣*)ブ，希望能借助Leetcode学习一些算法相关的知识~~","abbrlink":22353,"date":"2019-03-30T15:43:00.000Z","_content":"\n闲置许久，终于开始写Leetcode啦，兴奋o(*￣▽￣*)ブ，希望能借助Leetcode学习一些算法相关的知识~~\n\n\n\n**LeetCode第一题**：\n\n#### question\n\n难度：Easy\n\n​\t\t\t\t\t\t        Two sum\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\n译文：\n​                                                            两数之和\n给定一个整数数组和一个目标值，找出数组中和为目标值的 两个 数。\n你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n\n#### solution\n\n将时间复杂度缩短至O(n),只能以空间换时间，这里利用HashMap（查找时间复杂度为O(1)）\n\n```java\npublic Vector<Integer> twoSum(Vector<Integer> nums, int target) {\n    Vector<Integer> resultVector = new Vector<Integer>();\n\t Map<Integer,Integer> map = new HashMap<Integer, Integer>();\n\t int length = nums.size();\n\t \n\t for(int i = 0; i<length; i++) {\n\t\t int complementation = target - nums.get(i);\n\t\t if(map.containsKey(complementation)) {\n\t\t\t resultVector.add(map.get(complementation));\n\t\t\t resultVector.add(i);\n\t\t\t return resultVector;\n\t\t }\n\t\t map.put(nums.get(i),i);\n\t }\n\t return resultVector;\n   }\n```\n\n在网上还看到了一份大佬的优质解法，但一时找不到网址了，暂时无法分享，但后续会更新呦\n\n附：LeetCode代码仓库链接\n\n<a  href=\"https://github.com/CN-ZhangYue/LeetCode\">https://github.com/CN-ZhangYue/LeetCode</a>\n\n\n\n\n\n","source":"_posts/TwoSum.md","raw":"---\ntitle: Two sum\nurlname: LeetCode_TwoSum\nmathjax: true\ntags:\n  - LeetCode\n  - Two sum\ncategories: LeetCode\ndescription: 闲置许久，终于开始写Leetcode啦，兴奋o(*￣▽￣*)ブ，希望能借助Leetcode学习一些算法相关的知识~~\nabbrlink: 22353\ndate: 2019-03-30 23:43:00\n---\n\n闲置许久，终于开始写Leetcode啦，兴奋o(*￣▽￣*)ブ，希望能借助Leetcode学习一些算法相关的知识~~\n\n\n\n**LeetCode第一题**：\n\n#### question\n\n难度：Easy\n\n​\t\t\t\t\t\t        Two sum\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\n译文：\n​                                                            两数之和\n给定一个整数数组和一个目标值，找出数组中和为目标值的 两个 数。\n你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n\n#### solution\n\n将时间复杂度缩短至O(n),只能以空间换时间，这里利用HashMap（查找时间复杂度为O(1)）\n\n```java\npublic Vector<Integer> twoSum(Vector<Integer> nums, int target) {\n    Vector<Integer> resultVector = new Vector<Integer>();\n\t Map<Integer,Integer> map = new HashMap<Integer, Integer>();\n\t int length = nums.size();\n\t \n\t for(int i = 0; i<length; i++) {\n\t\t int complementation = target - nums.get(i);\n\t\t if(map.containsKey(complementation)) {\n\t\t\t resultVector.add(map.get(complementation));\n\t\t\t resultVector.add(i);\n\t\t\t return resultVector;\n\t\t }\n\t\t map.put(nums.get(i),i);\n\t }\n\t return resultVector;\n   }\n```\n\n在网上还看到了一份大佬的优质解法，但一时找不到网址了，暂时无法分享，但后续会更新呦\n\n附：LeetCode代码仓库链接\n\n<a  href=\"https://github.com/CN-ZhangYue/LeetCode\">https://github.com/CN-ZhangYue/LeetCode</a>\n\n\n\n\n\n","slug":"TwoSum","published":1,"updated":"2019-03-31T15:13:46.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvrtri0k0001tku367wzpsxo","content":"<p>闲置许久，终于开始写Leetcode啦，兴奋o(<em>￣▽￣</em>)ブ，希望能借助Leetcode学习一些算法相关的知识~~</p>\n<p><strong>LeetCode第一题</strong>：</p>\n<h4 id=\"question\"><a href=\"#question\" class=\"headerlink\" title=\"question\"></a>question</h4><p>难度：Easy</p>\n<p>​                                Two sum<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>\n<p>译文：<br>​                                                            两数之和<br>给定一个整数数组和一个目标值，找出数组中和为目标值的 两个 数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>\n<h4 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"solution\"></a>solution</h4><p>将时间复杂度缩短至O(n),只能以空间换时间，这里利用HashMap（查找时间复杂度为O(1)）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Vector&lt;Integer&gt; <span class=\"title\">twoSum</span><span class=\"params\">(Vector&lt;Integer&gt; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    Vector&lt;Integer&gt; resultVector = <span class=\"keyword\">new</span> Vector&lt;Integer&gt;();</span><br><span class=\"line\">\t Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">\t <span class=\"keyword\">int</span> length = nums.size();</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;length; i++) &#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> complementation = target - nums.get(i);</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span>(map.containsKey(complementation)) &#123;</span><br><span class=\"line\">\t\t\t resultVector.add(map.get(complementation));</span><br><span class=\"line\">\t\t\t resultVector.add(i);</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span> resultVector;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t map.put(nums.get(i),i);</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> resultVector;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在网上还看到了一份大佬的优质解法，但一时找不到网址了，暂时无法分享，但后续会更新呦</p>\n<p>附：LeetCode代码仓库链接</p>\n<p><a href=\"https://github.com/CN-ZhangYue/LeetCode\" target=\"_blank\" rel=\"noopener\">https://github.com/CN-ZhangYue/LeetCode</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>闲置许久，终于开始写Leetcode啦，兴奋o(<em>￣▽￣</em>)ブ，希望能借助Leetcode学习一些算法相关的知识~~</p>\n<p><strong>LeetCode第一题</strong>：</p>\n<h4 id=\"question\"><a href=\"#question\" class=\"headerlink\" title=\"question\"></a>question</h4><p>难度：Easy</p>\n<p>​                                Two sum<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>\n<p>译文：<br>​                                                            两数之和<br>给定一个整数数组和一个目标值，找出数组中和为目标值的 两个 数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>\n<h4 id=\"solution\"><a href=\"#solution\" class=\"headerlink\" title=\"solution\"></a>solution</h4><p>将时间复杂度缩短至O(n),只能以空间换时间，这里利用HashMap（查找时间复杂度为O(1)）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Vector&lt;Integer&gt; <span class=\"title\">twoSum</span><span class=\"params\">(Vector&lt;Integer&gt; nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    Vector&lt;Integer&gt; resultVector = <span class=\"keyword\">new</span> Vector&lt;Integer&gt;();</span><br><span class=\"line\">\t Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">\t <span class=\"keyword\">int</span> length = nums.size();</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;length; i++) &#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> complementation = target - nums.get(i);</span><br><span class=\"line\">\t\t <span class=\"keyword\">if</span>(map.containsKey(complementation)) &#123;</span><br><span class=\"line\">\t\t\t resultVector.add(map.get(complementation));</span><br><span class=\"line\">\t\t\t resultVector.add(i);</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span> resultVector;</span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t map.put(nums.get(i),i);</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> resultVector;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在网上还看到了一份大佬的优质解法，但一时找不到网址了，暂时无法分享，但后续会更新呦</p>\n<p>附：LeetCode代码仓库链接</p>\n<p><a href=\"https://github.com/CN-ZhangYue/LeetCode\" target=\"_blank\" rel=\"noopener\">https://github.com/CN-ZhangYue/LeetCode</a></p>\n"},{"title":"矩阵连乘——动态规划和贪心","date":"2019-03-23T08:05:48.000Z","description":"男朋友决定每天写进blog一个算法课上的示例，我不想落后，决定一起开始这个工程啦(#^.^#)。第一个当然是我比较感兴趣的矩阵连乘求最优的算法了。","_content":"\n​\t男朋友决定每天写进blog一个算法课上的示例，我不想落后，决定一起开始这个工程啦(#^.^#)。第一个当然是我比较感兴趣的矩阵连乘求最优的算法了。\n\n```\n输入：<A1,A2, ..., An>, Ai是(pi -1) * pi矩阵 \n\n输出：计算A1 * A2 *... * An的最小代价方法\n```\n\n##### 动态规划\n\n一般给出的是动态规划算法，使用动态规划，是因为矩阵连乘可以分解为若干个具有重叠性的子问题：\n\n<img src=\"\\img\\算法\\矩阵连乘分解图.JPG\" height=40%>\n\n\n\n​\t我们可以递归的求解每一种方式的代价，进而通过比较得到乘法次数最少的方案即最优解：\n$$\nA_i\\times A_{i+1}\\times...\\times A_j = \\begin{cases}(A_i) & \\times(A_{i+1}\\times...\\times A_j)\\\\(A_i\\times A_{i+1})&\\times(A_{i+2}\\times...\\times A_j)\\\\...\\\\(A_i\\times...\\times A_k)\\times(A_{k+1}\\times...\\times A_j)\\\\...\\\\(A_i\\times...\\times A_{j-1})\\times(A_j)\\end{cases}\n$$\n​\t考虑到所有的k，优化解的代价方程为:\n\n​\t $m[i, j]= 0    ,         if: i=j $\n\n​\t$m[i, j]= min_{i<k<j}{ m[i, k]+m[k+1, j]+p_{i-1}p_kp_j}     ,\t  if : i<j$\n\n​\t由此，我们可以自底向上的递归求解该问题，第一步：求m[1,1]，接着可求解m[2,2]、m[1,2]，然后求m[3,3]、m[2,3]、m[1,3]、、、求解过程中，动态的求解出了每一步的最优解，最终的结果m[1,n]即是我们要找的最优解：\n\n<img src=\"\\img\\算法\\矩阵连乘分析二.JPG\" height=60%>\n\n###### 算法伪代码\n\n```c\nFOR  i=1 TO  n DO\n\tm[i, i]=0; \nFOR  l=2 TO  n   /* 计算 l 对角线 */ \n\tFOR  i=1 TO  n-l+1  \n\t\tj=i+l-1;\n        m[i, j]=∞;\n        FOR  k = i To  j-1  /* 计算m[i,j] */\n        \tq=m[i, k]+m[k+1, j]+pi-1pkpj \n        \tIF  q<m[i, j] THEN  m[i,j]=q; \n```\n\n时间复杂度：O($n^3$),空间复杂度O($n^2$)\n\n###### 代码示例：\n\n```\n/**\n\t * 分治算法求最优解\n\t * \n\t * @return 矩阵连乘的最优解所需乘法次数\n\t */\n\tstatic void devideConquer() {\n\t\tsum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tpath[i][j] = 0;\n\t\t\t\tresult[i][j] = infty;\n\t\t\t\tif (i == j) {\n\t\t\t\t\tresult[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int l = 1; l < n; l++ ){\n\t\t\tfor (int i = 0; i <= n - l - 1; i++) {\n\t\t\t\tint j = i + l;\n\t\t\t\tresult[i][j] = infty;\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tint temp = (matrixs.get(i).getX()) * (matrixs.get(k).getY()) * (matrixs.get(j).getY());\n\t\t\t\t\tint num = result[i][k] + result[k + 1][j] + temp;\n\t\t\t\t\tif (num < result[i][j]) {\n\t\t\t\t\t\tresult[i][j] = num;\n\t\t\t\t\t\tpath[i][j] = k;//用于记录运算的先后顺序\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n\n\n##### 贪心算法\n\n​\t贪心算法循环从连乘的矩阵中选出两个相邻矩阵乘法次数最小的优先进行乘法运算，并将运算结果更新到连乘的矩阵中，直到最后只有一个矩阵为止。\n\n​\t需要注意的是，贪心算法每次找到局部最优解，但结果不一定是全局最优解。\n\n###### 代码示例\n\n```\n\t/**\n\t * 贪心算法\n\t */\n\tstatic void greedy() {\n\t\tsum = 0;\n\t\tArrayList<Pair> tempPairs = matrixs;\n\t\tint nn = tempPairs.size();\n\t\tint min = infty;\n\t\tint tempNum = 0;\n\t\tint index = 0;//记录每次循环中需要先计算的矩阵下标\n\t\t\n\t\twhile(nn > 1) {\n\t\t\tmin = infty;\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i< nn-1; i++) {\n\t\t\t\ttempNum = tempPairs.get(i).getX()*tempPairs.get(i).getY()*tempPairs.get(i+1).getY();\n\t\t\t\tif(min > tempNum) {\n\t\t\t\t\tmin = tempNum;\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPair pair = new Pair(tempPairs.get(index).getX(), tempPairs.get(index+1).getY());\n\t\t\ttempPairs.remove(index+1);\n\t\t\ttempPairs.remove(index);\n\t\t\ttempPairs.add(index, pair);\n\t\t\tnn = tempPairs.size();\n\t\t\tsum += min;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n```\n\n\n\n\n\n\n","source":"_posts/矩阵连乘——动态规划和贪心.md","raw":"---\ntitle: 矩阵连乘——动态规划和贪心\ndate: 2019-03-23 16:05:48\ndescription: 男朋友决定每天写进blog一个算法课上的示例，我不想落后，决定一起开始这个工程啦(#^.^#)。第一个当然是我比较感兴趣的矩阵连乘求最优的算法了。\ntags:\n - 算法\n - 矩阵连乘\n - 动态规划\n - 贪心\ncategories: 算法\n---\n\n​\t男朋友决定每天写进blog一个算法课上的示例，我不想落后，决定一起开始这个工程啦(#^.^#)。第一个当然是我比较感兴趣的矩阵连乘求最优的算法了。\n\n```\n输入：<A1,A2, ..., An>, Ai是(pi -1) * pi矩阵 \n\n输出：计算A1 * A2 *... * An的最小代价方法\n```\n\n##### 动态规划\n\n一般给出的是动态规划算法，使用动态规划，是因为矩阵连乘可以分解为若干个具有重叠性的子问题：\n\n<img src=\"\\img\\算法\\矩阵连乘分解图.JPG\" height=40%>\n\n\n\n​\t我们可以递归的求解每一种方式的代价，进而通过比较得到乘法次数最少的方案即最优解：\n$$\nA_i\\times A_{i+1}\\times...\\times A_j = \\begin{cases}(A_i) & \\times(A_{i+1}\\times...\\times A_j)\\\\(A_i\\times A_{i+1})&\\times(A_{i+2}\\times...\\times A_j)\\\\...\\\\(A_i\\times...\\times A_k)\\times(A_{k+1}\\times...\\times A_j)\\\\...\\\\(A_i\\times...\\times A_{j-1})\\times(A_j)\\end{cases}\n$$\n​\t考虑到所有的k，优化解的代价方程为:\n\n​\t $m[i, j]= 0    ,         if: i=j $\n\n​\t$m[i, j]= min_{i<k<j}{ m[i, k]+m[k+1, j]+p_{i-1}p_kp_j}     ,\t  if : i<j$\n\n​\t由此，我们可以自底向上的递归求解该问题，第一步：求m[1,1]，接着可求解m[2,2]、m[1,2]，然后求m[3,3]、m[2,3]、m[1,3]、、、求解过程中，动态的求解出了每一步的最优解，最终的结果m[1,n]即是我们要找的最优解：\n\n<img src=\"\\img\\算法\\矩阵连乘分析二.JPG\" height=60%>\n\n###### 算法伪代码\n\n```c\nFOR  i=1 TO  n DO\n\tm[i, i]=0; \nFOR  l=2 TO  n   /* 计算 l 对角线 */ \n\tFOR  i=1 TO  n-l+1  \n\t\tj=i+l-1;\n        m[i, j]=∞;\n        FOR  k = i To  j-1  /* 计算m[i,j] */\n        \tq=m[i, k]+m[k+1, j]+pi-1pkpj \n        \tIF  q<m[i, j] THEN  m[i,j]=q; \n```\n\n时间复杂度：O($n^3$),空间复杂度O($n^2$)\n\n###### 代码示例：\n\n```\n/**\n\t * 分治算法求最优解\n\t * \n\t * @return 矩阵连乘的最优解所需乘法次数\n\t */\n\tstatic void devideConquer() {\n\t\tsum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tpath[i][j] = 0;\n\t\t\t\tresult[i][j] = infty;\n\t\t\t\tif (i == j) {\n\t\t\t\t\tresult[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int l = 1; l < n; l++ ){\n\t\t\tfor (int i = 0; i <= n - l - 1; i++) {\n\t\t\t\tint j = i + l;\n\t\t\t\tresult[i][j] = infty;\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tint temp = (matrixs.get(i).getX()) * (matrixs.get(k).getY()) * (matrixs.get(j).getY());\n\t\t\t\t\tint num = result[i][k] + result[k + 1][j] + temp;\n\t\t\t\t\tif (num < result[i][j]) {\n\t\t\t\t\t\tresult[i][j] = num;\n\t\t\t\t\t\tpath[i][j] = k;//用于记录运算的先后顺序\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n\n\n##### 贪心算法\n\n​\t贪心算法循环从连乘的矩阵中选出两个相邻矩阵乘法次数最小的优先进行乘法运算，并将运算结果更新到连乘的矩阵中，直到最后只有一个矩阵为止。\n\n​\t需要注意的是，贪心算法每次找到局部最优解，但结果不一定是全局最优解。\n\n###### 代码示例\n\n```\n\t/**\n\t * 贪心算法\n\t */\n\tstatic void greedy() {\n\t\tsum = 0;\n\t\tArrayList<Pair> tempPairs = matrixs;\n\t\tint nn = tempPairs.size();\n\t\tint min = infty;\n\t\tint tempNum = 0;\n\t\tint index = 0;//记录每次循环中需要先计算的矩阵下标\n\t\t\n\t\twhile(nn > 1) {\n\t\t\tmin = infty;\n\t\t\tindex = 0;\n\t\t\tfor(int i = 0; i< nn-1; i++) {\n\t\t\t\ttempNum = tempPairs.get(i).getX()*tempPairs.get(i).getY()*tempPairs.get(i+1).getY();\n\t\t\t\tif(min > tempNum) {\n\t\t\t\t\tmin = tempNum;\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPair pair = new Pair(tempPairs.get(index).getX(), tempPairs.get(index+1).getY());\n\t\t\ttempPairs.remove(index+1);\n\t\t\ttempPairs.remove(index);\n\t\t\ttempPairs.add(index, pair);\n\t\t\tnn = tempPairs.size();\n\t\t\tsum += min;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n```\n\n\n\n\n\n\n","slug":"矩阵连乘——动态规划和贪心","published":1,"updated":"2019-03-23T12:03:54.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvrtri0s0003tku31yen1jd0","content":"<p>​    男朋友决定每天写进blog一个算法课上的示例，我不想落后，决定一起开始这个工程啦(#^.^#)。第一个当然是我比较感兴趣的矩阵连乘求最优的算法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&lt;A1,A2, ..., An&gt;, Ai是(pi -1) * pi矩阵 </span><br><span class=\"line\"></span><br><span class=\"line\">输出：计算A1 * A2 *... * An的最小代价方法</span><br></pre></td></tr></table></figure>\n<h5 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h5><p>一般给出的是动态规划算法，使用动态规划，是因为矩阵连乘可以分解为若干个具有重叠性的子问题：</p>\n<p><img src=\"\\img\\算法\\矩阵连乘分解图.JPG\" height=\"40%\"></p>\n<p>​    我们可以递归的求解每一种方式的代价，进而通过比较得到乘法次数最少的方案即最优解：<br>$$<br>A_i\\times A_{i+1}\\times…\\times A_j = \\begin{cases}(A_i) &amp; \\times(A_{i+1}\\times…\\times A_j)\\(A_i\\times A_{i+1})&amp;\\times(A_{i+2}\\times…\\times A_j)\\…\\(A_i\\times…\\times A_k)\\times(A_{k+1}\\times…\\times A_j)\\…\\(A_i\\times…\\times A_{j-1})\\times(A_j)\\end{cases}<br>$$<br>​    考虑到所有的k，优化解的代价方程为:</p>\n<p>​     $m[i, j]= 0    ,         if: i=j $</p>\n<p>​    $m[i, j]= min_{i&lt;k&lt;j}{ m[i, k]+m[k+1, j]+p_{i-1}p_kp_j}     ,      if : i&lt;j$</p>\n<p>​    由此，我们可以自底向上的递归求解该问题，第一步：求m[1,1]，接着可求解m[2,2]、m[1,2]，然后求m[3,3]、m[2,3]、m[1,3]、、、求解过程中，动态的求解出了每一步的最优解，最终的结果m[1,n]即是我们要找的最优解：</p>\n<p><img src=\"\\img\\算法\\矩阵连乘分析二.JPG\" height=\"60%\"></p>\n<h6 id=\"算法伪代码\"><a href=\"#算法伪代码\" class=\"headerlink\" title=\"算法伪代码\"></a>算法伪代码</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR  i=<span class=\"number\">1</span> TO  n DO</span><br><span class=\"line\">\tm[i, i]=<span class=\"number\">0</span>; </span><br><span class=\"line\">FOR  l=<span class=\"number\">2</span> TO  n   <span class=\"comment\">/* 计算 l 对角线 */</span> </span><br><span class=\"line\">\tFOR  i=<span class=\"number\">1</span> TO  n-l+<span class=\"number\">1</span>  </span><br><span class=\"line\">\t\tj=i+l<span class=\"number\">-1</span>;</span><br><span class=\"line\">        m[i, j]=∞;</span><br><span class=\"line\">        FOR  k = i To  j<span class=\"number\">-1</span>  <span class=\"comment\">/* 计算m[i,j] */</span></span><br><span class=\"line\">        \tq=m[i, k]+m[k+<span class=\"number\">1</span>, j]+pi<span class=\"number\">-1</span>pkpj </span><br><span class=\"line\">        \tIF  q&lt;m[i, j] THEN  m[i,j]=q;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：O($n^3$),空间复杂度O($n^2$)</p>\n<h6 id=\"代码示例：\"><a href=\"#代码示例：\" class=\"headerlink\" title=\"代码示例：\"></a>代码示例：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">\t * 分治算法求最优解</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @return 矩阵连乘的最优解所需乘法次数</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tstatic void devideConquer() &#123;</span><br><span class=\"line\">\t\tsum = 0;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t\tfor (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">\t\t\t\tpath[i][j] = 0;</span><br><span class=\"line\">\t\t\t\tresult[i][j] = infty;</span><br><span class=\"line\">\t\t\t\tif (i == j) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[i][j] = 0;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (int l = 1; l &lt; n; l++ )&#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt;= n - l - 1; i++) &#123;</span><br><span class=\"line\">\t\t\t\tint j = i + l;</span><br><span class=\"line\">\t\t\t\tresult[i][j] = infty;</span><br><span class=\"line\">\t\t\t\tfor (int k = i; k &lt; j; k++) &#123;</span><br><span class=\"line\">\t\t\t\t\tint temp = (matrixs.get(i).getX()) * (matrixs.get(k).getY()) * (matrixs.get(j).getY());</span><br><span class=\"line\">\t\t\t\t\tint num = result[i][k] + result[k + 1][j] + temp;</span><br><span class=\"line\">\t\t\t\t\tif (num &lt; result[i][j]) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tresult[i][j] = num;</span><br><span class=\"line\">\t\t\t\t\t\tpath[i][j] = k;//用于记录运算的先后顺序</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h5><p>​    贪心算法循环从连乘的矩阵中选出两个相邻矩阵乘法次数最小的优先进行乘法运算，并将运算结果更新到连乘的矩阵中，直到最后只有一个矩阵为止。</p>\n<p>​    需要注意的是，贪心算法每次找到局部最优解，但结果不一定是全局最优解。</p>\n<h6 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 贪心算法</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void greedy() &#123;</span><br><span class=\"line\">\tsum = 0;</span><br><span class=\"line\">\tArrayList&lt;Pair&gt; tempPairs = matrixs;</span><br><span class=\"line\">\tint nn = tempPairs.size();</span><br><span class=\"line\">\tint min = infty;</span><br><span class=\"line\">\tint tempNum = 0;</span><br><span class=\"line\">\tint index = 0;//记录每次循环中需要先计算的矩阵下标</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile(nn &gt; 1) &#123;</span><br><span class=\"line\">\t\tmin = infty;</span><br><span class=\"line\">\t\tindex = 0;</span><br><span class=\"line\">\t\tfor(int i = 0; i&lt; nn-1; i++) &#123;</span><br><span class=\"line\">\t\t\ttempNum = tempPairs.get(i).getX()*tempPairs.get(i).getY()*tempPairs.get(i+1).getY();</span><br><span class=\"line\">\t\t\tif(min &gt; tempNum) &#123;</span><br><span class=\"line\">\t\t\t\tmin = tempNum;</span><br><span class=\"line\">\t\t\t\tindex = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tPair pair = new Pair(tempPairs.get(index).getX(), tempPairs.get(index+1).getY());</span><br><span class=\"line\">\t\ttempPairs.remove(index+1);</span><br><span class=\"line\">\t\ttempPairs.remove(index);</span><br><span class=\"line\">\t\ttempPairs.add(index, pair);</span><br><span class=\"line\">\t\tnn = tempPairs.size();</span><br><span class=\"line\">\t\tsum += min;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.out.println(sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>​    男朋友决定每天写进blog一个算法课上的示例，我不想落后，决定一起开始这个工程啦(#^.^#)。第一个当然是我比较感兴趣的矩阵连乘求最优的算法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：&lt;A1,A2, ..., An&gt;, Ai是(pi -1) * pi矩阵 </span><br><span class=\"line\"></span><br><span class=\"line\">输出：计算A1 * A2 *... * An的最小代价方法</span><br></pre></td></tr></table></figure>\n<h5 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h5><p>一般给出的是动态规划算法，使用动态规划，是因为矩阵连乘可以分解为若干个具有重叠性的子问题：</p>\n<p><img src=\"\\img\\算法\\矩阵连乘分解图.JPG\" height=\"40%\"></p>\n<p>​    我们可以递归的求解每一种方式的代价，进而通过比较得到乘法次数最少的方案即最优解：<br>$$<br>A_i\\times A_{i+1}\\times…\\times A_j = \\begin{cases}(A_i) &amp; \\times(A_{i+1}\\times…\\times A_j)\\(A_i\\times A_{i+1})&amp;\\times(A_{i+2}\\times…\\times A_j)\\…\\(A_i\\times…\\times A_k)\\times(A_{k+1}\\times…\\times A_j)\\…\\(A_i\\times…\\times A_{j-1})\\times(A_j)\\end{cases}<br>$$<br>​    考虑到所有的k，优化解的代价方程为:</p>\n<p>​     $m[i, j]= 0    ,         if: i=j $</p>\n<p>​    $m[i, j]= min_{i&lt;k&lt;j}{ m[i, k]+m[k+1, j]+p_{i-1}p_kp_j}     ,      if : i&lt;j$</p>\n<p>​    由此，我们可以自底向上的递归求解该问题，第一步：求m[1,1]，接着可求解m[2,2]、m[1,2]，然后求m[3,3]、m[2,3]、m[1,3]、、、求解过程中，动态的求解出了每一步的最优解，最终的结果m[1,n]即是我们要找的最优解：</p>\n<p><img src=\"\\img\\算法\\矩阵连乘分析二.JPG\" height=\"60%\"></p>\n<h6 id=\"算法伪代码\"><a href=\"#算法伪代码\" class=\"headerlink\" title=\"算法伪代码\"></a>算法伪代码</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FOR  i=<span class=\"number\">1</span> TO  n DO</span><br><span class=\"line\">\tm[i, i]=<span class=\"number\">0</span>; </span><br><span class=\"line\">FOR  l=<span class=\"number\">2</span> TO  n   <span class=\"comment\">/* 计算 l 对角线 */</span> </span><br><span class=\"line\">\tFOR  i=<span class=\"number\">1</span> TO  n-l+<span class=\"number\">1</span>  </span><br><span class=\"line\">\t\tj=i+l<span class=\"number\">-1</span>;</span><br><span class=\"line\">        m[i, j]=∞;</span><br><span class=\"line\">        FOR  k = i To  j<span class=\"number\">-1</span>  <span class=\"comment\">/* 计算m[i,j] */</span></span><br><span class=\"line\">        \tq=m[i, k]+m[k+<span class=\"number\">1</span>, j]+pi<span class=\"number\">-1</span>pkpj </span><br><span class=\"line\">        \tIF  q&lt;m[i, j] THEN  m[i,j]=q;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：O($n^3$),空间复杂度O($n^2$)</p>\n<h6 id=\"代码示例：\"><a href=\"#代码示例：\" class=\"headerlink\" title=\"代码示例：\"></a>代码示例：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">\t * 分治算法求最优解</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @return 矩阵连乘的最优解所需乘法次数</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tstatic void devideConquer() &#123;</span><br><span class=\"line\">\t\tsum = 0;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t\tfor (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">\t\t\t\tpath[i][j] = 0;</span><br><span class=\"line\">\t\t\t\tresult[i][j] = infty;</span><br><span class=\"line\">\t\t\t\tif (i == j) &#123;</span><br><span class=\"line\">\t\t\t\t\tresult[i][j] = 0;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfor (int l = 1; l &lt; n; l++ )&#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt;= n - l - 1; i++) &#123;</span><br><span class=\"line\">\t\t\t\tint j = i + l;</span><br><span class=\"line\">\t\t\t\tresult[i][j] = infty;</span><br><span class=\"line\">\t\t\t\tfor (int k = i; k &lt; j; k++) &#123;</span><br><span class=\"line\">\t\t\t\t\tint temp = (matrixs.get(i).getX()) * (matrixs.get(k).getY()) * (matrixs.get(j).getY());</span><br><span class=\"line\">\t\t\t\t\tint num = result[i][k] + result[k + 1][j] + temp;</span><br><span class=\"line\">\t\t\t\t\tif (num &lt; result[i][j]) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tresult[i][j] = num;</span><br><span class=\"line\">\t\t\t\t\t\tpath[i][j] = k;//用于记录运算的先后顺序</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h5><p>​    贪心算法循环从连乘的矩阵中选出两个相邻矩阵乘法次数最小的优先进行乘法运算，并将运算结果更新到连乘的矩阵中，直到最后只有一个矩阵为止。</p>\n<p>​    需要注意的是，贪心算法每次找到局部最优解，但结果不一定是全局最优解。</p>\n<h6 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 贪心算法</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void greedy() &#123;</span><br><span class=\"line\">\tsum = 0;</span><br><span class=\"line\">\tArrayList&lt;Pair&gt; tempPairs = matrixs;</span><br><span class=\"line\">\tint nn = tempPairs.size();</span><br><span class=\"line\">\tint min = infty;</span><br><span class=\"line\">\tint tempNum = 0;</span><br><span class=\"line\">\tint index = 0;//记录每次循环中需要先计算的矩阵下标</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile(nn &gt; 1) &#123;</span><br><span class=\"line\">\t\tmin = infty;</span><br><span class=\"line\">\t\tindex = 0;</span><br><span class=\"line\">\t\tfor(int i = 0; i&lt; nn-1; i++) &#123;</span><br><span class=\"line\">\t\t\ttempNum = tempPairs.get(i).getX()*tempPairs.get(i).getY()*tempPairs.get(i+1).getY();</span><br><span class=\"line\">\t\t\tif(min &gt; tempNum) &#123;</span><br><span class=\"line\">\t\t\t\tmin = tempNum;</span><br><span class=\"line\">\t\t\t\tindex = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tPair pair = new Pair(tempPairs.get(index).getX(), tempPairs.get(index+1).getY());</span><br><span class=\"line\">\t\ttempPairs.remove(index+1);</span><br><span class=\"line\">\t\ttempPairs.remove(index);</span><br><span class=\"line\">\t\ttempPairs.add(index, pair);</span><br><span class=\"line\">\t\tnn = tempPairs.size();</span><br><span class=\"line\">\t\tsum += min;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.out.println(sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"javaEE-framework——Struts2","date":"2019-05-06T02:40:48.000Z","description":"习惯了学习时记笔记，虽然不多，但是包含了Strust2的大部分内容，如果内容有错误的地方，欢迎大家批评指正","_content":"[TOC]\n\n### 知识详解\n\n#### 简介\n\n##### 概念\n\n运行web层，处理访问服务器的请求，代理Servlet\n\nstruct2与struct1区别：struct2前身是webwork框架\n\n##### 优势\n\n自动封装参数、参数校验、结果的处理(转发(重定向))、国际化、显式等待页面、表单防止重复提交\n\n##### 搭建\n\n- 导包\n- 书写action类\n- 书写src/structs.xml核心配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE struts PUBLIC\n\t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t\"http://struts.apache.org/dtds/struts-2.3.dtd\">\n<struts>\n\t<package name=\"hello\" namespace=\"/hello\" extends=\"structs-default\">\n\t\t<action name=\"HelloAction\" class=\"cn_struct2.HelloAction\" method=\"hello\">\n\t\t\t<result name=\"success\" >/hello.jsp</result>\n\t\t</action>\n\t</package>\t\t\n</struts>\n```\n\n- 将structs2核心过滤器配置到web.xml\n\n```xml\n<filter>\n  \t<filter-name>structs2</filter-name>\n  \t<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n  </filter>\n  <filter-mapping>\n  \t<filter-name>structs2</filter-name>\n  \t<url-pattern>/*</url-pattern>\n  </filter-mapping>\n```\n\n##### Struts构造原理图\n\n<img src=\"\\img\\javaWeb\\struts原理.JPG\" height=550px>\n\n##### 配置详解\n\n###### struts.xml配置\n\n```xml\n<struts>\n<!--package:将Action配置封装，可在package里配置多个action\nname：包的名字（任意），起到标识作用，不能与其他包重复\nnamespace：给action的访问路径中定义一个命名空间\nextends：必选属性，继承一个指定包，默认struts-default\nadstract:包是否是抽象的，标识性属性，该包不能独立运行，只能被继承\n -->\n\t<package name=\"hello\" namespace=\"/hello\" extends=\"struts-default\">\n\t\t<!-- action类：配置action类\n\t\tname：决定了Action访问资源 \n\t\tcalss:action的完整类名\n\t\tmethod：指定调用Action中的哪个方法进行处理请求\n\t\t -->\n\t\t<action name=\"HelloAction\" class=\"cn_struct2.HelloAction\" method=\"hello\">\n\t\t\t<!-- result：结果配置\n\t\t\tname：标识结果处理的名称：与action方法的返回值对应\n\t\t\ttype：指定定义哪个Result类来处理结果，默认使用转发\n\t\t\t标签体：填写页面的相对路径\n\t\t\t -->\n\t\t\t<result name=\"success\" >/hello.jsp</result>\n\t\t</action>\n\t</package>\t\t\n</struts>\n```\n\n###### struts2常量配置\n\n**default.properties文件所在位置：**\n\n​\tLibraries\n\n​\t\tWeb App Libraries\n\n​\t\t\tstruts2-core-2.5.20.jar\n\n​\t\t\t\tstatic\n\n​\t\t\t\t\tdefault.properties\n\n**常量的三种修改方式：**\n\n方式先后也是文件加载顺序\n\n- struts.xml中,在\\<struts>根下，配置(常用)：\n\n  ```\n  <struts>\n  \t<constant name=\"\" value=\"\">\n  \t...\n  </struts>\t\n  ```\n\n- src下新建struts.properties，在文件里填写修改的键值对\n\n- web.xml中，filter前进行配置\n\n  ```\n  <context-param>\n  \t<param-name> </param-name>\n  \t<param-value> </param-value>\n  </context-param>\t\n  <filter>......\t\n  ```\n\n**常量**\n\n```xml\n<!-- i18n：国际化，使用配置文件配置多个语言，可解决post提交乱码问题-->\n<constant name=\"struts.i18n.encoding=UTF-8:\" value=\"UTF-8\">\n\n<!--struts.action.extension:指定访问action的后缀名-->\n<constant name=\"struts.action.extension\" value=\"action,,\">\n<!--逗号标识隔开两个值-->\n\n<!--指定struts是否以开放模式运行\n\t1、可热加载主配置（不需重启即可生效）\n\t2、提供更多错误信息输出，方便调试-->\n<constant name=\"struts.devMode\" value=\"true\">\n```\n\n###### struts2配置进阶\n\n**动态方法调用**\n\n方式一：（了解）\n\n- 调用方法时，方法前加 ‘ ！’\n\n- 主配置文件，struts下配置：\n\n```\n<!-- 配置动态方法调用是否开启的常量，默认是false -->\n<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/>\n```\n\n- 次配置\n\n```xml\n<struts>\t\n\t<package name=\"dynamic\" namespace=\"/dynamic\" extends=\"struts-default\">\n\t\t<global-allowed-methods>add,update</global-allowed-methods>\n\t\t<action name=\"Demo1Action\" class=\"cn_struct2.Demo1Action\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t</action>\n\t</package>\t\n</struts>\n```\n\n方式二：\n\n次配置\n\n```\n<struts>\t\n\t<package name=\"dynamic\" namespace=\"/dynamic\" extends=\"struts-default\">\n\t\t<global-allowed-methods>add,update</global-allowed-methods>\n\t\t<action name=\"Demo1Action_*\" class=\"cn_struct2.Demo1Action\" method=\"{1}\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t</action>\n\t</package>\t\n</struts>\n```\n\n**默认配置**（了解）\n\n```xml\n<package name=\"dynamic\" namespace=\"/dynamic\" extends=\"struts-default\">\n\t\t<!-- 找不到包下的action，会使用DemoAction作为默认action请求 -->\n\t\t<default-action-ref name=\"DemoAction\"></default-action-ref>\n\t\t<!-- method:execute -->\n\t\t<!-- result的name属性：success -->\n\t\t<!-- result的type属性：dispatcher转发 -->\t\n\t\t<!-- class属性：com.opensymphony.xwork2.ActionSupport -->\n\t\t<action name=\"Demo1Action\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t</action>\t\n</package>\n```\n\n##### action类创建方式\n\naction类：public,返回String，可抛异常\n\n1、创建一个类，可以是POJO(普通类，不需要继承任何父类或实现接口)，使struts2代码侵入性更低\n\n2、实现Action接口，\n\n​\t1）里面有execute方法，提供Action方法的规范\n\n​\t2）Action接口预置了一些字符串，可在返回时使用\n\n3、继承一个类，ActionSupport（重点）\n\n​\t帮助实现了Action、Validateable、ValidationAwre、TextProvider、LocaleProvider\n\n#### 结果跳转方式\n\n##### 转发（默认 ）\n\n##### 重定向\n\n##### 转发到Action\n\n```xml\n<result name=\"success\" type=\"chain\">\n\t<param name=\"actionName\" >DemoAction</param>\n\t<param name=\"namespace\" >/</param>\n</result>\n```\n\n##### 重定向到Action\n\n```xml\n<result name=\"success\" type=\"rediretAction\">\n\t<param name=\"actionName\" >DemoAction</param>\n\t<param name=\"namespace\" >/</param>\n</result>\n```\n\n#### 访问ServletAPI方式\n\n**ActionContext**:数据中心，可获得原生request(HttpServletRequest)、原生response(HttpServletResponse)、原生ServletContext、request域(Map)、session域(Map)、application域(Map)、params(Map)、attr域(Map,三个域合一)、ValueStack、、、\n\n生命周期：每次请求都会创建一个与请求对应的ActionContext对象，请求处理完域销毁，与当前线程绑定\n\n三种方式本质都是从ActionContext获得\n\n##### 通过actionContext\n\n```java\npublic String hello() {\n\t\t//request域(struts2不推荐用request域）\n\t\t//request域和ActionContext生命周期一致，可用ActionContext代替request域\n\t\tMap<String, Object> object = (Map<String, Object>)ActionContext.getContext().get(\"request\");\n\t\tActionContext.getContext().put(\"name\", \"value\");\n\t\t\n\t\t//session域\n\t\tMap<String, Object> session = ActionContext.getContext().getSession();\n\t\t\n\t\t//application域\n\t\tMap<String, Object> application = ActionContext.getContext().getApplication();\n\t\t\n\t\tSystem.out.println(\"hello world\");\n\t\treturn \"success\";\n\t}\n```\n\n##### 通过ServletActionContext\n\n不推荐\n\n```java\n\t//获得actionAPI方式2\n\t\tpublic String hello2() {\n\t\t\t//原生request域\n\t\t\tHttpServletRequest request = ServletActionContext.getRequest();\n\t\t\t\n\t\t\t//原生response域\n\t\t\tHttpServletResponse response = ServletActionContext.getResponse();\n\t\t\t\n\t\t\t//原生session域\n\t\t\tHttpSession session =request.getSession();\n\t\t\t\n\t\t\t//原生servletContext域\n\t\t\tServletContext servletContext = ServletActionContext.getServletContext();\n\t\t\t\n\t\t\tSystem.out.println(\"hello world\");\n\t\t\treturn \"success\";\n\t\t}\n```\n\n##### 实现接口Aware\n\n```java \nPublic class Demo entends ActioSUpport implments ServletRequestAware{\n    private HttpServletRequest request;\n    \n    public String execute() throws Exception{\n        System.out.println(\"原生Request\");\n        return SUCCESS;\n    }\n    \n    @Override\n    ppublic void setServletRequest(HttpServletRequest request){\n        this.request = request;\n    }\n}\n```\n\n#### 获得参数\n\n##### 扩展\n\n- **Struts MVC**\n\nFilter：Ctroller\n\nAction:Module\n\nResult:View\n\n- Action生命周期：每次请求到来时，都会创建一个新的Action实例，不会产生并发现象，线程安全，可使用成员变量来接受参数\n\n##### 属性驱动获得参数\n\nAction准备与参数键同名属性\n\n可自动转换八大基本类型及其包装类和Date(支持特定字符串类型,例：yyyy-MM-dd)\n\n```java \n//获得参数\npublic class Demo8Action extends ActionSupport{\n\t//每次请求都会创建新的Action对象\n\t//准备与参数键名称相同的属性\n\tprivate String cust_name;\n\t\n\tpublic String execute() {\n\t\tSystem.out.println(\"name的参数值：\"+cust_name);\n\t\treturn \"success\";\n\t}\n\n\tpublic String getCust_name() {\n\t\treturn cust_name;\n\t}\n\n\tpublic void setCust_name(String cust_name) {\n\t\tthis.cust_name = cust_name;\n\t}\t\n}\n```\n\n\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\t用户名：<input type=\"text\" name=\"Customer.cust_name\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\n```\n\n##### 对象驱动\n\nAction准备与参数键同名属性    xxx.yyy\n\n```java\npublic class Demo8Action extends ActionSupport{\n\t//准备customer属性\n\tCustomer customer;\n\t\n\tpublic String execute() {\n\t\tSystem.out.println(customer.toString);\n\t\treturn \"success\";\n\t}\n\n\tpublic Customer getCustomer() {\n\t\treturn customer;\n\t}\n\n\tpublic void setCustomer(Customer customer) {\n\t\tthis.customer = customer;\n\t}\t\n}\n```\n\n\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\t用户名：<input type=\"text\" name=\"customer.name\"/><br>\n\t\t年龄：<input type=\"text\" name=\"customer.age\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\n```\n\n##### 模型驱动\n\n实现ModelDrivern接口，实现getModel方法，返回需要封装参数的对象\n\n```java \npublic class Demo8Action extends ActionSupport implements ModelDriven<Customer>{\n\t//准备customer对象\n\tprivate Customer customer = new Customer();\n\t\n\tpublic String execute() {\n\t\tSystem.out.println(customer.toString);\n\t\treturn \"success\";\n\t}\n\t\n\t@Override\n\tpublic Customer getModel(){\n        return customer\n\t}\n}\n```\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\t用户名：<input type=\"text\" name=\"name\"/><br>\n\t\t年龄：<input type=\"text\" name=\"age\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\n```\n\n##### 集合类型封装获得参数：\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\tlist：<input type=\"text\" name=\"list\"/><br>\n\t\tlist：<input type=\"text\" name=\"list[3]\"/><br>\n\t\tmap：<input type=\"text\" name=\"map['haha']\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\t\n```\n\n注：封装集合类型参数在前端可直接使用，使用时，map需先给出key\n\n### 表达式\n\n#### OGNL表达式\n\nOGNL:对象视图导航语言，例：$(user.addr.name)这种写法就成为对象视图导航\n\nOGNL不仅仅可视图导航，还支持比EL表达式更加丰富的功能\n\n##### 准备工作\n\nOGNL从OGNLContext对象取值（复习：EL取值：11大内置对象）\n\nOGNLContext对象分为ROOT和Context两部分：\n\n​\tROOT：可放置任何对象\n\n​\tContext:\t只存放Map\n\n##### 基本语法\n\n###### 取值\n\nROOT取值：expression直接写要取值的属性名\n\nContext取值：expression写:#key.属性\n\n```java \npublic class demo1 {\n\tpublic void fun1() throws OgnlException {\n\t\t//1、准备OGNLContext\n\t\t//准备ROOT\n\t\tUser rootUser = new User(\"Tom\", 5);\n\t\t//准备Context\n\t\tMap<String ,User> context = new HashMap();\n\t\tcontext.put(\"user1\",new User(\"lucy\", 7));\n\t\tcontext.put(\"user2\",new User(\"rose\", 8));\n\t\t\n\t\tOgnlContext oc = new OgnlContext();\n\t\toc.setRoot(rootUser);\n\t\toc.setValues(context);\n\t\t\n\t\t//2、书写OGNL表达式\n\t\tString name = Ognl.getValue(\"name\", context, oc.getRoot());\n\t\tString name = Ognl.getValue(\"#user1.name\", context, oc.getRoot());\n\t}\n}\n```\n\n###### 赋值\n\nROOT：属性=值\n\nContext:#key.属性=值\n\n```java \n//赋值\n\tString name = Ognl.getValue(\"name='jerry'\", context, oc.getRoot());\n\tString name = Ognl.getValue(\"#user1.name='jerry'\", context, oc.getRoot());\n\t//表达式可串联，但是如果表达式都有返回值，则取最后一个表达式的值\n```\n\n###### 调用方法\n\n```java\nOgnl.getValue(\"setName('jerry')\", context, oc.getRoot());\nString name = Ognl.getValue(\"getName()\", context, oc.getRoot());\n\nString name = Ognl.getValue(\"#user1.setName('jerry'),#user2.getName()\", context, oc.getRoot());\nString name = Ognl.getValue(\"#user1.getName()\", context, oc.getRoot());\n\n//静态方法调用\nString name = （String）Ognl.getValue(\"@完整包名@方法名\", context, oc.getRoot());\nDouble pi = (Double)Ognl.getValue(\"@java.lang.Math@PI\", context, oc.getRoot());\n//Math是OGNL对象的内置对象\n(Double)Ognl.getValue(\"@@PI\", context, oc.getRoot());\n```\n\n###### 创建List和Map对象\n\n```java\n//创建list对象\nOgnl.getValue(\"{'hello','tom','penny'}\", context, oc.getRoot());\nString name1 = Ognl.getValue(\"{'hello','tom','penny'}[0]\", context, oc.getRoot());\nString name2 = Ognl.getValue(\"{'hello','tom','penny'}.get(1)\", context, oc.getRoot());\n\n//创建Map对象\nOgnl.getValue(\"#{'name':'Tome','age':18}\", context, oc.getRoot());\nString name3 = Ognl.getValue(\"{'hello','tom','penny'}['name']\", context, oc.getRoot());\nint age = = Ognl.getValue(\"{'hello','tom','penny'}.get('age')\", context, oc.getRoot());\n```\n\n\n\n#### OGNL与struts2结合\n\nOGNlContext-->ValueStack值栈\n\nROOT：栈，栈中放置当前访问的Action对象\n\nContext：ActionContext（数据中心）\n\n##### 结合体现：\n\n###### 参数接收\n\nstruts2的参数交给OGNL引擎处理\n\n<img src=\"\\img\\javaWeb\\OGNL_Struts原理.JPG\" height=200px>\n\n<img src=\"\\img\\javaWeb\\OGNL_Struts原理2.JPG\" height=250px>\n\n```java\n//将参数压入栈\n//方法一\n//public class DemoAction extends ActionSupport implements Preparable{\n//\tprivate Customer u = new Customer();\n//\tpublic String execute() {\n\n//\t\treturn SUCCESS;\n//\t}\n//\t@Override\n//\tpublic void prepare() throws Exception {\n//\t\t// TODO Auto-generated method stub\n//\t\t//压入栈顶\n//\t\t//1、获得栈值\n//\t\tValueStack vs = ActionContext.getContext().getValueStack();\n//\t\t\t\t\n//\t\t//2、将u压人栈顶\n//\t\tvs.push(u);\n//\t}\n//}\n\n//方法二\npublic class DemoAction extends ActionSupport implements ModelDriven<Customer>{\n\tprivate Customer u = new Customer();\n\tpublic String execute() {\n\t\t// TODO Auto-generated method stub\n\t\t//压入栈顶\n\t\t//1、获得栈值\n\t\tValueStack vs = ActionContext.getContext().getValueStack();\t\t\t\t\n\t\t//2、将u压人栈顶\n\t\tvs.push(u);\n\t\treturn SUCCESS;\n\t}\n\t@Override\n\tpublic Customer getModel() {\n\t\t// TODO Auto-generated method stub\n\t\treturn u;\n\t}\n}\n```\n\n###### 配置文件\n\n${ognl表达式}\n\n```xml\n<result name=\"success\" type=\"redirectAction\">\n\t<param name=\"actionName\" >DemoAction</param>\n\t<param name=\"namespace\" >/</param>\n\t<!--如果提交的参数struts看不懂，就会作为参数附加在重定向的路径之后，如果参数是动态的，可以OGNL\t\t表达式：\n\t  age=xx，${OGNL表达式}-->\n\t<param name=\"age\" >${age}</param>\n</result>\n```\n\n###### struts2标签\n\n\n\n#### 扩展:源码流程\n\n- request.getAttribute()查找顺序：\n  - 原生request域\n  - ValueStack的栈（Root）\n  - ValueStack的Context部分(ActionContext)\n\n- 拦截器的调用：递归调用\n\n  defaultActionInvocation调用interceptor.intercept()，interceptor调用defaultActionInvocation.invoke()\n\n### 拦截器\n\n准备工作：用户登录\n\n```java\npublic class UserAction extends ActionSupport implements ModelDriven<Customer>{\n\tprivate Customer customer = new Customer();\n\tprivate UserService us = new UserService();\n\t\n\tpublic String login() {\n\t\t//调用service，执行登录操作\n\t\tCustomer c = us.login(customer);\n\t\t//2、将返回的Customer对象放入session域作为登录标识\n\t\tActionContext.getContext().getSession().put(\"customer\",c);\n\t\t//3、重定向到项目的首页\n\t\treturn \"toHome\";//重定向页面的name属性\n\t\n\t}\n\t\t\n\t@Override\n\tpublic Customer getModel() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\t\n}\n```\n\n\n\n```java\npublic class UserService {\n\tpublic Customer login(Customer customer) {\n\t\t//Hibernate打开事务\n\t\n\t\tCustomerDao cd = new CustomerDao();\n\t\t//1、调用Dao根据登录名称查询的Customer对象\n\t\tCustomer existCustomer = cd.getByCode(customer.getCust_name().hashCode());\n\t\t\n\t\t//提交事务\n\t\t\n\t\t//抛出异常，用户不存在\n\t\tif(existCustomer==null) {\n\t\t\tthrow new RuntimeException(\"同户名不存在\");\n\t\t}\n\t\t//2、比对密码是否一致（Id)\n\t\tif(!existCustomer.getCust_id().equals(customer.getCust_id())) {\n\t\t\t//不一致，抛出异常提示\n\t\t\tthrow new RuntimeException(\"密码错误\");\n\t\t}\n\t\t\n\t\t//将数据库查询到的Customer返回\n\t\treturn existCustomer;\n\t}\t\n}\n```\n\n```xml\n<package name=\"crm\" namespace=\"/\" extends=\"struts-default\">\n\t<global-exception-mappings>\n\t\t<!--若出现该异常，跳转到结果为error的页面-->\n\t\t<exception-mapping result=\"error\" exception\"exception完整类名\">\n\t\t</exception-mapping>\n\t</global-exception-mappings>\n\t\n\t<action name=\"Demo1Action_*\" class=\"cn_struct2.Demo1Action\" method=\"{1}\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t\t<result name=\"error\">/login.jsp</result>\n\t</action>\n</package>\n```\n\n```\n<!--密码错误在新页面提示-->\n<!--跳转到的页面使用debug标签-->\n<%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\n\n<s:debug></s:debug>\n```\n\n#### 自定义拦截器\n\n拦截器生命周期：随项目的启动创建，随项目的关闭而销毁\n\n##### 拦截器的创建\n\n方式一：实现接口Interceptor\n\n方式二：继承AbstractInterceptor(该继承抽象类空实现了Interceptor)\n\n方式三：继承MethodFilterInterceptor，功能：定制拦截器拦截的方法,可定制需要拦截或不需要拦截的方法\n\n```java\n//拦截器：创建方式一\npublic class MyInterceptor implements Interceptor{}\n//方法二：\npublic class MyInterceptor_2 extends AbstractInterceptor{}\n//方式二：\n//功能：定制拦截器拦截的方法\n//实现方法doIntercept();\npublic class MyInterceptor_2 extends MethodFilterInterceptor{\n    @Override\n\tprotected String doIntercept(ActionInvocation arg0) throws Exception {\n\t\t//前处理\n\t\t\n\t\t//放行\n\t\tinvocation.invoke();\n\t\t\n\t\t//后处理\n\t\treturn null;\n\t}\n}\n```\n\n##### 拦截器配置\n\n##### 拦截方法指定\n\n不拦截和需要拦截的方法不能同时指定\n\n```xml\n<package>\n\t<interceptors>\n\t\t<!--注册拦截器-->\n\t\t<interceptor name=\"myInter\" class=\"完整类名\"></interceptor>\n\t\t<!--注册拦截器栈-->\n\t\t<interceptor-stack name=\"myStack\">\n\t\t\t<!--自定义拦截器默认 放在20个拦截器之前-->\n\t\t\t<interceptor-ref name=\"myInter\">\n            \t<param name=\"excludeMythods\">add,delete</param>                               </interceptor-ref>\n            \t<param name=\"includeMythods\">add,delete</param>                               </interceptor-ref>\n\t\t\t<interceptor-ref name=\"defaultStack\"></interceptor-ref>\n\t\t</interceptor-stack>\n\t</interceptors>\n\t<!--指定默认拦截器栈,作用范围是整个包-->\n\t<default-interceptor-ref name=\"myStack\"></default-interceptor-ref>\n\t<action name=\"myInter\" class=\"\">\n\t\t<!--或为action单独指定哪个拦截器-->\n\t\t<default-interceptor-ref name=\"myStack\"></default-interceptor-ref>\n\t\t<result name=\"error\">/index.jsp</result>\n\t</action>\n</package>\n```\n\n\n\n**定义全局结果集**\n\n```\n<global-results></global-results>\n```\n\n### 标签\n\n（了解）\n\nstruts标签分类：\n\n- 普通标签：\n  - 控制标签(iterater、if、elseif、else)\n  - 数据标签(property)\n\n- ul标签：\n  - 表单标签(form、textfield、password、file、checkboxlist、redio...)\n  - 非表单标签(Actionerror)\n\n#### 普通标签\n\n```jsp\n<!--普通标签-->\n<body>\n\t<!-- 遍历标签 iterator -->\n\t<s:interator value=\"#list\">\n\t\t<s:property/>\n\t</s:interator>\n\t<!-- 遍历方式二 -->\n\t<s:interator value=\"#list\" var=\"name\">\n\t\t<s:property value=\"#name\"/>\n\t</s:interator>\n\t\n\t<!-- if标签 -->\n\t<s:if test=\"#list.size()==4\">\n\t\tlist长度为4\n\t</s:if>\n\t<s:esle>\n\t\tlist长度不为4\n\t</s:esle>\n\t\n\t<!-- property标签 ,配合ognl表达式页面取值使用-->\n\t<s:property value=\"#value.size()\"/>\n\t<s:property value=\"#session.use.name\"/>\t\t\n</body>\n```\n\n#### 表单标签\n\n```jsp\n<!-- struts表单标签 -->\n\t<!-- 好处：内置了一套样式；自动回显，根据栈中的属性 -->\n\t<!-- theme属性，指定表单主题，默认xml主题 -->\n\t<s:form action=\"DemoAction\" namespace=\"/\" theme=\"simple\">\n\t\t<!-- 表单提交，提示：用户名 -->\n\t\t<s:textfield name=\"name\"lable=\"用户名\"></s:textfield>\n\t\t<s:password name=\"password\" lable=\"密码\"></s:password>\n\t\t<!-- 单选 -->\n\t\t<s:radio list=\"{'男',''女}\"  name=\"gender\" value=\"性别\"></s:radio>\n\t\t<s:radio list=\"#{1:'男',0:'女'}\"  name=\"gender\" value=\"性别\"></s:radio>\n\t\t<!-- 多选 -->\n\t\t<s:checkboxlist list=\"#{1:'游泳',0:'打球',2:'跑步'}\" name=\"hobby\" lable=\"爱好\"></s:checkboxlist>\n\t\t<!-- 下拉选 -->\n\t\t<s:select list=\"#{2:'大专',1:'本科',0:'硕士' }\" headerKey=\"\" headerValue=\"--请选择--\" name=\"edu\" lable=\"学历\"></s:select>\n\t\t<!-- 文件上传 -->\n\t\t<s:file name=\"photo\" lable=\"近照\"></s:file>\n\t\t<!-- 文本域 -->\n\t\t<s:textarea name=\"desc\" lable=\"个人简介\"></s:textarea>\n\t\t<s:submit value=\"提交\"></s:submit>\n\t</s:form>\n```\n\n#### 非表单标签\n\n```jsp\n//action中的方法加入错误提示信息\nthis.addActionError(\"你错了\")!\n\n<!--使错误信息在页面显示-->\n<s:actionerror/>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/struct2.md","raw":"---\ntitle: javaEE-framework——Struts2\ndate: 2019-05-06 10:40:48\ndescription: 习惯了学习时记笔记，虽然不多，但是包含了Strust2的大部分内容，如果内容有错误的地方，欢迎大家批评指正\ntags:\n - Struts2\n - javaEE framework\ncategories: javaEE framework\n---\n[TOC]\n\n### 知识详解\n\n#### 简介\n\n##### 概念\n\n运行web层，处理访问服务器的请求，代理Servlet\n\nstruct2与struct1区别：struct2前身是webwork框架\n\n##### 优势\n\n自动封装参数、参数校验、结果的处理(转发(重定向))、国际化、显式等待页面、表单防止重复提交\n\n##### 搭建\n\n- 导包\n- 书写action类\n- 书写src/structs.xml核心配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE struts PUBLIC\n\t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"\n\t\"http://struts.apache.org/dtds/struts-2.3.dtd\">\n<struts>\n\t<package name=\"hello\" namespace=\"/hello\" extends=\"structs-default\">\n\t\t<action name=\"HelloAction\" class=\"cn_struct2.HelloAction\" method=\"hello\">\n\t\t\t<result name=\"success\" >/hello.jsp</result>\n\t\t</action>\n\t</package>\t\t\n</struts>\n```\n\n- 将structs2核心过滤器配置到web.xml\n\n```xml\n<filter>\n  \t<filter-name>structs2</filter-name>\n  \t<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\n  </filter>\n  <filter-mapping>\n  \t<filter-name>structs2</filter-name>\n  \t<url-pattern>/*</url-pattern>\n  </filter-mapping>\n```\n\n##### Struts构造原理图\n\n<img src=\"\\img\\javaWeb\\struts原理.JPG\" height=550px>\n\n##### 配置详解\n\n###### struts.xml配置\n\n```xml\n<struts>\n<!--package:将Action配置封装，可在package里配置多个action\nname：包的名字（任意），起到标识作用，不能与其他包重复\nnamespace：给action的访问路径中定义一个命名空间\nextends：必选属性，继承一个指定包，默认struts-default\nadstract:包是否是抽象的，标识性属性，该包不能独立运行，只能被继承\n -->\n\t<package name=\"hello\" namespace=\"/hello\" extends=\"struts-default\">\n\t\t<!-- action类：配置action类\n\t\tname：决定了Action访问资源 \n\t\tcalss:action的完整类名\n\t\tmethod：指定调用Action中的哪个方法进行处理请求\n\t\t -->\n\t\t<action name=\"HelloAction\" class=\"cn_struct2.HelloAction\" method=\"hello\">\n\t\t\t<!-- result：结果配置\n\t\t\tname：标识结果处理的名称：与action方法的返回值对应\n\t\t\ttype：指定定义哪个Result类来处理结果，默认使用转发\n\t\t\t标签体：填写页面的相对路径\n\t\t\t -->\n\t\t\t<result name=\"success\" >/hello.jsp</result>\n\t\t</action>\n\t</package>\t\t\n</struts>\n```\n\n###### struts2常量配置\n\n**default.properties文件所在位置：**\n\n​\tLibraries\n\n​\t\tWeb App Libraries\n\n​\t\t\tstruts2-core-2.5.20.jar\n\n​\t\t\t\tstatic\n\n​\t\t\t\t\tdefault.properties\n\n**常量的三种修改方式：**\n\n方式先后也是文件加载顺序\n\n- struts.xml中,在\\<struts>根下，配置(常用)：\n\n  ```\n  <struts>\n  \t<constant name=\"\" value=\"\">\n  \t...\n  </struts>\t\n  ```\n\n- src下新建struts.properties，在文件里填写修改的键值对\n\n- web.xml中，filter前进行配置\n\n  ```\n  <context-param>\n  \t<param-name> </param-name>\n  \t<param-value> </param-value>\n  </context-param>\t\n  <filter>......\t\n  ```\n\n**常量**\n\n```xml\n<!-- i18n：国际化，使用配置文件配置多个语言，可解决post提交乱码问题-->\n<constant name=\"struts.i18n.encoding=UTF-8:\" value=\"UTF-8\">\n\n<!--struts.action.extension:指定访问action的后缀名-->\n<constant name=\"struts.action.extension\" value=\"action,,\">\n<!--逗号标识隔开两个值-->\n\n<!--指定struts是否以开放模式运行\n\t1、可热加载主配置（不需重启即可生效）\n\t2、提供更多错误信息输出，方便调试-->\n<constant name=\"struts.devMode\" value=\"true\">\n```\n\n###### struts2配置进阶\n\n**动态方法调用**\n\n方式一：（了解）\n\n- 调用方法时，方法前加 ‘ ！’\n\n- 主配置文件，struts下配置：\n\n```\n<!-- 配置动态方法调用是否开启的常量，默认是false -->\n<constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/>\n```\n\n- 次配置\n\n```xml\n<struts>\t\n\t<package name=\"dynamic\" namespace=\"/dynamic\" extends=\"struts-default\">\n\t\t<global-allowed-methods>add,update</global-allowed-methods>\n\t\t<action name=\"Demo1Action\" class=\"cn_struct2.Demo1Action\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t</action>\n\t</package>\t\n</struts>\n```\n\n方式二：\n\n次配置\n\n```\n<struts>\t\n\t<package name=\"dynamic\" namespace=\"/dynamic\" extends=\"struts-default\">\n\t\t<global-allowed-methods>add,update</global-allowed-methods>\n\t\t<action name=\"Demo1Action_*\" class=\"cn_struct2.Demo1Action\" method=\"{1}\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t</action>\n\t</package>\t\n</struts>\n```\n\n**默认配置**（了解）\n\n```xml\n<package name=\"dynamic\" namespace=\"/dynamic\" extends=\"struts-default\">\n\t\t<!-- 找不到包下的action，会使用DemoAction作为默认action请求 -->\n\t\t<default-action-ref name=\"DemoAction\"></default-action-ref>\n\t\t<!-- method:execute -->\n\t\t<!-- result的name属性：success -->\n\t\t<!-- result的type属性：dispatcher转发 -->\t\n\t\t<!-- class属性：com.opensymphony.xwork2.ActionSupport -->\n\t\t<action name=\"Demo1Action\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t</action>\t\n</package>\n```\n\n##### action类创建方式\n\naction类：public,返回String，可抛异常\n\n1、创建一个类，可以是POJO(普通类，不需要继承任何父类或实现接口)，使struts2代码侵入性更低\n\n2、实现Action接口，\n\n​\t1）里面有execute方法，提供Action方法的规范\n\n​\t2）Action接口预置了一些字符串，可在返回时使用\n\n3、继承一个类，ActionSupport（重点）\n\n​\t帮助实现了Action、Validateable、ValidationAwre、TextProvider、LocaleProvider\n\n#### 结果跳转方式\n\n##### 转发（默认 ）\n\n##### 重定向\n\n##### 转发到Action\n\n```xml\n<result name=\"success\" type=\"chain\">\n\t<param name=\"actionName\" >DemoAction</param>\n\t<param name=\"namespace\" >/</param>\n</result>\n```\n\n##### 重定向到Action\n\n```xml\n<result name=\"success\" type=\"rediretAction\">\n\t<param name=\"actionName\" >DemoAction</param>\n\t<param name=\"namespace\" >/</param>\n</result>\n```\n\n#### 访问ServletAPI方式\n\n**ActionContext**:数据中心，可获得原生request(HttpServletRequest)、原生response(HttpServletResponse)、原生ServletContext、request域(Map)、session域(Map)、application域(Map)、params(Map)、attr域(Map,三个域合一)、ValueStack、、、\n\n生命周期：每次请求都会创建一个与请求对应的ActionContext对象，请求处理完域销毁，与当前线程绑定\n\n三种方式本质都是从ActionContext获得\n\n##### 通过actionContext\n\n```java\npublic String hello() {\n\t\t//request域(struts2不推荐用request域）\n\t\t//request域和ActionContext生命周期一致，可用ActionContext代替request域\n\t\tMap<String, Object> object = (Map<String, Object>)ActionContext.getContext().get(\"request\");\n\t\tActionContext.getContext().put(\"name\", \"value\");\n\t\t\n\t\t//session域\n\t\tMap<String, Object> session = ActionContext.getContext().getSession();\n\t\t\n\t\t//application域\n\t\tMap<String, Object> application = ActionContext.getContext().getApplication();\n\t\t\n\t\tSystem.out.println(\"hello world\");\n\t\treturn \"success\";\n\t}\n```\n\n##### 通过ServletActionContext\n\n不推荐\n\n```java\n\t//获得actionAPI方式2\n\t\tpublic String hello2() {\n\t\t\t//原生request域\n\t\t\tHttpServletRequest request = ServletActionContext.getRequest();\n\t\t\t\n\t\t\t//原生response域\n\t\t\tHttpServletResponse response = ServletActionContext.getResponse();\n\t\t\t\n\t\t\t//原生session域\n\t\t\tHttpSession session =request.getSession();\n\t\t\t\n\t\t\t//原生servletContext域\n\t\t\tServletContext servletContext = ServletActionContext.getServletContext();\n\t\t\t\n\t\t\tSystem.out.println(\"hello world\");\n\t\t\treturn \"success\";\n\t\t}\n```\n\n##### 实现接口Aware\n\n```java \nPublic class Demo entends ActioSUpport implments ServletRequestAware{\n    private HttpServletRequest request;\n    \n    public String execute() throws Exception{\n        System.out.println(\"原生Request\");\n        return SUCCESS;\n    }\n    \n    @Override\n    ppublic void setServletRequest(HttpServletRequest request){\n        this.request = request;\n    }\n}\n```\n\n#### 获得参数\n\n##### 扩展\n\n- **Struts MVC**\n\nFilter：Ctroller\n\nAction:Module\n\nResult:View\n\n- Action生命周期：每次请求到来时，都会创建一个新的Action实例，不会产生并发现象，线程安全，可使用成员变量来接受参数\n\n##### 属性驱动获得参数\n\nAction准备与参数键同名属性\n\n可自动转换八大基本类型及其包装类和Date(支持特定字符串类型,例：yyyy-MM-dd)\n\n```java \n//获得参数\npublic class Demo8Action extends ActionSupport{\n\t//每次请求都会创建新的Action对象\n\t//准备与参数键名称相同的属性\n\tprivate String cust_name;\n\t\n\tpublic String execute() {\n\t\tSystem.out.println(\"name的参数值：\"+cust_name);\n\t\treturn \"success\";\n\t}\n\n\tpublic String getCust_name() {\n\t\treturn cust_name;\n\t}\n\n\tpublic void setCust_name(String cust_name) {\n\t\tthis.cust_name = cust_name;\n\t}\t\n}\n```\n\n\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\t用户名：<input type=\"text\" name=\"Customer.cust_name\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\n```\n\n##### 对象驱动\n\nAction准备与参数键同名属性    xxx.yyy\n\n```java\npublic class Demo8Action extends ActionSupport{\n\t//准备customer属性\n\tCustomer customer;\n\t\n\tpublic String execute() {\n\t\tSystem.out.println(customer.toString);\n\t\treturn \"success\";\n\t}\n\n\tpublic Customer getCustomer() {\n\t\treturn customer;\n\t}\n\n\tpublic void setCustomer(Customer customer) {\n\t\tthis.customer = customer;\n\t}\t\n}\n```\n\n\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\t用户名：<input type=\"text\" name=\"customer.name\"/><br>\n\t\t年龄：<input type=\"text\" name=\"customer.age\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\n```\n\n##### 模型驱动\n\n实现ModelDrivern接口，实现getModel方法，返回需要封装参数的对象\n\n```java \npublic class Demo8Action extends ActionSupport implements ModelDriven<Customer>{\n\t//准备customer对象\n\tprivate Customer customer = new Customer();\n\t\n\tpublic String execute() {\n\t\tSystem.out.println(customer.toString);\n\t\treturn \"success\";\n\t}\n\t\n\t@Override\n\tpublic Customer getModel(){\n        return customer\n\t}\n}\n```\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\t用户名：<input type=\"text\" name=\"name\"/><br>\n\t\t年龄：<input type=\"text\" name=\"age\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\n```\n\n##### 集合类型封装获得参数：\n\n```xml\n<form action=\"${pageContext.request.contextPath }/Demo8Action\">\n\t\tlist：<input type=\"text\" name=\"list\"/><br>\n\t\tlist：<input type=\"text\" name=\"list[3]\"/><br>\n\t\tmap：<input type=\"text\" name=\"map['haha']\"/><br>\n\t\t<input type=\"submit\" value=\"提交\"/> \n</form>\t\n```\n\n注：封装集合类型参数在前端可直接使用，使用时，map需先给出key\n\n### 表达式\n\n#### OGNL表达式\n\nOGNL:对象视图导航语言，例：$(user.addr.name)这种写法就成为对象视图导航\n\nOGNL不仅仅可视图导航，还支持比EL表达式更加丰富的功能\n\n##### 准备工作\n\nOGNL从OGNLContext对象取值（复习：EL取值：11大内置对象）\n\nOGNLContext对象分为ROOT和Context两部分：\n\n​\tROOT：可放置任何对象\n\n​\tContext:\t只存放Map\n\n##### 基本语法\n\n###### 取值\n\nROOT取值：expression直接写要取值的属性名\n\nContext取值：expression写:#key.属性\n\n```java \npublic class demo1 {\n\tpublic void fun1() throws OgnlException {\n\t\t//1、准备OGNLContext\n\t\t//准备ROOT\n\t\tUser rootUser = new User(\"Tom\", 5);\n\t\t//准备Context\n\t\tMap<String ,User> context = new HashMap();\n\t\tcontext.put(\"user1\",new User(\"lucy\", 7));\n\t\tcontext.put(\"user2\",new User(\"rose\", 8));\n\t\t\n\t\tOgnlContext oc = new OgnlContext();\n\t\toc.setRoot(rootUser);\n\t\toc.setValues(context);\n\t\t\n\t\t//2、书写OGNL表达式\n\t\tString name = Ognl.getValue(\"name\", context, oc.getRoot());\n\t\tString name = Ognl.getValue(\"#user1.name\", context, oc.getRoot());\n\t}\n}\n```\n\n###### 赋值\n\nROOT：属性=值\n\nContext:#key.属性=值\n\n```java \n//赋值\n\tString name = Ognl.getValue(\"name='jerry'\", context, oc.getRoot());\n\tString name = Ognl.getValue(\"#user1.name='jerry'\", context, oc.getRoot());\n\t//表达式可串联，但是如果表达式都有返回值，则取最后一个表达式的值\n```\n\n###### 调用方法\n\n```java\nOgnl.getValue(\"setName('jerry')\", context, oc.getRoot());\nString name = Ognl.getValue(\"getName()\", context, oc.getRoot());\n\nString name = Ognl.getValue(\"#user1.setName('jerry'),#user2.getName()\", context, oc.getRoot());\nString name = Ognl.getValue(\"#user1.getName()\", context, oc.getRoot());\n\n//静态方法调用\nString name = （String）Ognl.getValue(\"@完整包名@方法名\", context, oc.getRoot());\nDouble pi = (Double)Ognl.getValue(\"@java.lang.Math@PI\", context, oc.getRoot());\n//Math是OGNL对象的内置对象\n(Double)Ognl.getValue(\"@@PI\", context, oc.getRoot());\n```\n\n###### 创建List和Map对象\n\n```java\n//创建list对象\nOgnl.getValue(\"{'hello','tom','penny'}\", context, oc.getRoot());\nString name1 = Ognl.getValue(\"{'hello','tom','penny'}[0]\", context, oc.getRoot());\nString name2 = Ognl.getValue(\"{'hello','tom','penny'}.get(1)\", context, oc.getRoot());\n\n//创建Map对象\nOgnl.getValue(\"#{'name':'Tome','age':18}\", context, oc.getRoot());\nString name3 = Ognl.getValue(\"{'hello','tom','penny'}['name']\", context, oc.getRoot());\nint age = = Ognl.getValue(\"{'hello','tom','penny'}.get('age')\", context, oc.getRoot());\n```\n\n\n\n#### OGNL与struts2结合\n\nOGNlContext-->ValueStack值栈\n\nROOT：栈，栈中放置当前访问的Action对象\n\nContext：ActionContext（数据中心）\n\n##### 结合体现：\n\n###### 参数接收\n\nstruts2的参数交给OGNL引擎处理\n\n<img src=\"\\img\\javaWeb\\OGNL_Struts原理.JPG\" height=200px>\n\n<img src=\"\\img\\javaWeb\\OGNL_Struts原理2.JPG\" height=250px>\n\n```java\n//将参数压入栈\n//方法一\n//public class DemoAction extends ActionSupport implements Preparable{\n//\tprivate Customer u = new Customer();\n//\tpublic String execute() {\n\n//\t\treturn SUCCESS;\n//\t}\n//\t@Override\n//\tpublic void prepare() throws Exception {\n//\t\t// TODO Auto-generated method stub\n//\t\t//压入栈顶\n//\t\t//1、获得栈值\n//\t\tValueStack vs = ActionContext.getContext().getValueStack();\n//\t\t\t\t\n//\t\t//2、将u压人栈顶\n//\t\tvs.push(u);\n//\t}\n//}\n\n//方法二\npublic class DemoAction extends ActionSupport implements ModelDriven<Customer>{\n\tprivate Customer u = new Customer();\n\tpublic String execute() {\n\t\t// TODO Auto-generated method stub\n\t\t//压入栈顶\n\t\t//1、获得栈值\n\t\tValueStack vs = ActionContext.getContext().getValueStack();\t\t\t\t\n\t\t//2、将u压人栈顶\n\t\tvs.push(u);\n\t\treturn SUCCESS;\n\t}\n\t@Override\n\tpublic Customer getModel() {\n\t\t// TODO Auto-generated method stub\n\t\treturn u;\n\t}\n}\n```\n\n###### 配置文件\n\n${ognl表达式}\n\n```xml\n<result name=\"success\" type=\"redirectAction\">\n\t<param name=\"actionName\" >DemoAction</param>\n\t<param name=\"namespace\" >/</param>\n\t<!--如果提交的参数struts看不懂，就会作为参数附加在重定向的路径之后，如果参数是动态的，可以OGNL\t\t表达式：\n\t  age=xx，${OGNL表达式}-->\n\t<param name=\"age\" >${age}</param>\n</result>\n```\n\n###### struts2标签\n\n\n\n#### 扩展:源码流程\n\n- request.getAttribute()查找顺序：\n  - 原生request域\n  - ValueStack的栈（Root）\n  - ValueStack的Context部分(ActionContext)\n\n- 拦截器的调用：递归调用\n\n  defaultActionInvocation调用interceptor.intercept()，interceptor调用defaultActionInvocation.invoke()\n\n### 拦截器\n\n准备工作：用户登录\n\n```java\npublic class UserAction extends ActionSupport implements ModelDriven<Customer>{\n\tprivate Customer customer = new Customer();\n\tprivate UserService us = new UserService();\n\t\n\tpublic String login() {\n\t\t//调用service，执行登录操作\n\t\tCustomer c = us.login(customer);\n\t\t//2、将返回的Customer对象放入session域作为登录标识\n\t\tActionContext.getContext().getSession().put(\"customer\",c);\n\t\t//3、重定向到项目的首页\n\t\treturn \"toHome\";//重定向页面的name属性\n\t\n\t}\n\t\t\n\t@Override\n\tpublic Customer getModel() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\t\n}\n```\n\n\n\n```java\npublic class UserService {\n\tpublic Customer login(Customer customer) {\n\t\t//Hibernate打开事务\n\t\n\t\tCustomerDao cd = new CustomerDao();\n\t\t//1、调用Dao根据登录名称查询的Customer对象\n\t\tCustomer existCustomer = cd.getByCode(customer.getCust_name().hashCode());\n\t\t\n\t\t//提交事务\n\t\t\n\t\t//抛出异常，用户不存在\n\t\tif(existCustomer==null) {\n\t\t\tthrow new RuntimeException(\"同户名不存在\");\n\t\t}\n\t\t//2、比对密码是否一致（Id)\n\t\tif(!existCustomer.getCust_id().equals(customer.getCust_id())) {\n\t\t\t//不一致，抛出异常提示\n\t\t\tthrow new RuntimeException(\"密码错误\");\n\t\t}\n\t\t\n\t\t//将数据库查询到的Customer返回\n\t\treturn existCustomer;\n\t}\t\n}\n```\n\n```xml\n<package name=\"crm\" namespace=\"/\" extends=\"struts-default\">\n\t<global-exception-mappings>\n\t\t<!--若出现该异常，跳转到结果为error的页面-->\n\t\t<exception-mapping result=\"error\" exception\"exception完整类名\">\n\t\t</exception-mapping>\n\t</global-exception-mappings>\n\t\n\t<action name=\"Demo1Action_*\" class=\"cn_struct2.Demo1Action\" method=\"{1}\">\n\t\t\t<result name=\"success\">/hello.jsp</result>\n\t\t\t<result name=\"error\">/login.jsp</result>\n\t</action>\n</package>\n```\n\n```\n<!--密码错误在新页面提示-->\n<!--跳转到的页面使用debug标签-->\n<%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\n\n<s:debug></s:debug>\n```\n\n#### 自定义拦截器\n\n拦截器生命周期：随项目的启动创建，随项目的关闭而销毁\n\n##### 拦截器的创建\n\n方式一：实现接口Interceptor\n\n方式二：继承AbstractInterceptor(该继承抽象类空实现了Interceptor)\n\n方式三：继承MethodFilterInterceptor，功能：定制拦截器拦截的方法,可定制需要拦截或不需要拦截的方法\n\n```java\n//拦截器：创建方式一\npublic class MyInterceptor implements Interceptor{}\n//方法二：\npublic class MyInterceptor_2 extends AbstractInterceptor{}\n//方式二：\n//功能：定制拦截器拦截的方法\n//实现方法doIntercept();\npublic class MyInterceptor_2 extends MethodFilterInterceptor{\n    @Override\n\tprotected String doIntercept(ActionInvocation arg0) throws Exception {\n\t\t//前处理\n\t\t\n\t\t//放行\n\t\tinvocation.invoke();\n\t\t\n\t\t//后处理\n\t\treturn null;\n\t}\n}\n```\n\n##### 拦截器配置\n\n##### 拦截方法指定\n\n不拦截和需要拦截的方法不能同时指定\n\n```xml\n<package>\n\t<interceptors>\n\t\t<!--注册拦截器-->\n\t\t<interceptor name=\"myInter\" class=\"完整类名\"></interceptor>\n\t\t<!--注册拦截器栈-->\n\t\t<interceptor-stack name=\"myStack\">\n\t\t\t<!--自定义拦截器默认 放在20个拦截器之前-->\n\t\t\t<interceptor-ref name=\"myInter\">\n            \t<param name=\"excludeMythods\">add,delete</param>                               </interceptor-ref>\n            \t<param name=\"includeMythods\">add,delete</param>                               </interceptor-ref>\n\t\t\t<interceptor-ref name=\"defaultStack\"></interceptor-ref>\n\t\t</interceptor-stack>\n\t</interceptors>\n\t<!--指定默认拦截器栈,作用范围是整个包-->\n\t<default-interceptor-ref name=\"myStack\"></default-interceptor-ref>\n\t<action name=\"myInter\" class=\"\">\n\t\t<!--或为action单独指定哪个拦截器-->\n\t\t<default-interceptor-ref name=\"myStack\"></default-interceptor-ref>\n\t\t<result name=\"error\">/index.jsp</result>\n\t</action>\n</package>\n```\n\n\n\n**定义全局结果集**\n\n```\n<global-results></global-results>\n```\n\n### 标签\n\n（了解）\n\nstruts标签分类：\n\n- 普通标签：\n  - 控制标签(iterater、if、elseif、else)\n  - 数据标签(property)\n\n- ul标签：\n  - 表单标签(form、textfield、password、file、checkboxlist、redio...)\n  - 非表单标签(Actionerror)\n\n#### 普通标签\n\n```jsp\n<!--普通标签-->\n<body>\n\t<!-- 遍历标签 iterator -->\n\t<s:interator value=\"#list\">\n\t\t<s:property/>\n\t</s:interator>\n\t<!-- 遍历方式二 -->\n\t<s:interator value=\"#list\" var=\"name\">\n\t\t<s:property value=\"#name\"/>\n\t</s:interator>\n\t\n\t<!-- if标签 -->\n\t<s:if test=\"#list.size()==4\">\n\t\tlist长度为4\n\t</s:if>\n\t<s:esle>\n\t\tlist长度不为4\n\t</s:esle>\n\t\n\t<!-- property标签 ,配合ognl表达式页面取值使用-->\n\t<s:property value=\"#value.size()\"/>\n\t<s:property value=\"#session.use.name\"/>\t\t\n</body>\n```\n\n#### 表单标签\n\n```jsp\n<!-- struts表单标签 -->\n\t<!-- 好处：内置了一套样式；自动回显，根据栈中的属性 -->\n\t<!-- theme属性，指定表单主题，默认xml主题 -->\n\t<s:form action=\"DemoAction\" namespace=\"/\" theme=\"simple\">\n\t\t<!-- 表单提交，提示：用户名 -->\n\t\t<s:textfield name=\"name\"lable=\"用户名\"></s:textfield>\n\t\t<s:password name=\"password\" lable=\"密码\"></s:password>\n\t\t<!-- 单选 -->\n\t\t<s:radio list=\"{'男',''女}\"  name=\"gender\" value=\"性别\"></s:radio>\n\t\t<s:radio list=\"#{1:'男',0:'女'}\"  name=\"gender\" value=\"性别\"></s:radio>\n\t\t<!-- 多选 -->\n\t\t<s:checkboxlist list=\"#{1:'游泳',0:'打球',2:'跑步'}\" name=\"hobby\" lable=\"爱好\"></s:checkboxlist>\n\t\t<!-- 下拉选 -->\n\t\t<s:select list=\"#{2:'大专',1:'本科',0:'硕士' }\" headerKey=\"\" headerValue=\"--请选择--\" name=\"edu\" lable=\"学历\"></s:select>\n\t\t<!-- 文件上传 -->\n\t\t<s:file name=\"photo\" lable=\"近照\"></s:file>\n\t\t<!-- 文本域 -->\n\t\t<s:textarea name=\"desc\" lable=\"个人简介\"></s:textarea>\n\t\t<s:submit value=\"提交\"></s:submit>\n\t</s:form>\n```\n\n#### 非表单标签\n\n```jsp\n//action中的方法加入错误提示信息\nthis.addActionError(\"你错了\")!\n\n<!--使错误信息在页面显示-->\n<s:actionerror/>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"struct2","published":1,"updated":"2019-05-06T03:04:50.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvrtri51000ntku3tr59dadz","content":"<p>[TOC]</p>\n<h3 id=\"知识详解\"><a href=\"#知识详解\" class=\"headerlink\" title=\"知识详解\"></a>知识详解</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>运行web层，处理访问服务器的请求，代理Servlet</p>\n<p>struct2与struct1区别：struct2前身是webwork框架</p>\n<h5 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h5><p>自动封装参数、参数校验、结果的处理(转发(重定向))、国际化、显式等待页面、表单防止重复提交</p>\n<h5 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h5><ul>\n<li>导包</li>\n<li>书写action类</li>\n<li>书写src/structs.xml核心配置文件</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class=\"line\"><span class=\"meta\">\t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\t\"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hello\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/hello\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"structs-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"HelloAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.HelloAction\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> &gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>将structs2核心过滤器配置到web.xml</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>structs2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>structs2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Struts构造原理图\"><a href=\"#Struts构造原理图\" class=\"headerlink\" title=\"Struts构造原理图\"></a>Struts构造原理图</h5><p><img src=\"\\img\\javaWeb\\struts原理.JPG\" height=\"550px\"></p>\n<h5 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h5><h6 id=\"struts-xml配置\"><a href=\"#struts-xml配置\" class=\"headerlink\" title=\"struts.xml配置\"></a>struts.xml配置</h6><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--package:将Action配置封装，可在package里配置多个action</span></span><br><span class=\"line\"><span class=\"comment\">name：包的名字（任意），起到标识作用，不能与其他包重复</span></span><br><span class=\"line\"><span class=\"comment\">namespace：给action的访问路径中定义一个命名空间</span></span><br><span class=\"line\"><span class=\"comment\">extends：必选属性，继承一个指定包，默认struts-default</span></span><br><span class=\"line\"><span class=\"comment\">adstract:包是否是抽象的，标识性属性，该包不能独立运行，只能被继承</span></span><br><span class=\"line\"><span class=\"comment\"> --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hello\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/hello\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- action类：配置action类</span></span><br><span class=\"line\"><span class=\"comment\">\t\tname：决定了Action访问资源 </span></span><br><span class=\"line\"><span class=\"comment\">\t\tcalss:action的完整类名</span></span><br><span class=\"line\"><span class=\"comment\">\t\tmethod：指定调用Action中的哪个方法进行处理请求</span></span><br><span class=\"line\"><span class=\"comment\">\t\t --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"HelloAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.HelloAction\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!-- result：结果配置</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tname：标识结果处理的名称：与action方法的返回值对应</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\ttype：指定定义哪个Result类来处理结果，默认使用转发</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t标签体：填写页面的相对路径</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t --&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> &gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"struts2常量配置\"><a href=\"#struts2常量配置\" class=\"headerlink\" title=\"struts2常量配置\"></a>struts2常量配置</h6><p><strong>default.properties文件所在位置：</strong></p>\n<p>​    Libraries</p>\n<p>​        Web App Libraries</p>\n<p>​            struts2-core-2.5.20.jar</p>\n<p>​                static</p>\n<p>​                    default.properties</p>\n<p><strong>常量的三种修改方式：</strong></p>\n<p>方式先后也是文件加载顺序</p>\n<ul>\n<li><p>struts.xml中,在\\<struts>根下，配置(常用)：</struts></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;struts&gt;</span><br><span class=\"line\">\t&lt;constant name=&quot;&quot; value=&quot;&quot;&gt;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&lt;/struts&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>src下新建struts.properties，在文件里填写修改的键值对</p>\n</li>\n<li><p>web.xml中，filter前进行配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;context-param&gt;</span><br><span class=\"line\">\t&lt;param-name&gt; &lt;/param-name&gt;</span><br><span class=\"line\">\t&lt;param-value&gt; &lt;/param-value&gt;</span><br><span class=\"line\">&lt;/context-param&gt;\t</span><br><span class=\"line\">&lt;filter&gt;......</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>常量</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- i18n：国际化，使用配置文件配置多个语言，可解决post提交乱码问题--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">\"struts.i18n.encoding=UTF-8:\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--struts.action.extension:指定访问action的后缀名--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">\"struts.action.extension\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"action,,\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--逗号标识隔开两个值--&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--指定struts是否以开放模式运行</span></span><br><span class=\"line\"><span class=\"comment\">\t1、可热加载主配置（不需重启即可生效）</span></span><br><span class=\"line\"><span class=\"comment\">\t2、提供更多错误信息输出，方便调试--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">\"struts.devMode\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"struts2配置进阶\"><a href=\"#struts2配置进阶\" class=\"headerlink\" title=\"struts2配置进阶\"></a>struts2配置进阶</h6><p><strong>动态方法调用</strong></p>\n<p>方式一：（了解）</p>\n<ul>\n<li><p>调用方法时，方法前加 ‘ ！’</p>\n</li>\n<li><p>主配置文件，struts下配置：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 配置动态方法调用是否开启的常量，默认是false --&gt;</span><br><span class=\"line\">&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>次配置</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span>\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dynamic\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/dynamic\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">global-allowed-methods</span>&gt;</span>add,update<span class=\"tag\">&lt;/<span class=\"name\">global-allowed-methods</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Demo1Action\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.Demo1Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span>&gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>方式二：</p>\n<p>次配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;struts&gt;\t</span><br><span class=\"line\">\t&lt;package name=&quot;dynamic&quot; namespace=&quot;/dynamic&quot; extends=&quot;struts-default&quot;&gt;</span><br><span class=\"line\">\t\t&lt;global-allowed-methods&gt;add,update&lt;/global-allowed-methods&gt;</span><br><span class=\"line\">\t\t&lt;action name=&quot;Demo1Action_*&quot; class=&quot;cn_struct2.Demo1Action&quot; method=&quot;&#123;1&#125;&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;</span><br><span class=\"line\">\t\t&lt;/action&gt;</span><br><span class=\"line\">\t&lt;/package&gt;\t</span><br><span class=\"line\">&lt;/struts&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>默认配置</strong>（了解）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dynamic\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/dynamic\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 找不到包下的action，会使用DemoAction作为默认action请求 --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">default-action-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"DemoAction\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">default-action-ref</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- method:execute --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- result的name属性：success --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- result的type属性：dispatcher转发 --&gt;</span>\t</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- class属性：com.opensymphony.xwork2.ActionSupport --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Demo1Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span>&gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"action类创建方式\"><a href=\"#action类创建方式\" class=\"headerlink\" title=\"action类创建方式\"></a>action类创建方式</h5><p>action类：public,返回String，可抛异常</p>\n<p>1、创建一个类，可以是POJO(普通类，不需要继承任何父类或实现接口)，使struts2代码侵入性更低</p>\n<p>2、实现Action接口，</p>\n<p>​    1）里面有execute方法，提供Action方法的规范</p>\n<p>​    2）Action接口预置了一些字符串，可在返回时使用</p>\n<p>3、继承一个类，ActionSupport（重点）</p>\n<p>​    帮助实现了Action、Validateable、ValidationAwre、TextProvider、LocaleProvider</p>\n<h4 id=\"结果跳转方式\"><a href=\"#结果跳转方式\" class=\"headerlink\" title=\"结果跳转方式\"></a>结果跳转方式</h4><h5 id=\"转发（默认-）\"><a href=\"#转发（默认-）\" class=\"headerlink\" title=\"转发（默认 ）\"></a>转发（默认 ）</h5><h5 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h5><h5 id=\"转发到Action\"><a href=\"#转发到Action\" class=\"headerlink\" title=\"转发到Action\"></a>转发到Action</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"chain\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"actionName\"</span> &gt;</span>DemoAction<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"namespace\"</span> &gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"重定向到Action\"><a href=\"#重定向到Action\" class=\"headerlink\" title=\"重定向到Action\"></a>重定向到Action</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"rediretAction\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"actionName\"</span> &gt;</span>DemoAction<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"namespace\"</span> &gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"访问ServletAPI方式\"><a href=\"#访问ServletAPI方式\" class=\"headerlink\" title=\"访问ServletAPI方式\"></a>访问ServletAPI方式</h4><p><strong>ActionContext</strong>:数据中心，可获得原生request(HttpServletRequest)、原生response(HttpServletResponse)、原生ServletContext、request域(Map)、session域(Map)、application域(Map)、params(Map)、attr域(Map,三个域合一)、ValueStack、、、</p>\n<p>生命周期：每次请求都会创建一个与请求对应的ActionContext对象，请求处理完域销毁，与当前线程绑定</p>\n<p>三种方式本质都是从ActionContext获得</p>\n<h5 id=\"通过actionContext\"><a href=\"#通过actionContext\" class=\"headerlink\" title=\"通过actionContext\"></a>通过actionContext</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//request域(struts2不推荐用request域）</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//request域和ActionContext生命周期一致，可用ActionContext代替request域</span></span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; object = (Map&lt;String, Object&gt;)ActionContext.getContext().get(<span class=\"string\">\"request\"</span>);</span><br><span class=\"line\">\t\tActionContext.getContext().put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//session域</span></span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; session = ActionContext.getContext().getSession();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//application域</span></span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; application = ActionContext.getContext().getApplication();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hello world\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过ServletActionContext\"><a href=\"#通过ServletActionContext\" class=\"headerlink\" title=\"通过ServletActionContext\"></a>通过ServletActionContext</h5><p>不推荐</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得actionAPI方式2</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生request域</span></span><br><span class=\"line\">\t\tHttpServletRequest request = ServletActionContext.getRequest();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生response域</span></span><br><span class=\"line\">\t\tHttpServletResponse response = ServletActionContext.getResponse();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生session域</span></span><br><span class=\"line\">\t\tHttpSession session =request.getSession();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生servletContext域</span></span><br><span class=\"line\">\t\tServletContext servletContext = ServletActionContext.getServletContext();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hello world\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"实现接口Aware\"><a href=\"#实现接口Aware\" class=\"headerlink\" title=\"实现接口Aware\"></a>实现接口Aware</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"title\">entends</span> <span class=\"title\">ActioSUpport</span> <span class=\"title\">implments</span> <span class=\"title\">ServletRequestAware</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpServletRequest request;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"原生Request\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\">ppublic <span class=\"keyword\">void</span> <span class=\"title\">setServletRequest</span><span class=\"params\">(HttpServletRequest request)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.request = request;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"获得参数\"><a href=\"#获得参数\" class=\"headerlink\" title=\"获得参数\"></a>获得参数</h4><h5 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h5><ul>\n<li><strong>Struts MVC</strong></li>\n</ul>\n<p>Filter：Ctroller</p>\n<p>Action:Module</p>\n<p>Result:View</p>\n<ul>\n<li>Action生命周期：每次请求到来时，都会创建一个新的Action实例，不会产生并发现象，线程安全，可使用成员变量来接受参数</li>\n</ul>\n<h5 id=\"属性驱动获得参数\"><a href=\"#属性驱动获得参数\" class=\"headerlink\" title=\"属性驱动获得参数\"></a>属性驱动获得参数</h5><p>Action准备与参数键同名属性</p>\n<p>可自动转换八大基本类型及其包装类和Date(支持特定字符串类型,例：yyyy-MM-dd)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得参数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo8Action</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//每次请求都会创建新的Action对象</span></span><br><span class=\"line\">\t<span class=\"comment\">//准备与参数键名称相同的属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String cust_name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"name的参数值：\"</span>+cust_name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCust_name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cust_name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCust_name</span><span class=\"params\">(String cust_name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.cust_name = cust_name;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Customer.cust_name\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"对象驱动\"><a href=\"#对象驱动\" class=\"headerlink\" title=\"对象驱动\"></a>对象驱动</h5><p>Action准备与参数键同名属性    xxx.yyy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo8Action</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备customer属性</span></span><br><span class=\"line\">\tCustomer customer;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(customer.toString);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getCustomer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCustomer</span><span class=\"params\">(Customer customer)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.customer = customer;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"customer.name\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t年龄：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"customer.age\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"模型驱动\"><a href=\"#模型驱动\" class=\"headerlink\" title=\"模型驱动\"></a>模型驱动</h5><p>实现ModelDrivern接口，实现getModel方法，返回需要封装参数的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo8Action</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ModelDriven</span>&lt;<span class=\"title\">Customer</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备customer对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(customer.toString);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getModel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> customer</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t年龄：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"集合类型封装获得参数：\"><a href=\"#集合类型封装获得参数：\" class=\"headerlink\" title=\"集合类型封装获得参数：\"></a>集合类型封装获得参数：</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\tlist：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\tlist：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list[3]\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\tmap：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"map['haha']\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注：封装集合类型参数在前端可直接使用，使用时，map需先给出key</p>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><h4 id=\"OGNL表达式\"><a href=\"#OGNL表达式\" class=\"headerlink\" title=\"OGNL表达式\"></a>OGNL表达式</h4><p>OGNL:对象视图导航语言，例：$(user.addr.name)这种写法就成为对象视图导航</p>\n<p>OGNL不仅仅可视图导航，还支持比EL表达式更加丰富的功能</p>\n<h5 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h5><p>OGNL从OGNLContext对象取值（复习：EL取值：11大内置对象）</p>\n<p>OGNLContext对象分为ROOT和Context两部分：</p>\n<p>​    ROOT：可放置任何对象</p>\n<p>​    Context:    只存放Map</p>\n<h5 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h5><h6 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h6><p>ROOT取值：expression直接写要取值的属性名</p>\n<p>Context取值：expression写:#key.属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo1</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> OgnlException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//1、准备OGNLContext</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//准备ROOT</span></span><br><span class=\"line\">\t\tUser rootUser = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//准备Context</span></span><br><span class=\"line\">\t\tMap&lt;String ,User&gt; context = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">\t\tcontext.put(<span class=\"string\">\"user1\"</span>,<span class=\"keyword\">new</span> User(<span class=\"string\">\"lucy\"</span>, <span class=\"number\">7</span>));</span><br><span class=\"line\">\t\tcontext.put(<span class=\"string\">\"user2\"</span>,<span class=\"keyword\">new</span> User(<span class=\"string\">\"rose\"</span>, <span class=\"number\">8</span>));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tOgnlContext oc = <span class=\"keyword\">new</span> OgnlContext();</span><br><span class=\"line\">\t\toc.setRoot(rootUser);</span><br><span class=\"line\">\t\toc.setValues(context);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、书写OGNL表达式</span></span><br><span class=\"line\">\t\tString name = Ognl.getValue(<span class=\"string\">\"name\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\t\tString name = Ognl.getValue(<span class=\"string\">\"#user1.name\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h6><p>ROOT：属性=值</p>\n<p>Context:#key.属性=值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">\tString name = Ognl.getValue(<span class=\"string\">\"name='jerry'\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\tString name = Ognl.getValue(<span class=\"string\">\"#user1.name='jerry'\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\t<span class=\"comment\">//表达式可串联，但是如果表达式都有返回值，则取最后一个表达式的值</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ognl.getValue(<span class=\"string\">\"setName('jerry')\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name = Ognl.getValue(<span class=\"string\">\"getName()\"</span>, context, oc.getRoot());</span><br><span class=\"line\"></span><br><span class=\"line\">String name = Ognl.getValue(<span class=\"string\">\"#user1.setName('jerry'),#user2.getName()\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name = Ognl.getValue(<span class=\"string\">\"#user1.getName()\"</span>, context, oc.getRoot());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//静态方法调用</span></span><br><span class=\"line\">String name = （String）Ognl.getValue(<span class=\"string\">\"@完整包名@方法名\"</span>, context, oc.getRoot());</span><br><span class=\"line\">Double pi = (Double)Ognl.getValue(<span class=\"string\">\"@java.lang.Math@PI\"</span>, context, oc.getRoot());</span><br><span class=\"line\"><span class=\"comment\">//Math是OGNL对象的内置对象</span></span><br><span class=\"line\">(Double)Ognl.getValue(<span class=\"string\">\"@@PI\"</span>, context, oc.getRoot());</span><br></pre></td></tr></table></figure>\n<h6 id=\"创建List和Map对象\"><a href=\"#创建List和Map对象\" class=\"headerlink\" title=\"创建List和Map对象\"></a>创建List和Map对象</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建list对象</span></span><br><span class=\"line\">Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name1 = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;[0]\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name2 = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;.get(1)\"</span>, context, oc.getRoot());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建Map对象</span></span><br><span class=\"line\">Ognl.getValue(<span class=\"string\">\"#&#123;'name':'Tome','age':18&#125;\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name3 = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;['name']\"</span>, context, oc.getRoot());</span><br><span class=\"line\"><span class=\"keyword\">int</span> age = = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;.get('age')\"</span>, context, oc.getRoot());</span><br></pre></td></tr></table></figure>\n<h4 id=\"OGNL与struts2结合\"><a href=\"#OGNL与struts2结合\" class=\"headerlink\" title=\"OGNL与struts2结合\"></a>OGNL与struts2结合</h4><p>OGNlContext–&gt;ValueStack值栈</p>\n<p>ROOT：栈，栈中放置当前访问的Action对象</p>\n<p>Context：ActionContext（数据中心）</p>\n<h5 id=\"结合体现：\"><a href=\"#结合体现：\" class=\"headerlink\" title=\"结合体现：\"></a>结合体现：</h5><h6 id=\"参数接收\"><a href=\"#参数接收\" class=\"headerlink\" title=\"参数接收\"></a>参数接收</h6><p>struts2的参数交给OGNL引擎处理</p>\n<p><img src=\"\\img\\javaWeb\\OGNL_Struts原理.JPG\" height=\"200px\"></p>\n<p><img src=\"\\img\\javaWeb\\OGNL_Struts原理2.JPG\" height=\"250px\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将参数压入栈</span></span><br><span class=\"line\"><span class=\"comment\">//方法一</span></span><br><span class=\"line\"><span class=\"comment\">//public class DemoAction extends ActionSupport implements Preparable&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tprivate Customer u = new Customer();</span></span><br><span class=\"line\"><span class=\"comment\">//\tpublic String execute() &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\t\treturn SUCCESS;</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//\t@Override</span></span><br><span class=\"line\"><span class=\"comment\">//\tpublic void prepare() throws Exception &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t// TODO Auto-generated method stub</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t//压入栈顶</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t//1、获得栈值</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tValueStack vs = ActionContext.getContext().getValueStack();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t//2、将u压人栈顶</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tvs.push(u);</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法二</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ModelDriven</span>&lt;<span class=\"title\">Customer</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer u = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//压入栈顶</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//1、获得栈值</span></span><br><span class=\"line\">\t\tValueStack vs = ActionContext.getContext().getValueStack();\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、将u压人栈顶</span></span><br><span class=\"line\">\t\tvs.push(u);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> u;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h6><p>${ognl表达式}</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"redirectAction\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"actionName\"</span> &gt;</span>DemoAction<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"namespace\"</span> &gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--如果提交的参数struts看不懂，就会作为参数附加在重定向的路径之后，如果参数是动态的，可以OGNL\t\t表达式：</span></span><br><span class=\"line\"><span class=\"comment\">\t  age=xx，$&#123;OGNL表达式&#125;--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> &gt;</span>$&#123;age&#125;<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"struts2标签\"><a href=\"#struts2标签\" class=\"headerlink\" title=\"struts2标签\"></a>struts2标签</h6><h4 id=\"扩展-源码流程\"><a href=\"#扩展-源码流程\" class=\"headerlink\" title=\"扩展:源码流程\"></a>扩展:源码流程</h4><ul>\n<li><p>request.getAttribute()查找顺序：</p>\n<ul>\n<li>原生request域</li>\n<li>ValueStack的栈（Root）</li>\n<li>ValueStack的Context部分(ActionContext)</li>\n</ul>\n</li>\n<li><p>拦截器的调用：递归调用</p>\n<p>defaultActionInvocation调用interceptor.intercept()，interceptor调用defaultActionInvocation.invoke()</p>\n</li>\n</ul>\n<h3 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h3><p>准备工作：用户登录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ModelDriven</span>&lt;<span class=\"title\">Customer</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserService us = <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//调用service，执行登录操作</span></span><br><span class=\"line\">\t\tCustomer c = us.login(customer);</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、将返回的Customer对象放入session域作为登录标识</span></span><br><span class=\"line\">\t\tActionContext.getContext().getSession().put(<span class=\"string\">\"customer\"</span>,c);</span><br><span class=\"line\">\t\t<span class=\"comment\">//3、重定向到项目的首页</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"toHome\"</span>;<span class=\"comment\">//重定向页面的name属性</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">login</span><span class=\"params\">(Customer customer)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Hibernate打开事务</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tCustomerDao cd = <span class=\"keyword\">new</span> CustomerDao();</span><br><span class=\"line\">\t\t<span class=\"comment\">//1、调用Dao根据登录名称查询的Customer对象</span></span><br><span class=\"line\">\t\tCustomer existCustomer = cd.getByCode(customer.getCust_name().hashCode());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//提交事务</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//抛出异常，用户不存在</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(existCustomer==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"同户名不存在\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、比对密码是否一致（Id)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!existCustomer.getCust_id().equals(customer.getCust_id())) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//不一致，抛出异常提示</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"密码错误\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//将数据库查询到的Customer返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> existCustomer;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"crm\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">global-exception-mappings</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--若出现该异常，跳转到结果为error的页面--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">exception-mapping</span> <span class=\"attr\">result</span>=<span class=\"string\">\"error\"</span> <span class=\"attr\">exception</span>\"<span class=\"attr\">exception</span>完整类名\"&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">exception-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">global-exception-mappings</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Demo1Action_*\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.Demo1Action\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"&#123;1&#125;\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span>&gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"error\"</span>&gt;</span>/login.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--密码错误在新页面提示--&gt;</span><br><span class=\"line\">&lt;!--跳转到的页面使用debug标签--&gt;</span><br><span class=\"line\">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;s:debug&gt;&lt;/s:debug&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义拦截器\"><a href=\"#自定义拦截器\" class=\"headerlink\" title=\"自定义拦截器\"></a>自定义拦截器</h4><p>拦截器生命周期：随项目的启动创建，随项目的关闭而销毁</p>\n<h5 id=\"拦截器的创建\"><a href=\"#拦截器的创建\" class=\"headerlink\" title=\"拦截器的创建\"></a>拦截器的创建</h5><p>方式一：实现接口Interceptor</p>\n<p>方式二：继承AbstractInterceptor(该继承抽象类空实现了Interceptor)</p>\n<p>方式三：继承MethodFilterInterceptor，功能：定制拦截器拦截的方法,可定制需要拦截或不需要拦截的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//拦截器：创建方式一</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Interceptor</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法二：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterceptor_2</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractInterceptor</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//方式二：</span></span><br><span class=\"line\"><span class=\"comment\">//功能：定制拦截器拦截的方法</span></span><br><span class=\"line\"><span class=\"comment\">//实现方法doIntercept();</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterceptor_2</span> <span class=\"keyword\">extends</span> <span class=\"title\">MethodFilterInterceptor</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doIntercept</span><span class=\"params\">(ActionInvocation arg0)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//前处理</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//放行</span></span><br><span class=\"line\">\t\tinvocation.invoke();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//后处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拦截器配置\"><a href=\"#拦截器配置\" class=\"headerlink\" title=\"拦截器配置\"></a>拦截器配置</h5><h5 id=\"拦截方法指定\"><a href=\"#拦截方法指定\" class=\"headerlink\" title=\"拦截方法指定\"></a>拦截方法指定</h5><p>不拦截和需要拦截的方法不能同时指定</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">interceptors</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--注册拦截器--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myInter\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"完整类名\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">interceptor</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--注册拦截器栈--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor-stack</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myStack\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--自定义拦截器默认 放在20个拦截器之前--&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myInter\"</span>&gt;</span></span><br><span class=\"line\">            \t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"excludeMythods\"</span>&gt;</span>add,delete<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span>                               <span class=\"tag\">&lt;/<span class=\"name\">interceptor-ref</span>&gt;</span></span><br><span class=\"line\">            \t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"includeMythods\"</span>&gt;</span>add,delete<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span>                               <span class=\"tag\">&lt;/<span class=\"name\">interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultStack\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">interceptor-stack</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">interceptors</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--指定默认拦截器栈,作用范围是整个包--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">default-interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myStack\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">default-interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myInter\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--或为action单独指定哪个拦截器--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">default-interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myStack\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">default-interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"error\"</span>&gt;</span>/index.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>定义全局结果集</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;global-results&gt;&lt;/global-results&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><p>（了解）</p>\n<p>struts标签分类：</p>\n<ul>\n<li><p>普通标签：</p>\n<ul>\n<li>控制标签(iterater、if、elseif、else)</li>\n<li>数据标签(property)</li>\n</ul>\n</li>\n<li><p>ul标签：</p>\n<ul>\n<li>表单标签(form、textfield、password、file、checkboxlist、redio…)</li>\n<li>非表单标签(Actionerror)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"普通标签\"><a href=\"#普通标签\" class=\"headerlink\" title=\"普通标签\"></a>普通标签</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--普通标签--&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 遍历标签 iterator --&gt;</span><br><span class=\"line\">\t&lt;s:interator value=<span class=\"string\">\"#list\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;s:property/&gt;</span><br><span class=\"line\">\t&lt;/s:interator&gt;</span><br><span class=\"line\">\t&lt;!-- 遍历方式二 --&gt;</span><br><span class=\"line\">\t&lt;s:interator value=<span class=\"string\">\"#list\"</span> <span class=\"keyword\">var</span>=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;s:property value=<span class=\"string\">\"#name\"</span>/&gt;</span><br><span class=\"line\">\t&lt;/s:interator&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;!-- <span class=\"keyword\">if</span>标签 --&gt;</span><br><span class=\"line\">\t&lt;s:<span class=\"keyword\">if</span> test=<span class=\"string\">\"#list.size()==4\"</span>&gt;</span><br><span class=\"line\">\t\tlist长度为<span class=\"number\">4</span></span><br><span class=\"line\">\t&lt;/s:if&gt;</span><br><span class=\"line\">\t&lt;s:esle&gt;</span><br><span class=\"line\">\t\tlist长度不为<span class=\"number\">4</span></span><br><span class=\"line\">\t&lt;/s:esle&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;!-- property标签 ,配合ognl表达式页面取值使用--&gt;</span><br><span class=\"line\">\t&lt;s:property value=<span class=\"string\">\"#value.size()\"</span>/&gt;</span><br><span class=\"line\">\t&lt;s:property value=<span class=\"string\">\"#session.use.name\"</span>/&gt;\t\t</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- struts表单标签 --&gt;</span><br><span class=\"line\">\t&lt;!-- 好处：内置了一套样式；自动回显，根据栈中的属性 --&gt;</span><br><span class=\"line\">\t&lt;!-- theme属性，指定表单主题，默认xml主题 --&gt;</span><br><span class=\"line\">\t&lt;s:form action=<span class=\"string\">\"DemoAction\"</span> namespace=<span class=\"string\">\"/\"</span> theme=<span class=\"string\">\"simple\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;!-- 表单提交，提示：用户名 --&gt;</span><br><span class=\"line\">\t\t&lt;s:textfield name=\"name\"lable=\"用户名\"&gt;&lt;/s:textfield&gt;</span><br><span class=\"line\">\t\t&lt;s:password name=\"password\" lable=\"密码\"&gt;&lt;/s:password&gt;</span><br><span class=\"line\">\t\t&lt;!-- 单选 --&gt;</span><br><span class=\"line\">\t\t&lt;s:radio list=\"&#123;'男',''女&#125;\"  name=\"gender\" value=\"性别\"&gt;&lt;/s:radio&gt;</span><br><span class=\"line\">\t\t&lt;s:radio list=\"#&#123;1:'男',0:'女'&#125;\"  name=\"gender\" value=\"性别\"&gt;&lt;/s:radio&gt;</span><br><span class=\"line\">\t\t&lt;!-- 多选 --&gt;</span><br><span class=\"line\">\t\t&lt;s:checkboxlist list=\"#&#123;1:'游泳',0:'打球',2:'跑步'&#125;\" name=\"hobby\" lable=\"爱好\"&gt;&lt;/s:checkboxlist&gt;</span><br><span class=\"line\">\t\t&lt;!-- 下拉选 --&gt;</span><br><span class=\"line\">\t\t&lt;s:select list=\"#&#123;2:'大专',1:'本科',0:'硕士' &#125;\" headerKey=\"\" headerValue=\"--请选择--\" name=\"edu\" lable=\"学历\"&gt;&lt;/s:select&gt;</span><br><span class=\"line\">\t\t&lt;!-- 文件上传 --&gt;</span><br><span class=\"line\">\t\t&lt;s:file name=\"photo\" lable=\"近照\"&gt;&lt;/s:file&gt;</span><br><span class=\"line\">\t\t&lt;!-- 文本域 --&gt;</span><br><span class=\"line\">\t\t&lt;s:textarea name=\"desc\" lable=\"个人简介\"&gt;&lt;/s:textarea&gt;</span><br><span class=\"line\">\t\t&lt;s:submit value=\"提交\"&gt;&lt;/s:submit&gt;</span><br><span class=\"line\">\t&lt;/s:form&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"非表单标签\"><a href=\"#非表单标签\" class=\"headerlink\" title=\"非表单标签\"></a>非表单标签</h4><figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//action中的方法加入错误提示信息</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.addActionError(<span class=\"string\">\"你错了\"</span>)!</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--使错误信息在页面显示--&gt;</span><br><span class=\"line\">&lt;s:actionerror/&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h3 id=\"知识详解\"><a href=\"#知识详解\" class=\"headerlink\" title=\"知识详解\"></a>知识详解</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>运行web层，处理访问服务器的请求，代理Servlet</p>\n<p>struct2与struct1区别：struct2前身是webwork框架</p>\n<h5 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h5><p>自动封装参数、参数校验、结果的处理(转发(重定向))、国际化、显式等待页面、表单防止重复提交</p>\n<h5 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h5><ul>\n<li>导包</li>\n<li>书写action类</li>\n<li>书写src/structs.xml核心配置文件</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class=\"line\"><span class=\"meta\">\t\"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\t\"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hello\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/hello\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"structs-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"HelloAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.HelloAction\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> &gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>将structs2核心过滤器配置到web.xml</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>structs2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>structs2<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Struts构造原理图\"><a href=\"#Struts构造原理图\" class=\"headerlink\" title=\"Struts构造原理图\"></a>Struts构造原理图</h5><p><img src=\"\\img\\javaWeb\\struts原理.JPG\" height=\"550px\"></p>\n<h5 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h5><h6 id=\"struts-xml配置\"><a href=\"#struts-xml配置\" class=\"headerlink\" title=\"struts.xml配置\"></a>struts.xml配置</h6><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--package:将Action配置封装，可在package里配置多个action</span></span><br><span class=\"line\"><span class=\"comment\">name：包的名字（任意），起到标识作用，不能与其他包重复</span></span><br><span class=\"line\"><span class=\"comment\">namespace：给action的访问路径中定义一个命名空间</span></span><br><span class=\"line\"><span class=\"comment\">extends：必选属性，继承一个指定包，默认struts-default</span></span><br><span class=\"line\"><span class=\"comment\">adstract:包是否是抽象的，标识性属性，该包不能独立运行，只能被继承</span></span><br><span class=\"line\"><span class=\"comment\"> --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hello\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/hello\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- action类：配置action类</span></span><br><span class=\"line\"><span class=\"comment\">\t\tname：决定了Action访问资源 </span></span><br><span class=\"line\"><span class=\"comment\">\t\tcalss:action的完整类名</span></span><br><span class=\"line\"><span class=\"comment\">\t\tmethod：指定调用Action中的哪个方法进行处理请求</span></span><br><span class=\"line\"><span class=\"comment\">\t\t --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"HelloAction\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.HelloAction\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"hello\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!-- result：结果配置</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tname：标识结果处理的名称：与action方法的返回值对应</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\ttype：指定定义哪个Result类来处理结果，默认使用转发</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t标签体：填写页面的相对路径</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t --&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> &gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"struts2常量配置\"><a href=\"#struts2常量配置\" class=\"headerlink\" title=\"struts2常量配置\"></a>struts2常量配置</h6><p><strong>default.properties文件所在位置：</strong></p>\n<p>​    Libraries</p>\n<p>​        Web App Libraries</p>\n<p>​            struts2-core-2.5.20.jar</p>\n<p>​                static</p>\n<p>​                    default.properties</p>\n<p><strong>常量的三种修改方式：</strong></p>\n<p>方式先后也是文件加载顺序</p>\n<ul>\n<li><p>struts.xml中,在\\<struts>根下，配置(常用)：</struts></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;struts&gt;</span><br><span class=\"line\">\t&lt;constant name=&quot;&quot; value=&quot;&quot;&gt;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&lt;/struts&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>src下新建struts.properties，在文件里填写修改的键值对</p>\n</li>\n<li><p>web.xml中，filter前进行配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;context-param&gt;</span><br><span class=\"line\">\t&lt;param-name&gt; &lt;/param-name&gt;</span><br><span class=\"line\">\t&lt;param-value&gt; &lt;/param-value&gt;</span><br><span class=\"line\">&lt;/context-param&gt;\t</span><br><span class=\"line\">&lt;filter&gt;......</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>常量</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- i18n：国际化，使用配置文件配置多个语言，可解决post提交乱码问题--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">\"struts.i18n.encoding=UTF-8:\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--struts.action.extension:指定访问action的后缀名--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">\"struts.action.extension\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"action,,\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--逗号标识隔开两个值--&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--指定struts是否以开放模式运行</span></span><br><span class=\"line\"><span class=\"comment\">\t1、可热加载主配置（不需重启即可生效）</span></span><br><span class=\"line\"><span class=\"comment\">\t2、提供更多错误信息输出，方便调试--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">\"struts.devMode\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"struts2配置进阶\"><a href=\"#struts2配置进阶\" class=\"headerlink\" title=\"struts2配置进阶\"></a>struts2配置进阶</h6><p><strong>动态方法调用</strong></p>\n<p>方式一：（了解）</p>\n<ul>\n<li><p>调用方法时，方法前加 ‘ ！’</p>\n</li>\n<li><p>主配置文件，struts下配置：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 配置动态方法调用是否开启的常量，默认是false --&gt;</span><br><span class=\"line\">&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>次配置</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">struts</span>&gt;</span>\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dynamic\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/dynamic\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">global-allowed-methods</span>&gt;</span>add,update<span class=\"tag\">&lt;/<span class=\"name\">global-allowed-methods</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Demo1Action\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.Demo1Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span>&gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>方式二：</p>\n<p>次配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;struts&gt;\t</span><br><span class=\"line\">\t&lt;package name=&quot;dynamic&quot; namespace=&quot;/dynamic&quot; extends=&quot;struts-default&quot;&gt;</span><br><span class=\"line\">\t\t&lt;global-allowed-methods&gt;add,update&lt;/global-allowed-methods&gt;</span><br><span class=\"line\">\t\t&lt;action name=&quot;Demo1Action_*&quot; class=&quot;cn_struct2.Demo1Action&quot; method=&quot;&#123;1&#125;&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;</span><br><span class=\"line\">\t\t&lt;/action&gt;</span><br><span class=\"line\">\t&lt;/package&gt;\t</span><br><span class=\"line\">&lt;/struts&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>默认配置</strong>（了解）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dynamic\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/dynamic\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- 找不到包下的action，会使用DemoAction作为默认action请求 --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">default-action-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"DemoAction\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">default-action-ref</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- method:execute --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- result的name属性：success --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- result的type属性：dispatcher转发 --&gt;</span>\t</span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!-- class属性：com.opensymphony.xwork2.ActionSupport --&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Demo1Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span>&gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"action类创建方式\"><a href=\"#action类创建方式\" class=\"headerlink\" title=\"action类创建方式\"></a>action类创建方式</h5><p>action类：public,返回String，可抛异常</p>\n<p>1、创建一个类，可以是POJO(普通类，不需要继承任何父类或实现接口)，使struts2代码侵入性更低</p>\n<p>2、实现Action接口，</p>\n<p>​    1）里面有execute方法，提供Action方法的规范</p>\n<p>​    2）Action接口预置了一些字符串，可在返回时使用</p>\n<p>3、继承一个类，ActionSupport（重点）</p>\n<p>​    帮助实现了Action、Validateable、ValidationAwre、TextProvider、LocaleProvider</p>\n<h4 id=\"结果跳转方式\"><a href=\"#结果跳转方式\" class=\"headerlink\" title=\"结果跳转方式\"></a>结果跳转方式</h4><h5 id=\"转发（默认-）\"><a href=\"#转发（默认-）\" class=\"headerlink\" title=\"转发（默认 ）\"></a>转发（默认 ）</h5><h5 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h5><h5 id=\"转发到Action\"><a href=\"#转发到Action\" class=\"headerlink\" title=\"转发到Action\"></a>转发到Action</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"chain\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"actionName\"</span> &gt;</span>DemoAction<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"namespace\"</span> &gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"重定向到Action\"><a href=\"#重定向到Action\" class=\"headerlink\" title=\"重定向到Action\"></a>重定向到Action</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"rediretAction\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"actionName\"</span> &gt;</span>DemoAction<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"namespace\"</span> &gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"访问ServletAPI方式\"><a href=\"#访问ServletAPI方式\" class=\"headerlink\" title=\"访问ServletAPI方式\"></a>访问ServletAPI方式</h4><p><strong>ActionContext</strong>:数据中心，可获得原生request(HttpServletRequest)、原生response(HttpServletResponse)、原生ServletContext、request域(Map)、session域(Map)、application域(Map)、params(Map)、attr域(Map,三个域合一)、ValueStack、、、</p>\n<p>生命周期：每次请求都会创建一个与请求对应的ActionContext对象，请求处理完域销毁，与当前线程绑定</p>\n<p>三种方式本质都是从ActionContext获得</p>\n<h5 id=\"通过actionContext\"><a href=\"#通过actionContext\" class=\"headerlink\" title=\"通过actionContext\"></a>通过actionContext</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//request域(struts2不推荐用request域）</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//request域和ActionContext生命周期一致，可用ActionContext代替request域</span></span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; object = (Map&lt;String, Object&gt;)ActionContext.getContext().get(<span class=\"string\">\"request\"</span>);</span><br><span class=\"line\">\t\tActionContext.getContext().put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"value\"</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//session域</span></span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; session = ActionContext.getContext().getSession();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//application域</span></span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; application = ActionContext.getContext().getApplication();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hello world\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"通过ServletActionContext\"><a href=\"#通过ServletActionContext\" class=\"headerlink\" title=\"通过ServletActionContext\"></a>通过ServletActionContext</h5><p>不推荐</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得actionAPI方式2</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生request域</span></span><br><span class=\"line\">\t\tHttpServletRequest request = ServletActionContext.getRequest();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生response域</span></span><br><span class=\"line\">\t\tHttpServletResponse response = ServletActionContext.getResponse();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生session域</span></span><br><span class=\"line\">\t\tHttpSession session =request.getSession();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//原生servletContext域</span></span><br><span class=\"line\">\t\tServletContext servletContext = ServletActionContext.getServletContext();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hello world\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"实现接口Aware\"><a href=\"#实现接口Aware\" class=\"headerlink\" title=\"实现接口Aware\"></a>实现接口Aware</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"title\">entends</span> <span class=\"title\">ActioSUpport</span> <span class=\"title\">implments</span> <span class=\"title\">ServletRequestAware</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpServletRequest request;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"原生Request\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\">ppublic <span class=\"keyword\">void</span> <span class=\"title\">setServletRequest</span><span class=\"params\">(HttpServletRequest request)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.request = request;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"获得参数\"><a href=\"#获得参数\" class=\"headerlink\" title=\"获得参数\"></a>获得参数</h4><h5 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h5><ul>\n<li><strong>Struts MVC</strong></li>\n</ul>\n<p>Filter：Ctroller</p>\n<p>Action:Module</p>\n<p>Result:View</p>\n<ul>\n<li>Action生命周期：每次请求到来时，都会创建一个新的Action实例，不会产生并发现象，线程安全，可使用成员变量来接受参数</li>\n</ul>\n<h5 id=\"属性驱动获得参数\"><a href=\"#属性驱动获得参数\" class=\"headerlink\" title=\"属性驱动获得参数\"></a>属性驱动获得参数</h5><p>Action准备与参数键同名属性</p>\n<p>可自动转换八大基本类型及其包装类和Date(支持特定字符串类型,例：yyyy-MM-dd)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得参数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo8Action</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//每次请求都会创建新的Action对象</span></span><br><span class=\"line\">\t<span class=\"comment\">//准备与参数键名称相同的属性</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String cust_name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"name的参数值：\"</span>+cust_name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCust_name</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cust_name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCust_name</span><span class=\"params\">(String cust_name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.cust_name = cust_name;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Customer.cust_name\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"对象驱动\"><a href=\"#对象驱动\" class=\"headerlink\" title=\"对象驱动\"></a>对象驱动</h5><p>Action准备与参数键同名属性    xxx.yyy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo8Action</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备customer属性</span></span><br><span class=\"line\">\tCustomer customer;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(customer.toString);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getCustomer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCustomer</span><span class=\"params\">(Customer customer)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.customer = customer;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"customer.name\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t年龄：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"customer.age\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"模型驱动\"><a href=\"#模型驱动\" class=\"headerlink\" title=\"模型驱动\"></a>模型驱动</h5><p>实现ModelDrivern接口，实现getModel方法，返回需要封装参数的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo8Action</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ModelDriven</span>&lt;<span class=\"title\">Customer</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//准备customer对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(customer.toString);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"success\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getModel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> customer</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\t用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t年龄：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"集合类型封装获得参数：\"><a href=\"#集合类型封装获得参数：\" class=\"headerlink\" title=\"集合类型封装获得参数：\"></a>集合类型封装获得参数：</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath &#125;/Demo8Action\"</span>&gt;</span></span><br><span class=\"line\">\t\tlist：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\tlist：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list[3]\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\tmap：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"map['haha']\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注：封装集合类型参数在前端可直接使用，使用时，map需先给出key</p>\n<h3 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h3><h4 id=\"OGNL表达式\"><a href=\"#OGNL表达式\" class=\"headerlink\" title=\"OGNL表达式\"></a>OGNL表达式</h4><p>OGNL:对象视图导航语言，例：$(user.addr.name)这种写法就成为对象视图导航</p>\n<p>OGNL不仅仅可视图导航，还支持比EL表达式更加丰富的功能</p>\n<h5 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h5><p>OGNL从OGNLContext对象取值（复习：EL取值：11大内置对象）</p>\n<p>OGNLContext对象分为ROOT和Context两部分：</p>\n<p>​    ROOT：可放置任何对象</p>\n<p>​    Context:    只存放Map</p>\n<h5 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h5><h6 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h6><p>ROOT取值：expression直接写要取值的属性名</p>\n<p>Context取值：expression写:#key.属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demo1</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> OgnlException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//1、准备OGNLContext</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//准备ROOT</span></span><br><span class=\"line\">\t\tUser rootUser = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Tom\"</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//准备Context</span></span><br><span class=\"line\">\t\tMap&lt;String ,User&gt; context = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">\t\tcontext.put(<span class=\"string\">\"user1\"</span>,<span class=\"keyword\">new</span> User(<span class=\"string\">\"lucy\"</span>, <span class=\"number\">7</span>));</span><br><span class=\"line\">\t\tcontext.put(<span class=\"string\">\"user2\"</span>,<span class=\"keyword\">new</span> User(<span class=\"string\">\"rose\"</span>, <span class=\"number\">8</span>));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tOgnlContext oc = <span class=\"keyword\">new</span> OgnlContext();</span><br><span class=\"line\">\t\toc.setRoot(rootUser);</span><br><span class=\"line\">\t\toc.setValues(context);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、书写OGNL表达式</span></span><br><span class=\"line\">\t\tString name = Ognl.getValue(<span class=\"string\">\"name\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\t\tString name = Ognl.getValue(<span class=\"string\">\"#user1.name\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h6><p>ROOT：属性=值</p>\n<p>Context:#key.属性=值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">\tString name = Ognl.getValue(<span class=\"string\">\"name='jerry'\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\tString name = Ognl.getValue(<span class=\"string\">\"#user1.name='jerry'\"</span>, context, oc.getRoot());</span><br><span class=\"line\">\t<span class=\"comment\">//表达式可串联，但是如果表达式都有返回值，则取最后一个表达式的值</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ognl.getValue(<span class=\"string\">\"setName('jerry')\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name = Ognl.getValue(<span class=\"string\">\"getName()\"</span>, context, oc.getRoot());</span><br><span class=\"line\"></span><br><span class=\"line\">String name = Ognl.getValue(<span class=\"string\">\"#user1.setName('jerry'),#user2.getName()\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name = Ognl.getValue(<span class=\"string\">\"#user1.getName()\"</span>, context, oc.getRoot());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//静态方法调用</span></span><br><span class=\"line\">String name = （String）Ognl.getValue(<span class=\"string\">\"@完整包名@方法名\"</span>, context, oc.getRoot());</span><br><span class=\"line\">Double pi = (Double)Ognl.getValue(<span class=\"string\">\"@java.lang.Math@PI\"</span>, context, oc.getRoot());</span><br><span class=\"line\"><span class=\"comment\">//Math是OGNL对象的内置对象</span></span><br><span class=\"line\">(Double)Ognl.getValue(<span class=\"string\">\"@@PI\"</span>, context, oc.getRoot());</span><br></pre></td></tr></table></figure>\n<h6 id=\"创建List和Map对象\"><a href=\"#创建List和Map对象\" class=\"headerlink\" title=\"创建List和Map对象\"></a>创建List和Map对象</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建list对象</span></span><br><span class=\"line\">Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name1 = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;[0]\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name2 = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;.get(1)\"</span>, context, oc.getRoot());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建Map对象</span></span><br><span class=\"line\">Ognl.getValue(<span class=\"string\">\"#&#123;'name':'Tome','age':18&#125;\"</span>, context, oc.getRoot());</span><br><span class=\"line\">String name3 = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;['name']\"</span>, context, oc.getRoot());</span><br><span class=\"line\"><span class=\"keyword\">int</span> age = = Ognl.getValue(<span class=\"string\">\"&#123;'hello','tom','penny'&#125;.get('age')\"</span>, context, oc.getRoot());</span><br></pre></td></tr></table></figure>\n<h4 id=\"OGNL与struts2结合\"><a href=\"#OGNL与struts2结合\" class=\"headerlink\" title=\"OGNL与struts2结合\"></a>OGNL与struts2结合</h4><p>OGNlContext–&gt;ValueStack值栈</p>\n<p>ROOT：栈，栈中放置当前访问的Action对象</p>\n<p>Context：ActionContext（数据中心）</p>\n<h5 id=\"结合体现：\"><a href=\"#结合体现：\" class=\"headerlink\" title=\"结合体现：\"></a>结合体现：</h5><h6 id=\"参数接收\"><a href=\"#参数接收\" class=\"headerlink\" title=\"参数接收\"></a>参数接收</h6><p>struts2的参数交给OGNL引擎处理</p>\n<p><img src=\"\\img\\javaWeb\\OGNL_Struts原理.JPG\" height=\"200px\"></p>\n<p><img src=\"\\img\\javaWeb\\OGNL_Struts原理2.JPG\" height=\"250px\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将参数压入栈</span></span><br><span class=\"line\"><span class=\"comment\">//方法一</span></span><br><span class=\"line\"><span class=\"comment\">//public class DemoAction extends ActionSupport implements Preparable&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\tprivate Customer u = new Customer();</span></span><br><span class=\"line\"><span class=\"comment\">//\tpublic String execute() &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\t\treturn SUCCESS;</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//\t@Override</span></span><br><span class=\"line\"><span class=\"comment\">//\tpublic void prepare() throws Exception &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t// TODO Auto-generated method stub</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t//压入栈顶</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t//1、获得栈值</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tValueStack vs = ActionContext.getContext().getValueStack();</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t//2、将u压人栈顶</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tvs.push(u);</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法二</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ModelDriven</span>&lt;<span class=\"title\">Customer</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer u = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//压入栈顶</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//1、获得栈值</span></span><br><span class=\"line\">\t\tValueStack vs = ActionContext.getContext().getValueStack();\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、将u压人栈顶</span></span><br><span class=\"line\">\t\tvs.push(u);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> u;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h6><p>${ognl表达式}</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"redirectAction\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"actionName\"</span> &gt;</span>DemoAction<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"namespace\"</span> &gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--如果提交的参数struts看不懂，就会作为参数附加在重定向的路径之后，如果参数是动态的，可以OGNL\t\t表达式：</span></span><br><span class=\"line\"><span class=\"comment\">\t  age=xx，$&#123;OGNL表达式&#125;--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"age\"</span> &gt;</span>$&#123;age&#125;<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"struts2标签\"><a href=\"#struts2标签\" class=\"headerlink\" title=\"struts2标签\"></a>struts2标签</h6><h4 id=\"扩展-源码流程\"><a href=\"#扩展-源码流程\" class=\"headerlink\" title=\"扩展:源码流程\"></a>扩展:源码流程</h4><ul>\n<li><p>request.getAttribute()查找顺序：</p>\n<ul>\n<li>原生request域</li>\n<li>ValueStack的栈（Root）</li>\n<li>ValueStack的Context部分(ActionContext)</li>\n</ul>\n</li>\n<li><p>拦截器的调用：递归调用</p>\n<p>defaultActionInvocation调用interceptor.intercept()，interceptor调用defaultActionInvocation.invoke()</p>\n</li>\n</ul>\n<h3 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h3><p>准备工作：用户登录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ModelDriven</span>&lt;<span class=\"title\">Customer</span>&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Customer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserService us = <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//调用service，执行登录操作</span></span><br><span class=\"line\">\t\tCustomer c = us.login(customer);</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、将返回的Customer对象放入session域作为登录标识</span></span><br><span class=\"line\">\t\tActionContext.getContext().getSession().put(<span class=\"string\">\"customer\"</span>,c);</span><br><span class=\"line\">\t\t<span class=\"comment\">//3、重定向到项目的首页</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"toHome\"</span>;<span class=\"comment\">//重定向页面的name属性</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">getModel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Customer <span class=\"title\">login</span><span class=\"params\">(Customer customer)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Hibernate打开事务</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tCustomerDao cd = <span class=\"keyword\">new</span> CustomerDao();</span><br><span class=\"line\">\t\t<span class=\"comment\">//1、调用Dao根据登录名称查询的Customer对象</span></span><br><span class=\"line\">\t\tCustomer existCustomer = cd.getByCode(customer.getCust_name().hashCode());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//提交事务</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//抛出异常，用户不存在</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(existCustomer==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"同户名不存在\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、比对密码是否一致（Id)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!existCustomer.getCust_id().equals(customer.getCust_id())) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//不一致，抛出异常提示</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"密码错误\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//将数据库查询到的Customer返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> existCustomer;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"crm\"</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">extends</span>=<span class=\"string\">\"struts-default\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">global-exception-mappings</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--若出现该异常，跳转到结果为error的页面--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">exception-mapping</span> <span class=\"attr\">result</span>=<span class=\"string\">\"error\"</span> <span class=\"attr\">exception</span>\"<span class=\"attr\">exception</span>完整类名\"&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">exception-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">global-exception-mappings</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Demo1Action_*\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn_struct2.Demo1Action\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"&#123;1&#125;\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"success\"</span>&gt;</span>/hello.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"error\"</span>&gt;</span>/login.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--密码错误在新页面提示--&gt;</span><br><span class=\"line\">&lt;!--跳转到的页面使用debug标签--&gt;</span><br><span class=\"line\">&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;s:debug&gt;&lt;/s:debug&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义拦截器\"><a href=\"#自定义拦截器\" class=\"headerlink\" title=\"自定义拦截器\"></a>自定义拦截器</h4><p>拦截器生命周期：随项目的启动创建，随项目的关闭而销毁</p>\n<h5 id=\"拦截器的创建\"><a href=\"#拦截器的创建\" class=\"headerlink\" title=\"拦截器的创建\"></a>拦截器的创建</h5><p>方式一：实现接口Interceptor</p>\n<p>方式二：继承AbstractInterceptor(该继承抽象类空实现了Interceptor)</p>\n<p>方式三：继承MethodFilterInterceptor，功能：定制拦截器拦截的方法,可定制需要拦截或不需要拦截的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//拦截器：创建方式一</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Interceptor</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法二：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterceptor_2</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractInterceptor</span></span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//方式二：</span></span><br><span class=\"line\"><span class=\"comment\">//功能：定制拦截器拦截的方法</span></span><br><span class=\"line\"><span class=\"comment\">//实现方法doIntercept();</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterceptor_2</span> <span class=\"keyword\">extends</span> <span class=\"title\">MethodFilterInterceptor</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">doIntercept</span><span class=\"params\">(ActionInvocation arg0)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//前处理</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//放行</span></span><br><span class=\"line\">\t\tinvocation.invoke();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//后处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拦截器配置\"><a href=\"#拦截器配置\" class=\"headerlink\" title=\"拦截器配置\"></a>拦截器配置</h5><h5 id=\"拦截方法指定\"><a href=\"#拦截方法指定\" class=\"headerlink\" title=\"拦截方法指定\"></a>拦截方法指定</h5><p>不拦截和需要拦截的方法不能同时指定</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">package</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">interceptors</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--注册拦截器--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myInter\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"完整类名\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">interceptor</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--注册拦截器栈--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor-stack</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myStack\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--自定义拦截器默认 放在20个拦截器之前--&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myInter\"</span>&gt;</span></span><br><span class=\"line\">            \t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"excludeMythods\"</span>&gt;</span>add,delete<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span>                               <span class=\"tag\">&lt;/<span class=\"name\">interceptor-ref</span>&gt;</span></span><br><span class=\"line\">            \t<span class=\"tag\">&lt;<span class=\"name\">param</span> <span class=\"attr\">name</span>=<span class=\"string\">\"includeMythods\"</span>&gt;</span>add,delete<span class=\"tag\">&lt;/<span class=\"name\">param</span>&gt;</span>                               <span class=\"tag\">&lt;/<span class=\"name\">interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"defaultStack\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">interceptor-stack</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">interceptors</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--指定默认拦截器栈,作用范围是整个包--&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">default-interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myStack\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">default-interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myInter\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--或为action单独指定哪个拦截器--&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">default-interceptor-ref</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myStack\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">default-interceptor-ref</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">name</span>=<span class=\"string\">\"error\"</span>&gt;</span>/index.jsp<span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">action</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">package</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>定义全局结果集</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;global-results&gt;&lt;/global-results&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><p>（了解）</p>\n<p>struts标签分类：</p>\n<ul>\n<li><p>普通标签：</p>\n<ul>\n<li>控制标签(iterater、if、elseif、else)</li>\n<li>数据标签(property)</li>\n</ul>\n</li>\n<li><p>ul标签：</p>\n<ul>\n<li>表单标签(form、textfield、password、file、checkboxlist、redio…)</li>\n<li>非表单标签(Actionerror)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"普通标签\"><a href=\"#普通标签\" class=\"headerlink\" title=\"普通标签\"></a>普通标签</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--普通标签--&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;!-- 遍历标签 iterator --&gt;</span><br><span class=\"line\">\t&lt;s:interator value=<span class=\"string\">\"#list\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;s:property/&gt;</span><br><span class=\"line\">\t&lt;/s:interator&gt;</span><br><span class=\"line\">\t&lt;!-- 遍历方式二 --&gt;</span><br><span class=\"line\">\t&lt;s:interator value=<span class=\"string\">\"#list\"</span> <span class=\"keyword\">var</span>=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;s:property value=<span class=\"string\">\"#name\"</span>/&gt;</span><br><span class=\"line\">\t&lt;/s:interator&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;!-- <span class=\"keyword\">if</span>标签 --&gt;</span><br><span class=\"line\">\t&lt;s:<span class=\"keyword\">if</span> test=<span class=\"string\">\"#list.size()==4\"</span>&gt;</span><br><span class=\"line\">\t\tlist长度为<span class=\"number\">4</span></span><br><span class=\"line\">\t&lt;/s:if&gt;</span><br><span class=\"line\">\t&lt;s:esle&gt;</span><br><span class=\"line\">\t\tlist长度不为<span class=\"number\">4</span></span><br><span class=\"line\">\t&lt;/s:esle&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&lt;!-- property标签 ,配合ognl表达式页面取值使用--&gt;</span><br><span class=\"line\">\t&lt;s:property value=<span class=\"string\">\"#value.size()\"</span>/&gt;</span><br><span class=\"line\">\t&lt;s:property value=<span class=\"string\">\"#session.use.name\"</span>/&gt;\t\t</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h4><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- struts表单标签 --&gt;</span><br><span class=\"line\">\t&lt;!-- 好处：内置了一套样式；自动回显，根据栈中的属性 --&gt;</span><br><span class=\"line\">\t&lt;!-- theme属性，指定表单主题，默认xml主题 --&gt;</span><br><span class=\"line\">\t&lt;s:form action=<span class=\"string\">\"DemoAction\"</span> namespace=<span class=\"string\">\"/\"</span> theme=<span class=\"string\">\"simple\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;!-- 表单提交，提示：用户名 --&gt;</span><br><span class=\"line\">\t\t&lt;s:textfield name=\"name\"lable=\"用户名\"&gt;&lt;/s:textfield&gt;</span><br><span class=\"line\">\t\t&lt;s:password name=\"password\" lable=\"密码\"&gt;&lt;/s:password&gt;</span><br><span class=\"line\">\t\t&lt;!-- 单选 --&gt;</span><br><span class=\"line\">\t\t&lt;s:radio list=\"&#123;'男',''女&#125;\"  name=\"gender\" value=\"性别\"&gt;&lt;/s:radio&gt;</span><br><span class=\"line\">\t\t&lt;s:radio list=\"#&#123;1:'男',0:'女'&#125;\"  name=\"gender\" value=\"性别\"&gt;&lt;/s:radio&gt;</span><br><span class=\"line\">\t\t&lt;!-- 多选 --&gt;</span><br><span class=\"line\">\t\t&lt;s:checkboxlist list=\"#&#123;1:'游泳',0:'打球',2:'跑步'&#125;\" name=\"hobby\" lable=\"爱好\"&gt;&lt;/s:checkboxlist&gt;</span><br><span class=\"line\">\t\t&lt;!-- 下拉选 --&gt;</span><br><span class=\"line\">\t\t&lt;s:select list=\"#&#123;2:'大专',1:'本科',0:'硕士' &#125;\" headerKey=\"\" headerValue=\"--请选择--\" name=\"edu\" lable=\"学历\"&gt;&lt;/s:select&gt;</span><br><span class=\"line\">\t\t&lt;!-- 文件上传 --&gt;</span><br><span class=\"line\">\t\t&lt;s:file name=\"photo\" lable=\"近照\"&gt;&lt;/s:file&gt;</span><br><span class=\"line\">\t\t&lt;!-- 文本域 --&gt;</span><br><span class=\"line\">\t\t&lt;s:textarea name=\"desc\" lable=\"个人简介\"&gt;&lt;/s:textarea&gt;</span><br><span class=\"line\">\t\t&lt;s:submit value=\"提交\"&gt;&lt;/s:submit&gt;</span><br><span class=\"line\">\t&lt;/s:form&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"非表单标签\"><a href=\"#非表单标签\" class=\"headerlink\" title=\"非表单标签\"></a>非表单标签</h4><figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//action中的方法加入错误提示信息</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.addActionError(<span class=\"string\">\"你错了\"</span>)!</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--使错误信息在页面显示--&gt;</span><br><span class=\"line\">&lt;s:actionerror/&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"javaEE-framework开篇——hibernate","date":"2019-04-18T06:05:48.000Z","description":"hibernate是我学习JavaEE framework的开始，分享学习的笔记给大家~","_content":"\n​\thibernate是我学习JavaEE framework的开始，分享学习的笔记给大家~\n\n#### 搭建\n\n1）导包\n\n2）创建数据库\n\n3）书写Orm元数据(对象与表的映射配置文件)\n\n导入约束、实体、orm元数据\n\n4）书写主配置文件\n\nhibernate.cfg.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n\t\n<hibernate-configuration>\n\t<session-factory>\n\t\t<property name=\"hibernate.connection.dirver_class\">com.mysql.cj.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql:///hibernate?useSSL=false&amp;serverTimezone=GMT%2b8&amp;allowPublicKeyRetrieval=true</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">yue18800422369</property>\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQL5Dialect</property>\n\t\t\n\t\t<property name=\"hibernate.show_sql\">true</property>\n\t\t<property name=\"hibernate.format_sql\">true</property>\n\t\t\n\t\t<property name=\"hibernate.hbm2ddl.auto\">update</property>\n\t\t\n\t\t<mapping resource=\"domain/Customer.hbm.xml\"/>\n\t</session-factory>\n</hibernate-configuration>\n```\n\n5）书写代码测试\n\n映射文件:Customer.hbm.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC\n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n<!-- 配置表与实体对象的关系 -->\n<hibernate-mapping>\n\t<class name=\"domain.Customer\" table=\"cst_customer\">\n\t\t<id name=\"cust_id\" column=\"cust_id\">\n\t\t\t<generator class=\"native\"></generator>\n\t\t</id>\n\t\t<property name=\"cust_name\" column=\"cust_name\"></property>\n\t\t<property name=\"cust_source\" column=\"cust_source\"></property>\n\t\t<property name=\"cust_industry\" column=\"cust_industry\"></property>\n\t\t<property name=\"cust_level\" column=\"cust_level\"></property>\n\t\t<property name=\"cust_linkman\" column=\"cust_linkman\"></property>\n\t\t<property name=\"cust_phone\" column=\"cust_phone\"></property>\n\t\t<property name=\"cust_mobile\" column=\"cust_mobile\"></property>\n\t\n\t</class>\n</hibernate-mapping>\n```\n\n\n\n#### hibernateAPI详解\n\n##### configuration\n\n读取配置文件：主配置和orm元数据\n\n##### SessionFactory\n\n用于创建操作数据库核心对象session对象的工厂\n注：1、sessionFactory负责保存和使用所有配置信息，消耗内存资源非常大\n​\t2、sessionFactory属于线程安全的对象设计\n结论：保证在web项目中，只创建一个sessionFactory\n\n##### Session\n\n表达hibernate框架与数据库之间的连接（会话），类似于JDBC的connection对象，可实现数据库的增删改查\n\n##### Transaction\n\n封装了事务的操作：打开事务、提交事务、回滚事务\n\n```java\n//1、创建\n\t\tConfiguration conf = new Configuration().configure();\n\t\t//2、读取主配置文件,无参读取：hibernate.cfg.xml\n\t\tconf.configure();\n\t\t\n//\t\t//读取指定orm元数据(old)\n//\t\tconf.addResource(resourceName);\n//\t\tconf.addClass(persistentClass);\n\t\t//4、根据配置信息，创建sessionFactory对象\n\t\tSessionFactory sessionFactory = conf.buildSessionFactory();\n\t\n\t\t//5、获得session\n\t\tSession session = sessionFactory.openSession();\n\t\t//打开一个新的session对象\n\t\t//sessionFactory.openSession();\n\t\t//获得一个与线程绑定的session对象\n\t\t//sessionFactory.getCurrentSession();\n\t\t\n\t\t//6、session获得操作事务的Transaction对象\n\t\t//获得操作事务的tx对象\n\t\t//Transaction tx = session.getTransaction();\n\t\t//tx.begin();\n\t\t//开启事务并获得操作事务的tx对象（建议使用）\n\t\tTransaction tx2 = session.beginTransaction();\n\t\t\n\t\t//...................\n\t\t//增\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setCust_name(\"best\");\n\t\tsession.save(customer);\t\n\t\t//查询\n\t\tCustomer customer2 = session.get(Customer.class, 1l);\t\n\t\t//修改\n\t\tCustomer customer3  = session.get(Customer.class,1L);\n\t\tcustomer3.setCust_name(\"angle\");\n\t\tsession.update(customer3);\n\t\t//删除\n\t\tCustomer customer4 = session.get(Customer.class, 1l);\n\t\tsession.delete(customer4);\n\t\t//...............\n\t\t\n\t\ttx2.commit();\n\t\tsession.close();\n\t\tsessionFactory.close();\n\t\t\n```\n\n#### 实体规则\n\n##### 创建规则\n\n- 持久化类提供无参构造(通过反射创建对象)\n\n- 成员变量私有，需提供get/set（属性）\n\n- 持久化类中的属性，应尽量使用包装类型\n\n- 持久化类需要oid与数据库中的主键列对应\n- 不要用final修饰class（hibernate使用cglib代理生成代理对象，代理对象继承被代理对象，如果被final修饰，将无法代理）\n\n##### 主键类型\n\n###### 自然主键\n\n表的业务列中，其中必须有且不可重复的列可作为主键使用\n\n###### 代理主键\n\n表的业务列中，没有可作为主键的列，则创建一个没有业务的列作为主键\n\n##### 主键生成策略\n\n每条记录生成时，主键的生成规则（7个）\n\n- identity：主键自增，由数据库来维护主键值，录入时不需指定主键\n- sequence：Oracle中的主键生成策略\n- increment（了解）：主键自增，由hibernate来维护，每次插入前，会先查询表中id最大值，然后加1作为主键值（线程不安全）\n\n- hilo（了解）：高低位算法，由hibernate维护\n- native：hilo+sequence+identity，自动三选一\n- uuid： 产生随机字符串作为主串\n- assigned：自然主键生成，由用户录入生成\n\n#### hibernate的对象状态\n\n对象分为三种状态：\n\n- 瞬时状态：没有id，没有与session关联\n\n- 持久化状态：有id，与session关联\n\n  持久化状态的对象的任何变化都会自动同步到数据库中，不需要执行update方法\n\n- 游离/托管状态：有id，没有与session关联\n\n注：有id指的是有和数据库中对应的id\n\n状态转化：\n\n起点$\\rightarrow$瞬时（new）\n\n起点$\\rightarrow$持久化（get）\n\n瞬时 $\\rightarrow $持久化(save) $\\rightarrow $游离/托管状态(close)\n\n瞬时 $\\leftarrow $持久化(delete) $\\leftarrow $游离/托管状态(update)\n\nsaveOrUpdate:将所有对象转化为持久化状态\n\n（持久化对象就是放入session缓存的对象）\n\n#### hibernate的进阶--缓存\n\n提高效率的方式：\n\n- 提高查询效率（缓冲区）\n- 减少不必要的修改语句发送（利用快照）\n\n#### 事务\n\n- 性质：\n\n  - 原子性\n\n  - 一致性：数据在提交前和提交后总量保持一致\n\n  - 隔离性\n\n  - 持久性：数据提交之后必须要被持久化保存\n\n- 并发问题：\n\n  - 脏读：读取到了正在操作并未保存的数据；B事务读取了A事务没有提交的数据\n\n  - 不可重复读：在一个事务中，两次读取的事务不一致\n\n  - 幻/虚读：一般针对整表的操作；一个事务中，两次读取的数据的数量不一致\n\n- 事务的隔离级别：\n\n  - 读未提交 1*：脏读、不可重复读、幻读（可产生问题）\n\n  - 读已提交 2*：不可重复读、幻读\n\n  - 可重复读 4*（MySQL默认级别）：幻读\n\n  - 串行化 8*\n\n- 在hibernate指定隔离级别：1 2 4 8\n\n- 在项目中管理项目\n\n  dao层数据操作和service层控制事务都需要session对象，要确保使用的是同一个session对象：\n\n  1）在hibernate中调用getCurrentSession方法获得与线程绑定的session对象，调用该方法时，必须在主配置中主配置中说明：\n\n  ```xml\n  <property name=\"hibernate.current_session_context_class\">thread</property>\n  ```\n\n  2）通过getCurrentSession方法获得session对象，当事务提交时session会自动关闭，不许手动。\n\n#### 批量查询\n\n##### HQL查询\n\n多表查询，但不复杂时使用\n\nhibernate独家查询语言，面向对象\n\n```javascript\n//1、书写HQL语句\n\t\t//String hql = \"from 对象的完整类名\";\n\t\t//String hql = \"from Customer where cust_id = 1\";//cust_id是属性\n\t\t//String hql = \"from Customer\";//查询所有Customer对象\n\t\t//String hql = \"from Customer where cust_id = ?\";//问号占位符\n\t\tString hql = \"from Customer where cust_id ：id\";\n\t\t\n\t\t//2、根据HQL语句创建查询对象\n\t\tQuery<Customer> query = session.createQuery(hql);\n\t\t\n\t\t//分页查询\n\t\t//设置分页信息\n\t\tquery.setFirstResult(0);//第0条开始查询\n\t\tquery.setMaxResults(2);//最多查询两条\n\t\t\n\t\t//设置参数(占位符）\n\t\tquery.setLong(0, 1);//问号占位符\n\t\tquery.setParameter(0, 1);//类型通用\n\t\tquery.setParameter(\"id\", 1);//命名占位符\n\t\t//3、根据查询对象获得查询结果\n\t\tList list = (List) query.list();\n\t\t//query.uniqueResult();//接收唯一的查询对象\n```\n\n##### Criteria查询\n\n单表查询\n\nhibernate自创的无语句面向对象查询\n\n```\n\t//Criteria查询\n\t//查询所有Customer对象\n\tCriteria criteria = session.createCriteria(Customer.class);\n\t//普通查询\n\tList<Customer> list2  = criteria.list();\n\t//条件查询\n\tcriteria.add(Restrictions.eq(\"cust_id\",1));\n\t//criteria.add(Restrictions.IdEq(1));\n\tCustomer c = (Customer) criteria.uniqueResult();\n\t//分页\n\tcriteria.setFirstResult(1);\n\tcriteria.setMaxResults(1);\n\t//查询总记录\n\t//设置查询的聚合函数=》总行数\n\tcriteria.setProjection(Projections.rowCount());\n\tLong count = (Long) criteria.uniqueResult();\n```\n\n常见查询条件:\n\n| >    | gt   | between and | between   |\n| ---- | ---- | ----------- | --------- |\n| >=   | lt   | like        | like      |\n| <    | lt   | is not null | isNotNull |\n| <=   | le   | is null     | isNull    |\n| ==   | eq   | or          | or        |\n| !=   | in   | and         | and       |\n\n##### 原生SQL查询\n\n复杂的业务查询\n\n```javascript\n\t//原生SQL查询\n\t\t//String sql = \"select * from cst_customer\";\n\t\t//条件查询与分页\n\t\tString sqlString  = \"select * from csy_customer limit ?,?\";\n\t\t\n\t\tSQLQuery<Object[]> query2 = session.createSQLQuery(sql);\n\t\t\n\t\tquery2.setParameter(0, 0);\n\t\tquery2.setParameter(1, 1);\n\t\t\n\t\t//查询到的每行结果放到一个object数组\n\t\t//List<Object[]> list3 = query2.list();\n\t\t\n\t\t//封装结果\n\t\tquery2.addEntity(Customer.class);\n\t\tList<Customer> list3 = query2.list();\n```\n\n#### 多对多关系\n\n##### 一对多、多对一\n\n###### 关系的表达\n\n```\n<!-- 集合，一对多关系的配置 -->\n\t\t<!--\n\t\t name:集合属性名\n\t\t column:外键列名\n\t\t class：关联的对象的完整类名\n\t\t -->\n\t\t<set name=\"LinkMen\" cascade：save-update>\n\t\t\t<key column=\"lkm_cust_id\"></key>\n\t\t\t<one-to-many class=\"LinkMan\"/>\n\t\t</set>\n\t\t\n\t\t<!-- 多对一的配置 -->\n\t\t<many-to-one name=\"customer\" column=\"lkm_cust_id\" class=\"Customer\"></many-to-one>\n\t\t\n```\n\n###### 操作\n\n```\n\t//保存客户以及客户下的联系人\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setCust_name(\"blog\");\n\t\t\n\t\tLinkMan lMan1 = new LinkMan();\n\t\tlMan1.setLkm_name(\"man1\");\n\t\tLinkMan lMan2 = new LinkMan();\n\t\tlMan2.setLkm_name(\"man2\");\n\t\tLinkMan lMan3 = new LinkMan();\n\t\tlMan3.setLkm_name(\"man3\");\n\t\t//表达一对多，一个客户有多个联系人\n\t\tcustomer.getLinkmen().add(lMan1);\n\t\tcustomer.getLinkmen().add(lMan2);\n\t\t//表达多对一，联系人属于哪个客户\n\t\tlMan1.setCustomer(customer);\n\t\tlMan2.setCustomer(customer);\n\t\t\n\t\tsession.save(customer);\n\t\tsession.save(lMan1);\n\t\tsession.save(lMan2);\n```\n\n###### 进阶\n\n**联操作**\n\ncascade（配置文件配置）\n\n​\tsave-update:级联保存更新\n\n​\tdelete：级联删除\n\n​\tall：save-update+delete\n\n**关系维护**\n\n在保存时，两方都会维护关系，冗余\n\ninverse属性：配置关系是否维护，默认是false(维护），但是多的一方不能放弃维护\n\n##### 多对多\n\n配置\n\n```\n<set name=\"set集合名\" table=\"中间表名\">\n\n\t<key column=\"对方引用的自己的外键名>\"\n\n\t<many-to-many class=\"与哪个别的类多对多\" column=\"引用的别人的外键\">\n\n</set>\n```\n\n注：开发中利用inverse属性，根据业务方向选择一方放弃维护关系\n\n**小结**\n\n**一对多/多对一**\n\n- O：对象  \n\n    一的一方使用集合，多的一方直接引用一的一方\n\n- R：关系型数据库      \n\n  多的一方使用外键引用一的一方主键\n\n- M：映射文件  \n\n  ```\n  一：<set name=\"\">\n  \n  \t\t<key column = \"\"/>\n  \n  \t\t<one-to-many name=\"\" column=\"\" class=\"\"/>\n  \n  \t</set>\n  \n  多：<many-to-one name=\"\" column=\"\" class=\"\"/>\n  ```\n\n  关系操作：级别属性\n\n  进阶：\n\n  ​\tinverse：反转关系维护,性能优化（true：放弃，默认false维护），一对多中，一的一方可放弃维护关系\n\n  ​\tcasecade：级联操作，减少代码（nono(默认)：不级联save-update、delete、all)\n\n**多对多**\n\n- O：对象\n\n  两方都使用集合\n\n- R：使用中间表，至少两列，作为外键引用两张表的主键\n\n- M：映射文件\n\n```\n多：\n<set name=\"\" table=\"中间表名\">\n\t<key column=\"别人引用的自己的外键\">\n\t<many-to-many class=\"\" column=\"引用别人的外键名\"/>\n</set>\t\n```\n\n操作：操作管理级别属性\n\n- casede:级联属性，减少代码书写\n\n​\tnono(默认)：不级联\n\n​\tsave-update、delete、all\n\n- inverse:反转关系维护，属于性能优化，必须根据业务关系选择一方放弃维护主键关系\n\n##### 检索\n\n###### 查询小结\n\noid查询-get\n\n对象属性导航查询\n\nHQL\n\nCriteria\n\n原生SQL\n\n###### HQL查询\n\n**基本语法**\n\n```\nString hql = “from java.lang.Object\"//查询所有Object及其子类\n```\n\n**排序语法**\n\n```\nString hql = \"from Customer order by id asc\"//asc：升序\n\nString hql = \"from Customer order by id desc，xxxx  desc/asc\n\n\"//desc：降序,如果相同，可根据别的列按照desc/asc再排序\n```\n\n**条件查询**\n\n```\nString hql = \"from Customer where id =？\"\n\nString hql = \"from Customer where id: id\"\n```\n\n**分页查询**\n\n```\nString hql = \"from con.itcast.domain.Customer\";\n\nquery query = session.creatQuery(hql);\n\n//limit ?， ?\n\nquery.setFirstResult(0);//从第0条开始查询\n\nquery.setFirstResult(2);//每页查询两条\n```\n\n**统计查询**\n\n聚合函数：count（计数）、sum(求和）、avg（平均数）、max、min\n\n```\nString hql = \"select count(*) from Customer\"//总记录数 \n//String hq2 = \"select sum(id) from Customer\"\n//String hql = \"select avg(id) from Customer\"\n//String hql = \"select max(id) from Customer\"\n//String hql = \"select min(id) from Customer\"\nQuery query = session.creatQuery(hql);\n\nNumber number = (Number) query.uniqueResult();\n```\n\n**投影查询**\n\n```\nString hql = \"select cust_name from Customer\"//查询name\nString hql = \"select cust_name,cust_id from Customer\";//查询name和id两列，返回数组\nString hql = \"select newCustomer(cust_name,cust_id) from Customer\";//将查询的每个name和id封装到对应Customer对象中\n//注：必须在Customerclass类中添加参数为name和id的构造方法以及无参构造方法\n```\n\n**多表查询**\n\n- 原生SQL：\n\n  交叉连接：笛卡尔积selecte * from A,B\n\n  内连接：\n\n  ​\t隐式内连接：selecte * from A,B where 条件\n\n  ​\t显式外连接：selecte * from A inner join B on  条件\n\n  外连接：\n\n  ​\t左外连接：selecte * from A left [outer] join B on 条件\n\n  ​\t右外连接:selecte * from A right [outer] join B on 条件\n\n- HQL查询：\n\n  - 内连接：\n\n  ​\tString hql = \"from Customer c inner join c.LinkMen\";//将对应的两个对象分别封装到数组\n\n  ​\t迫切：String hql = \"from Customer c inner join fetch c.LinkMen\";//把第二个表的东西封装到第一个对象中\n\n  - 左外连接：String hql = \"from Customer c left join c.LinkMen\"\n\n  - 右外连接：String hql = \"from Customer c right join c.LinkMen\"\n\n###### Criterla查询（QBC）\n\n**基本**\n\n```\n//Criteria查询\n\t//查询所有Customer对象\n\tCriteria criteria = session.createCriteria(Customer.class);\n\t\n\t//普通查询\n\tList<Customer> list2  = criteria.list();\n\t\n\t//条件查询\n\tcriteria.add(Restrictions.eq(\"cust_id\",1));\n\t//criteria.add(Restrictions.IdEq(1));\n\tCustomer c = (Customer) criteria.uniqueResult();\n\t\n\t//分页\n\tcriteria.setFirstResult(1);\n\tcriteria.setMaxResults(1);\n\t\n\t//查询总记录\n\t//设置查询的聚合函数=》总行数\n\tcriteria.setProjection(Projections.rowCount());\n\tLong count = (Long) criteria.uniqueResult();\n```\n\n**条件**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\ncriteria.add(Restrictions.eq(\"cust_id\",1));\n//criteria.add(Restrictions.IdEq(1));\nCustomer c = (Customer) criteria.uniqueResult();\n```\n\n**分页**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\nc.setFirstResult(0);\nc.setMaxResult(2);\nList<Customer> list = c.list;\n```\n\n**排序**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\nc.addOrder(Order.asc(\"cust_id\"));\nList<Customer> list = c.list;\n```\n\n**统计**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\nc.setProject(Projections.rowCount());\nList<Long> list = c.list;\n```\n\n**离线查询**\n\n传统的criteria依赖于session创建（dao层）\n\n离线的criteria，可脱离session，在任意层均可凭空创建（扩大session的作用范围）\n\n```\n//web或service层\nDetachedCriteria dc = DetachedCriteria.forClass(Customer.class);\ndc.add(Restrictions.idEq(61));//拼装条件与普通一致\n\n\n//dao层\nCriteria c = dc.getExecutableCriteria(session)\nList list = c.list();\n```\n\n##### 查询优化\n\n###### 类级别查询\n\n懒加载|延迟加载\n\nget:立即加载，执行方法时立即发送SQL语句查询结果\n\nload(默认)：结果和get一样，执行时，不发送任何SQL语句，返回一个对象，使用该对象时，才执行查询\n\n延时加载：仅仅获得不使用，不会查询，使用时才进行查询，（针对load方法），原理是动态代理\n是否对类进行延迟加载，可通过在class元素上配置lazy属性控制：\n​\tlazy=true：加载时，不查询，使用时才查询\n​\tlazy=false：加载时立刻查询\n\n###### 关联级别查询\n\n**集合级别的关联**\n\nlazy属性:决定是否延迟加载：\n\n​\ttrue(默认):延迟加载，懒加载；\n\n​\tfalse：立即加载\n\n​\textra：及其懒惰（集合级别）\n\nfetch属性：决定加载策略，使用什么类型的SQL语句加载集合数据\n\n​\tselect(默认)：单表查询加载\n\n​\tjoin：使用多表查询加载集合\n\n​\tsubselect:使用子查询加载集合\n\n```\n<set name=\"\" lazy=\"\" fetch=\"\">\n\t<key volumn=\"lkm_cust_id></key>\n\t<one_to_many class=\"\"/>\n</set>\n```\n\n- fetch:select（单表查询） , lazy=true(使用时才加载集合数据)，该组合为默认\n- fetch:select（/单表查询） , lazy=false(立即加载集合数据）\n\n- fetch:select（/单表查询） , lazy=extra(与懒加载效果基本一致，但如果只获得集合的size，extra只获得集合的size：‘count语句’）\n\n- fetch:join , lazy=true/false/extra：多表查询立即加载集合，lazy属性失效\n\n- fetch:subselect，lazy=true:如果用不到子查询，效果相当于select，先单表查询，集合使用时才立即查询加载\n- fetch:subselect，lazy=false:立即查询加载相关集合数据\n\n- fetch:subselect，lazy=extra:先单表查询，集合使用时才立即查询加载，如果只获得集合的size，extra只获得集合的size：‘count语句’\n\n**属性级别的关联**\n\n根据被关联的对象获得主对象\n\n```\nLinkman lm = session.get(Linkman.class,2);\nCustomer c = lm.getCustomer();\nSystem.out.println(customer);\n```\n\n配置中属性：\n\n```\n<many-to-one name=\"Customer\" column=\"\" class=\"\" fetch=\"\" lazy=\">\n</many-to-one>\n```\n\nfetch属性：决定加载策略，使用什么类型的SQL语句加载数据\n\n​\tselect(默认)：单表查询加载\n\n​\tjoin：使用多表查询加载集合\n\nlazy属性:决定是否延迟加载：\n\n​\tfalse：立即加载\n\n​\tproxy：由主类的类级别策略决定\n\n- fetch:select,lazy=proxy(true),单表查询，懒加载\n- fetch:select,lazy=proxy(false，extra),多表立即加载\n- fetch:join,lazy属性失效,\n\n**结论**：为了提高效率，fetch的选择应选择select，lazy应选择true（默认）\n\n##### 批量抓取\n\n每次抓取几个集合：\n\n```\n<--每次抓取3个客户的集合-->\n<set name=\"\" batch-size=\"3\">\n\t<key volumn=\"lkm_cust_id></key>\n\t<one_to_many class=\"\"/>\n</set>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/hibernate.md","raw":"---\ntitle: javaEE-framework开篇——hibernate\ndate: 2019-04-18 14:05:48\ndescription: hibernate是我学习JavaEE framework的开始，分享学习的笔记给大家~\ntags:\n - hibernate\n - javaEE framework\ncategories: javaEE framework\n---\n\n​\thibernate是我学习JavaEE framework的开始，分享学习的笔记给大家~\n\n#### 搭建\n\n1）导包\n\n2）创建数据库\n\n3）书写Orm元数据(对象与表的映射配置文件)\n\n导入约束、实体、orm元数据\n\n4）书写主配置文件\n\nhibernate.cfg.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n\t\n<hibernate-configuration>\n\t<session-factory>\n\t\t<property name=\"hibernate.connection.dirver_class\">com.mysql.cj.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql:///hibernate?useSSL=false&amp;serverTimezone=GMT%2b8&amp;allowPublicKeyRetrieval=true</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">yue18800422369</property>\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQL5Dialect</property>\n\t\t\n\t\t<property name=\"hibernate.show_sql\">true</property>\n\t\t<property name=\"hibernate.format_sql\">true</property>\n\t\t\n\t\t<property name=\"hibernate.hbm2ddl.auto\">update</property>\n\t\t\n\t\t<mapping resource=\"domain/Customer.hbm.xml\"/>\n\t</session-factory>\n</hibernate-configuration>\n```\n\n5）书写代码测试\n\n映射文件:Customer.hbm.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC\n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n<!-- 配置表与实体对象的关系 -->\n<hibernate-mapping>\n\t<class name=\"domain.Customer\" table=\"cst_customer\">\n\t\t<id name=\"cust_id\" column=\"cust_id\">\n\t\t\t<generator class=\"native\"></generator>\n\t\t</id>\n\t\t<property name=\"cust_name\" column=\"cust_name\"></property>\n\t\t<property name=\"cust_source\" column=\"cust_source\"></property>\n\t\t<property name=\"cust_industry\" column=\"cust_industry\"></property>\n\t\t<property name=\"cust_level\" column=\"cust_level\"></property>\n\t\t<property name=\"cust_linkman\" column=\"cust_linkman\"></property>\n\t\t<property name=\"cust_phone\" column=\"cust_phone\"></property>\n\t\t<property name=\"cust_mobile\" column=\"cust_mobile\"></property>\n\t\n\t</class>\n</hibernate-mapping>\n```\n\n\n\n#### hibernateAPI详解\n\n##### configuration\n\n读取配置文件：主配置和orm元数据\n\n##### SessionFactory\n\n用于创建操作数据库核心对象session对象的工厂\n注：1、sessionFactory负责保存和使用所有配置信息，消耗内存资源非常大\n​\t2、sessionFactory属于线程安全的对象设计\n结论：保证在web项目中，只创建一个sessionFactory\n\n##### Session\n\n表达hibernate框架与数据库之间的连接（会话），类似于JDBC的connection对象，可实现数据库的增删改查\n\n##### Transaction\n\n封装了事务的操作：打开事务、提交事务、回滚事务\n\n```java\n//1、创建\n\t\tConfiguration conf = new Configuration().configure();\n\t\t//2、读取主配置文件,无参读取：hibernate.cfg.xml\n\t\tconf.configure();\n\t\t\n//\t\t//读取指定orm元数据(old)\n//\t\tconf.addResource(resourceName);\n//\t\tconf.addClass(persistentClass);\n\t\t//4、根据配置信息，创建sessionFactory对象\n\t\tSessionFactory sessionFactory = conf.buildSessionFactory();\n\t\n\t\t//5、获得session\n\t\tSession session = sessionFactory.openSession();\n\t\t//打开一个新的session对象\n\t\t//sessionFactory.openSession();\n\t\t//获得一个与线程绑定的session对象\n\t\t//sessionFactory.getCurrentSession();\n\t\t\n\t\t//6、session获得操作事务的Transaction对象\n\t\t//获得操作事务的tx对象\n\t\t//Transaction tx = session.getTransaction();\n\t\t//tx.begin();\n\t\t//开启事务并获得操作事务的tx对象（建议使用）\n\t\tTransaction tx2 = session.beginTransaction();\n\t\t\n\t\t//...................\n\t\t//增\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setCust_name(\"best\");\n\t\tsession.save(customer);\t\n\t\t//查询\n\t\tCustomer customer2 = session.get(Customer.class, 1l);\t\n\t\t//修改\n\t\tCustomer customer3  = session.get(Customer.class,1L);\n\t\tcustomer3.setCust_name(\"angle\");\n\t\tsession.update(customer3);\n\t\t//删除\n\t\tCustomer customer4 = session.get(Customer.class, 1l);\n\t\tsession.delete(customer4);\n\t\t//...............\n\t\t\n\t\ttx2.commit();\n\t\tsession.close();\n\t\tsessionFactory.close();\n\t\t\n```\n\n#### 实体规则\n\n##### 创建规则\n\n- 持久化类提供无参构造(通过反射创建对象)\n\n- 成员变量私有，需提供get/set（属性）\n\n- 持久化类中的属性，应尽量使用包装类型\n\n- 持久化类需要oid与数据库中的主键列对应\n- 不要用final修饰class（hibernate使用cglib代理生成代理对象，代理对象继承被代理对象，如果被final修饰，将无法代理）\n\n##### 主键类型\n\n###### 自然主键\n\n表的业务列中，其中必须有且不可重复的列可作为主键使用\n\n###### 代理主键\n\n表的业务列中，没有可作为主键的列，则创建一个没有业务的列作为主键\n\n##### 主键生成策略\n\n每条记录生成时，主键的生成规则（7个）\n\n- identity：主键自增，由数据库来维护主键值，录入时不需指定主键\n- sequence：Oracle中的主键生成策略\n- increment（了解）：主键自增，由hibernate来维护，每次插入前，会先查询表中id最大值，然后加1作为主键值（线程不安全）\n\n- hilo（了解）：高低位算法，由hibernate维护\n- native：hilo+sequence+identity，自动三选一\n- uuid： 产生随机字符串作为主串\n- assigned：自然主键生成，由用户录入生成\n\n#### hibernate的对象状态\n\n对象分为三种状态：\n\n- 瞬时状态：没有id，没有与session关联\n\n- 持久化状态：有id，与session关联\n\n  持久化状态的对象的任何变化都会自动同步到数据库中，不需要执行update方法\n\n- 游离/托管状态：有id，没有与session关联\n\n注：有id指的是有和数据库中对应的id\n\n状态转化：\n\n起点$\\rightarrow$瞬时（new）\n\n起点$\\rightarrow$持久化（get）\n\n瞬时 $\\rightarrow $持久化(save) $\\rightarrow $游离/托管状态(close)\n\n瞬时 $\\leftarrow $持久化(delete) $\\leftarrow $游离/托管状态(update)\n\nsaveOrUpdate:将所有对象转化为持久化状态\n\n（持久化对象就是放入session缓存的对象）\n\n#### hibernate的进阶--缓存\n\n提高效率的方式：\n\n- 提高查询效率（缓冲区）\n- 减少不必要的修改语句发送（利用快照）\n\n#### 事务\n\n- 性质：\n\n  - 原子性\n\n  - 一致性：数据在提交前和提交后总量保持一致\n\n  - 隔离性\n\n  - 持久性：数据提交之后必须要被持久化保存\n\n- 并发问题：\n\n  - 脏读：读取到了正在操作并未保存的数据；B事务读取了A事务没有提交的数据\n\n  - 不可重复读：在一个事务中，两次读取的事务不一致\n\n  - 幻/虚读：一般针对整表的操作；一个事务中，两次读取的数据的数量不一致\n\n- 事务的隔离级别：\n\n  - 读未提交 1*：脏读、不可重复读、幻读（可产生问题）\n\n  - 读已提交 2*：不可重复读、幻读\n\n  - 可重复读 4*（MySQL默认级别）：幻读\n\n  - 串行化 8*\n\n- 在hibernate指定隔离级别：1 2 4 8\n\n- 在项目中管理项目\n\n  dao层数据操作和service层控制事务都需要session对象，要确保使用的是同一个session对象：\n\n  1）在hibernate中调用getCurrentSession方法获得与线程绑定的session对象，调用该方法时，必须在主配置中主配置中说明：\n\n  ```xml\n  <property name=\"hibernate.current_session_context_class\">thread</property>\n  ```\n\n  2）通过getCurrentSession方法获得session对象，当事务提交时session会自动关闭，不许手动。\n\n#### 批量查询\n\n##### HQL查询\n\n多表查询，但不复杂时使用\n\nhibernate独家查询语言，面向对象\n\n```javascript\n//1、书写HQL语句\n\t\t//String hql = \"from 对象的完整类名\";\n\t\t//String hql = \"from Customer where cust_id = 1\";//cust_id是属性\n\t\t//String hql = \"from Customer\";//查询所有Customer对象\n\t\t//String hql = \"from Customer where cust_id = ?\";//问号占位符\n\t\tString hql = \"from Customer where cust_id ：id\";\n\t\t\n\t\t//2、根据HQL语句创建查询对象\n\t\tQuery<Customer> query = session.createQuery(hql);\n\t\t\n\t\t//分页查询\n\t\t//设置分页信息\n\t\tquery.setFirstResult(0);//第0条开始查询\n\t\tquery.setMaxResults(2);//最多查询两条\n\t\t\n\t\t//设置参数(占位符）\n\t\tquery.setLong(0, 1);//问号占位符\n\t\tquery.setParameter(0, 1);//类型通用\n\t\tquery.setParameter(\"id\", 1);//命名占位符\n\t\t//3、根据查询对象获得查询结果\n\t\tList list = (List) query.list();\n\t\t//query.uniqueResult();//接收唯一的查询对象\n```\n\n##### Criteria查询\n\n单表查询\n\nhibernate自创的无语句面向对象查询\n\n```\n\t//Criteria查询\n\t//查询所有Customer对象\n\tCriteria criteria = session.createCriteria(Customer.class);\n\t//普通查询\n\tList<Customer> list2  = criteria.list();\n\t//条件查询\n\tcriteria.add(Restrictions.eq(\"cust_id\",1));\n\t//criteria.add(Restrictions.IdEq(1));\n\tCustomer c = (Customer) criteria.uniqueResult();\n\t//分页\n\tcriteria.setFirstResult(1);\n\tcriteria.setMaxResults(1);\n\t//查询总记录\n\t//设置查询的聚合函数=》总行数\n\tcriteria.setProjection(Projections.rowCount());\n\tLong count = (Long) criteria.uniqueResult();\n```\n\n常见查询条件:\n\n| >    | gt   | between and | between   |\n| ---- | ---- | ----------- | --------- |\n| >=   | lt   | like        | like      |\n| <    | lt   | is not null | isNotNull |\n| <=   | le   | is null     | isNull    |\n| ==   | eq   | or          | or        |\n| !=   | in   | and         | and       |\n\n##### 原生SQL查询\n\n复杂的业务查询\n\n```javascript\n\t//原生SQL查询\n\t\t//String sql = \"select * from cst_customer\";\n\t\t//条件查询与分页\n\t\tString sqlString  = \"select * from csy_customer limit ?,?\";\n\t\t\n\t\tSQLQuery<Object[]> query2 = session.createSQLQuery(sql);\n\t\t\n\t\tquery2.setParameter(0, 0);\n\t\tquery2.setParameter(1, 1);\n\t\t\n\t\t//查询到的每行结果放到一个object数组\n\t\t//List<Object[]> list3 = query2.list();\n\t\t\n\t\t//封装结果\n\t\tquery2.addEntity(Customer.class);\n\t\tList<Customer> list3 = query2.list();\n```\n\n#### 多对多关系\n\n##### 一对多、多对一\n\n###### 关系的表达\n\n```\n<!-- 集合，一对多关系的配置 -->\n\t\t<!--\n\t\t name:集合属性名\n\t\t column:外键列名\n\t\t class：关联的对象的完整类名\n\t\t -->\n\t\t<set name=\"LinkMen\" cascade：save-update>\n\t\t\t<key column=\"lkm_cust_id\"></key>\n\t\t\t<one-to-many class=\"LinkMan\"/>\n\t\t</set>\n\t\t\n\t\t<!-- 多对一的配置 -->\n\t\t<many-to-one name=\"customer\" column=\"lkm_cust_id\" class=\"Customer\"></many-to-one>\n\t\t\n```\n\n###### 操作\n\n```\n\t//保存客户以及客户下的联系人\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setCust_name(\"blog\");\n\t\t\n\t\tLinkMan lMan1 = new LinkMan();\n\t\tlMan1.setLkm_name(\"man1\");\n\t\tLinkMan lMan2 = new LinkMan();\n\t\tlMan2.setLkm_name(\"man2\");\n\t\tLinkMan lMan3 = new LinkMan();\n\t\tlMan3.setLkm_name(\"man3\");\n\t\t//表达一对多，一个客户有多个联系人\n\t\tcustomer.getLinkmen().add(lMan1);\n\t\tcustomer.getLinkmen().add(lMan2);\n\t\t//表达多对一，联系人属于哪个客户\n\t\tlMan1.setCustomer(customer);\n\t\tlMan2.setCustomer(customer);\n\t\t\n\t\tsession.save(customer);\n\t\tsession.save(lMan1);\n\t\tsession.save(lMan2);\n```\n\n###### 进阶\n\n**联操作**\n\ncascade（配置文件配置）\n\n​\tsave-update:级联保存更新\n\n​\tdelete：级联删除\n\n​\tall：save-update+delete\n\n**关系维护**\n\n在保存时，两方都会维护关系，冗余\n\ninverse属性：配置关系是否维护，默认是false(维护），但是多的一方不能放弃维护\n\n##### 多对多\n\n配置\n\n```\n<set name=\"set集合名\" table=\"中间表名\">\n\n\t<key column=\"对方引用的自己的外键名>\"\n\n\t<many-to-many class=\"与哪个别的类多对多\" column=\"引用的别人的外键\">\n\n</set>\n```\n\n注：开发中利用inverse属性，根据业务方向选择一方放弃维护关系\n\n**小结**\n\n**一对多/多对一**\n\n- O：对象  \n\n    一的一方使用集合，多的一方直接引用一的一方\n\n- R：关系型数据库      \n\n  多的一方使用外键引用一的一方主键\n\n- M：映射文件  \n\n  ```\n  一：<set name=\"\">\n  \n  \t\t<key column = \"\"/>\n  \n  \t\t<one-to-many name=\"\" column=\"\" class=\"\"/>\n  \n  \t</set>\n  \n  多：<many-to-one name=\"\" column=\"\" class=\"\"/>\n  ```\n\n  关系操作：级别属性\n\n  进阶：\n\n  ​\tinverse：反转关系维护,性能优化（true：放弃，默认false维护），一对多中，一的一方可放弃维护关系\n\n  ​\tcasecade：级联操作，减少代码（nono(默认)：不级联save-update、delete、all)\n\n**多对多**\n\n- O：对象\n\n  两方都使用集合\n\n- R：使用中间表，至少两列，作为外键引用两张表的主键\n\n- M：映射文件\n\n```\n多：\n<set name=\"\" table=\"中间表名\">\n\t<key column=\"别人引用的自己的外键\">\n\t<many-to-many class=\"\" column=\"引用别人的外键名\"/>\n</set>\t\n```\n\n操作：操作管理级别属性\n\n- casede:级联属性，减少代码书写\n\n​\tnono(默认)：不级联\n\n​\tsave-update、delete、all\n\n- inverse:反转关系维护，属于性能优化，必须根据业务关系选择一方放弃维护主键关系\n\n##### 检索\n\n###### 查询小结\n\noid查询-get\n\n对象属性导航查询\n\nHQL\n\nCriteria\n\n原生SQL\n\n###### HQL查询\n\n**基本语法**\n\n```\nString hql = “from java.lang.Object\"//查询所有Object及其子类\n```\n\n**排序语法**\n\n```\nString hql = \"from Customer order by id asc\"//asc：升序\n\nString hql = \"from Customer order by id desc，xxxx  desc/asc\n\n\"//desc：降序,如果相同，可根据别的列按照desc/asc再排序\n```\n\n**条件查询**\n\n```\nString hql = \"from Customer where id =？\"\n\nString hql = \"from Customer where id: id\"\n```\n\n**分页查询**\n\n```\nString hql = \"from con.itcast.domain.Customer\";\n\nquery query = session.creatQuery(hql);\n\n//limit ?， ?\n\nquery.setFirstResult(0);//从第0条开始查询\n\nquery.setFirstResult(2);//每页查询两条\n```\n\n**统计查询**\n\n聚合函数：count（计数）、sum(求和）、avg（平均数）、max、min\n\n```\nString hql = \"select count(*) from Customer\"//总记录数 \n//String hq2 = \"select sum(id) from Customer\"\n//String hql = \"select avg(id) from Customer\"\n//String hql = \"select max(id) from Customer\"\n//String hql = \"select min(id) from Customer\"\nQuery query = session.creatQuery(hql);\n\nNumber number = (Number) query.uniqueResult();\n```\n\n**投影查询**\n\n```\nString hql = \"select cust_name from Customer\"//查询name\nString hql = \"select cust_name,cust_id from Customer\";//查询name和id两列，返回数组\nString hql = \"select newCustomer(cust_name,cust_id) from Customer\";//将查询的每个name和id封装到对应Customer对象中\n//注：必须在Customerclass类中添加参数为name和id的构造方法以及无参构造方法\n```\n\n**多表查询**\n\n- 原生SQL：\n\n  交叉连接：笛卡尔积selecte * from A,B\n\n  内连接：\n\n  ​\t隐式内连接：selecte * from A,B where 条件\n\n  ​\t显式外连接：selecte * from A inner join B on  条件\n\n  外连接：\n\n  ​\t左外连接：selecte * from A left [outer] join B on 条件\n\n  ​\t右外连接:selecte * from A right [outer] join B on 条件\n\n- HQL查询：\n\n  - 内连接：\n\n  ​\tString hql = \"from Customer c inner join c.LinkMen\";//将对应的两个对象分别封装到数组\n\n  ​\t迫切：String hql = \"from Customer c inner join fetch c.LinkMen\";//把第二个表的东西封装到第一个对象中\n\n  - 左外连接：String hql = \"from Customer c left join c.LinkMen\"\n\n  - 右外连接：String hql = \"from Customer c right join c.LinkMen\"\n\n###### Criterla查询（QBC）\n\n**基本**\n\n```\n//Criteria查询\n\t//查询所有Customer对象\n\tCriteria criteria = session.createCriteria(Customer.class);\n\t\n\t//普通查询\n\tList<Customer> list2  = criteria.list();\n\t\n\t//条件查询\n\tcriteria.add(Restrictions.eq(\"cust_id\",1));\n\t//criteria.add(Restrictions.IdEq(1));\n\tCustomer c = (Customer) criteria.uniqueResult();\n\t\n\t//分页\n\tcriteria.setFirstResult(1);\n\tcriteria.setMaxResults(1);\n\t\n\t//查询总记录\n\t//设置查询的聚合函数=》总行数\n\tcriteria.setProjection(Projections.rowCount());\n\tLong count = (Long) criteria.uniqueResult();\n```\n\n**条件**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\ncriteria.add(Restrictions.eq(\"cust_id\",1));\n//criteria.add(Restrictions.IdEq(1));\nCustomer c = (Customer) criteria.uniqueResult();\n```\n\n**分页**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\nc.setFirstResult(0);\nc.setMaxResult(2);\nList<Customer> list = c.list;\n```\n\n**排序**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\nc.addOrder(Order.asc(\"cust_id\"));\nList<Customer> list = c.list;\n```\n\n**统计**\n\n```\nCriteria c = session.creatCriteria(Customer.class);\nc.setProject(Projections.rowCount());\nList<Long> list = c.list;\n```\n\n**离线查询**\n\n传统的criteria依赖于session创建（dao层）\n\n离线的criteria，可脱离session，在任意层均可凭空创建（扩大session的作用范围）\n\n```\n//web或service层\nDetachedCriteria dc = DetachedCriteria.forClass(Customer.class);\ndc.add(Restrictions.idEq(61));//拼装条件与普通一致\n\n\n//dao层\nCriteria c = dc.getExecutableCriteria(session)\nList list = c.list();\n```\n\n##### 查询优化\n\n###### 类级别查询\n\n懒加载|延迟加载\n\nget:立即加载，执行方法时立即发送SQL语句查询结果\n\nload(默认)：结果和get一样，执行时，不发送任何SQL语句，返回一个对象，使用该对象时，才执行查询\n\n延时加载：仅仅获得不使用，不会查询，使用时才进行查询，（针对load方法），原理是动态代理\n是否对类进行延迟加载，可通过在class元素上配置lazy属性控制：\n​\tlazy=true：加载时，不查询，使用时才查询\n​\tlazy=false：加载时立刻查询\n\n###### 关联级别查询\n\n**集合级别的关联**\n\nlazy属性:决定是否延迟加载：\n\n​\ttrue(默认):延迟加载，懒加载；\n\n​\tfalse：立即加载\n\n​\textra：及其懒惰（集合级别）\n\nfetch属性：决定加载策略，使用什么类型的SQL语句加载集合数据\n\n​\tselect(默认)：单表查询加载\n\n​\tjoin：使用多表查询加载集合\n\n​\tsubselect:使用子查询加载集合\n\n```\n<set name=\"\" lazy=\"\" fetch=\"\">\n\t<key volumn=\"lkm_cust_id></key>\n\t<one_to_many class=\"\"/>\n</set>\n```\n\n- fetch:select（单表查询） , lazy=true(使用时才加载集合数据)，该组合为默认\n- fetch:select（/单表查询） , lazy=false(立即加载集合数据）\n\n- fetch:select（/单表查询） , lazy=extra(与懒加载效果基本一致，但如果只获得集合的size，extra只获得集合的size：‘count语句’）\n\n- fetch:join , lazy=true/false/extra：多表查询立即加载集合，lazy属性失效\n\n- fetch:subselect，lazy=true:如果用不到子查询，效果相当于select，先单表查询，集合使用时才立即查询加载\n- fetch:subselect，lazy=false:立即查询加载相关集合数据\n\n- fetch:subselect，lazy=extra:先单表查询，集合使用时才立即查询加载，如果只获得集合的size，extra只获得集合的size：‘count语句’\n\n**属性级别的关联**\n\n根据被关联的对象获得主对象\n\n```\nLinkman lm = session.get(Linkman.class,2);\nCustomer c = lm.getCustomer();\nSystem.out.println(customer);\n```\n\n配置中属性：\n\n```\n<many-to-one name=\"Customer\" column=\"\" class=\"\" fetch=\"\" lazy=\">\n</many-to-one>\n```\n\nfetch属性：决定加载策略，使用什么类型的SQL语句加载数据\n\n​\tselect(默认)：单表查询加载\n\n​\tjoin：使用多表查询加载集合\n\nlazy属性:决定是否延迟加载：\n\n​\tfalse：立即加载\n\n​\tproxy：由主类的类级别策略决定\n\n- fetch:select,lazy=proxy(true),单表查询，懒加载\n- fetch:select,lazy=proxy(false，extra),多表立即加载\n- fetch:join,lazy属性失效,\n\n**结论**：为了提高效率，fetch的选择应选择select，lazy应选择true（默认）\n\n##### 批量抓取\n\n每次抓取几个集合：\n\n```\n<--每次抓取3个客户的集合-->\n<set name=\"\" batch-size=\"3\">\n\t<key volumn=\"lkm_cust_id></key>\n\t<one_to_many class=\"\"/>\n</set>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"hibernate","published":1,"updated":"2019-04-18T06:58:04.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvrtri52000otku3527ansj7","content":"<p>​    hibernate是我学习JavaEE framework的开始，分享学习的笔记给大家~</p>\n<h4 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h4><p>1）导包</p>\n<p>2）创建数据库</p>\n<p>3）书写Orm元数据(对象与表的映射配置文件)</p>\n<p>导入约束、实体、orm元数据</p>\n<p>4）书写主配置文件</p>\n<p>hibernate.cfg.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class=\"line\"><span class=\"meta\">\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.dirver_class\"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql:///hibernate?useSSL=false&amp;amp;serverTimezone=GMT%2b8&amp;amp;allowPublicKeyRetrieval=true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.password\"</span>&gt;</span>yue18800422369<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.format_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.hbm2ddl.auto\"</span>&gt;</span>update<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mapping</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"domain/Customer.hbm.xml\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>5）书写代码测试</p>\n<p>映射文件:Customer.hbm.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class=\"line\"><span class=\"meta\">\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置表与实体对象的关系 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">class</span> <span class=\"attr\">name</span>=<span class=\"string\">\"domain.Customer\"</span> <span class=\"attr\">table</span>=<span class=\"string\">\"cst_customer\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_id\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_id\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">generator</span> <span class=\"attr\">class</span>=<span class=\"string\">\"native\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">generator</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_name\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_source\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_source\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_industry\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_industry\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_level\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_level\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_linkman\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_linkman\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_phone\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_phone\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_mobile\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_mobile\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"hibernateAPI详解\"><a href=\"#hibernateAPI详解\" class=\"headerlink\" title=\"hibernateAPI详解\"></a>hibernateAPI详解</h4><h5 id=\"configuration\"><a href=\"#configuration\" class=\"headerlink\" title=\"configuration\"></a>configuration</h5><p>读取配置文件：主配置和orm元数据</p>\n<h5 id=\"SessionFactory\"><a href=\"#SessionFactory\" class=\"headerlink\" title=\"SessionFactory\"></a>SessionFactory</h5><p>用于创建操作数据库核心对象session对象的工厂<br>注：1、sessionFactory负责保存和使用所有配置信息，消耗内存资源非常大<br>​    2、sessionFactory属于线程安全的对象设计<br>结论：保证在web项目中，只创建一个sessionFactory</p>\n<h5 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h5><p>表达hibernate框架与数据库之间的连接（会话），类似于JDBC的connection对象，可实现数据库的增删改查</p>\n<h5 id=\"Transaction\"><a href=\"#Transaction\" class=\"headerlink\" title=\"Transaction\"></a>Transaction</h5><p>封装了事务的操作：打开事务、提交事务、回滚事务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、创建</span></span><br><span class=\"line\">\t\tConfiguration conf = <span class=\"keyword\">new</span> Configuration().configure();</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、读取主配置文件,无参读取：hibernate.cfg.xml</span></span><br><span class=\"line\">\t\tconf.configure();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">//\t\t//读取指定orm元数据(old)</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tconf.addResource(resourceName);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tconf.addClass(persistentClass);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//4、根据配置信息，创建sessionFactory对象</span></span><br><span class=\"line\">\t\tSessionFactory sessionFactory = conf.buildSessionFactory();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//5、获得session</span></span><br><span class=\"line\">\t\tSession session = sessionFactory.openSession();</span><br><span class=\"line\">\t\t<span class=\"comment\">//打开一个新的session对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//sessionFactory.openSession();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//获得一个与线程绑定的session对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//sessionFactory.getCurrentSession();</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//6、session获得操作事务的Transaction对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//获得操作事务的tx对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Transaction tx = session.getTransaction();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//tx.begin();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//开启事务并获得操作事务的tx对象（建议使用）</span></span><br><span class=\"line\">\t\tTransaction tx2 = session.beginTransaction();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//...................</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//增</span></span><br><span class=\"line\">\t\tCustomer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t\tcustomer.setCust_name(<span class=\"string\">\"best\"</span>);</span><br><span class=\"line\">\t\tsession.save(customer);\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//查询</span></span><br><span class=\"line\">\t\tCustomer customer2 = session.get(Customer.class, <span class=\"number\">1l</span>);\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//修改</span></span><br><span class=\"line\">\t\tCustomer customer3  = session.get(Customer.class,<span class=\"number\">1L</span>);</span><br><span class=\"line\">\t\tcustomer3.setCust_name(<span class=\"string\">\"angle\"</span>);</span><br><span class=\"line\">\t\tsession.update(customer3);</span><br><span class=\"line\">\t\t<span class=\"comment\">//删除</span></span><br><span class=\"line\">\t\tCustomer customer4 = session.get(Customer.class, <span class=\"number\">1l</span>);</span><br><span class=\"line\">\t\tsession.delete(customer4);</span><br><span class=\"line\">\t\t<span class=\"comment\">//...............</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttx2.commit();</span><br><span class=\"line\">\t\tsession.close();</span><br><span class=\"line\">\t\tsessionFactory.close();</span><br></pre></td></tr></table></figure>\n<h4 id=\"实体规则\"><a href=\"#实体规则\" class=\"headerlink\" title=\"实体规则\"></a>实体规则</h4><h5 id=\"创建规则\"><a href=\"#创建规则\" class=\"headerlink\" title=\"创建规则\"></a>创建规则</h5><ul>\n<li><p>持久化类提供无参构造(通过反射创建对象)</p>\n</li>\n<li><p>成员变量私有，需提供get/set（属性）</p>\n</li>\n<li><p>持久化类中的属性，应尽量使用包装类型</p>\n</li>\n<li><p>持久化类需要oid与数据库中的主键列对应</p>\n</li>\n<li>不要用final修饰class（hibernate使用cglib代理生成代理对象，代理对象继承被代理对象，如果被final修饰，将无法代理）</li>\n</ul>\n<h5 id=\"主键类型\"><a href=\"#主键类型\" class=\"headerlink\" title=\"主键类型\"></a>主键类型</h5><h6 id=\"自然主键\"><a href=\"#自然主键\" class=\"headerlink\" title=\"自然主键\"></a>自然主键</h6><p>表的业务列中，其中必须有且不可重复的列可作为主键使用</p>\n<h6 id=\"代理主键\"><a href=\"#代理主键\" class=\"headerlink\" title=\"代理主键\"></a>代理主键</h6><p>表的业务列中，没有可作为主键的列，则创建一个没有业务的列作为主键</p>\n<h5 id=\"主键生成策略\"><a href=\"#主键生成策略\" class=\"headerlink\" title=\"主键生成策略\"></a>主键生成策略</h5><p>每条记录生成时，主键的生成规则（7个）</p>\n<ul>\n<li>identity：主键自增，由数据库来维护主键值，录入时不需指定主键</li>\n<li>sequence：Oracle中的主键生成策略</li>\n<li><p>increment（了解）：主键自增，由hibernate来维护，每次插入前，会先查询表中id最大值，然后加1作为主键值（线程不安全）</p>\n</li>\n<li><p>hilo（了解）：高低位算法，由hibernate维护</p>\n</li>\n<li>native：hilo+sequence+identity，自动三选一</li>\n<li>uuid： 产生随机字符串作为主串</li>\n<li>assigned：自然主键生成，由用户录入生成</li>\n</ul>\n<h4 id=\"hibernate的对象状态\"><a href=\"#hibernate的对象状态\" class=\"headerlink\" title=\"hibernate的对象状态\"></a>hibernate的对象状态</h4><p>对象分为三种状态：</p>\n<ul>\n<li><p>瞬时状态：没有id，没有与session关联</p>\n</li>\n<li><p>持久化状态：有id，与session关联</p>\n<p>持久化状态的对象的任何变化都会自动同步到数据库中，不需要执行update方法</p>\n</li>\n<li><p>游离/托管状态：有id，没有与session关联</p>\n</li>\n</ul>\n<p>注：有id指的是有和数据库中对应的id</p>\n<p>状态转化：</p>\n<p>起点$\\rightarrow$瞬时（new）</p>\n<p>起点$\\rightarrow$持久化（get）</p>\n<p>瞬时 $\\rightarrow $持久化(save) $\\rightarrow $游离/托管状态(close)</p>\n<p>瞬时 $\\leftarrow $持久化(delete) $\\leftarrow $游离/托管状态(update)</p>\n<p>saveOrUpdate:将所有对象转化为持久化状态</p>\n<p>（持久化对象就是放入session缓存的对象）</p>\n<h4 id=\"hibernate的进阶–缓存\"><a href=\"#hibernate的进阶–缓存\" class=\"headerlink\" title=\"hibernate的进阶–缓存\"></a>hibernate的进阶–缓存</h4><p>提高效率的方式：</p>\n<ul>\n<li>提高查询效率（缓冲区）</li>\n<li>减少不必要的修改语句发送（利用快照）</li>\n</ul>\n<h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><ul>\n<li><p>性质：</p>\n<ul>\n<li><p>原子性</p>\n</li>\n<li><p>一致性：数据在提交前和提交后总量保持一致</p>\n</li>\n<li><p>隔离性</p>\n</li>\n<li><p>持久性：数据提交之后必须要被持久化保存</p>\n</li>\n</ul>\n</li>\n<li><p>并发问题：</p>\n<ul>\n<li><p>脏读：读取到了正在操作并未保存的数据；B事务读取了A事务没有提交的数据</p>\n</li>\n<li><p>不可重复读：在一个事务中，两次读取的事务不一致</p>\n</li>\n<li><p>幻/虚读：一般针对整表的操作；一个事务中，两次读取的数据的数量不一致</p>\n</li>\n</ul>\n</li>\n<li><p>事务的隔离级别：</p>\n<ul>\n<li><p>读未提交 1*：脏读、不可重复读、幻读（可产生问题）</p>\n</li>\n<li><p>读已提交 2*：不可重复读、幻读</p>\n</li>\n<li><p>可重复读 4*（MySQL默认级别）：幻读</p>\n</li>\n<li><p>串行化 8*</p>\n</li>\n</ul>\n</li>\n<li><p>在hibernate指定隔离级别：1 2 4 8</p>\n</li>\n<li><p>在项目中管理项目</p>\n<p>dao层数据操作和service层控制事务都需要session对象，要确保使用的是同一个session对象：</p>\n<p>1）在hibernate中调用getCurrentSession方法获得与线程绑定的session对象，调用该方法时，必须在主配置中主配置中说明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.current_session_context_class\"</span>&gt;</span>thread<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2）通过getCurrentSession方法获得session对象，当事务提交时session会自动关闭，不许手动。</p>\n</li>\n</ul>\n<h4 id=\"批量查询\"><a href=\"#批量查询\" class=\"headerlink\" title=\"批量查询\"></a>批量查询</h4><h5 id=\"HQL查询\"><a href=\"#HQL查询\" class=\"headerlink\" title=\"HQL查询\"></a>HQL查询</h5><p>多表查询，但不复杂时使用</p>\n<p>hibernate独家查询语言，面向对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、书写HQL语句</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from 对象的完整类名\";</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from Customer where cust_id = 1\";//cust_id是属性</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from Customer\";//查询所有Customer对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from Customer where cust_id = ?\";//问号占位符</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">String</span> hql = <span class=\"string\">\"from Customer where cust_id ：id\"</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、根据HQL语句创建查询对象</span></span><br><span class=\"line\">\t\tQuery&lt;Customer&gt; query = session.createQuery(hql);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//分页查询</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//设置分页信息</span></span><br><span class=\"line\">\t\tquery.setFirstResult(<span class=\"number\">0</span>);<span class=\"comment\">//第0条开始查询</span></span><br><span class=\"line\">\t\tquery.setMaxResults(<span class=\"number\">2</span>);<span class=\"comment\">//最多查询两条</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置参数(占位符）</span></span><br><span class=\"line\">\t\tquery.setLong(<span class=\"number\">0</span>, <span class=\"number\">1</span>);<span class=\"comment\">//问号占位符</span></span><br><span class=\"line\">\t\tquery.setParameter(<span class=\"number\">0</span>, <span class=\"number\">1</span>);<span class=\"comment\">//类型通用</span></span><br><span class=\"line\">\t\tquery.setParameter(<span class=\"string\">\"id\"</span>, <span class=\"number\">1</span>);<span class=\"comment\">//命名占位符</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//3、根据查询对象获得查询结果</span></span><br><span class=\"line\">\t\tList list = (List) query.list();</span><br><span class=\"line\">\t\t<span class=\"comment\">//query.uniqueResult();//接收唯一的查询对象</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Criteria查询\"><a href=\"#Criteria查询\" class=\"headerlink\" title=\"Criteria查询\"></a>Criteria查询</h5><p>单表查询</p>\n<p>hibernate自创的无语句面向对象查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Criteria查询</span><br><span class=\"line\">//查询所有Customer对象</span><br><span class=\"line\">Criteria criteria = session.createCriteria(Customer.class);</span><br><span class=\"line\">//普通查询</span><br><span class=\"line\">List&lt;Customer&gt; list2  = criteria.list();</span><br><span class=\"line\">//条件查询</span><br><span class=\"line\">criteria.add(Restrictions.eq(&quot;cust_id&quot;,1));</span><br><span class=\"line\">//criteria.add(Restrictions.IdEq(1));</span><br><span class=\"line\">Customer c = (Customer) criteria.uniqueResult();</span><br><span class=\"line\">//分页</span><br><span class=\"line\">criteria.setFirstResult(1);</span><br><span class=\"line\">criteria.setMaxResults(1);</span><br><span class=\"line\">//查询总记录</span><br><span class=\"line\">//设置查询的聚合函数=》总行数</span><br><span class=\"line\">criteria.setProjection(Projections.rowCount());</span><br><span class=\"line\">Long count = (Long) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p>常见查询条件:</p>\n<table>\n<thead>\n<tr>\n<th>&gt;</th>\n<th>gt</th>\n<th>between and</th>\n<th>between</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;=</td>\n<td>lt</td>\n<td>like</td>\n<td>like</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>lt</td>\n<td>is not null</td>\n<td>isNotNull</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>le</td>\n<td>is null</td>\n<td>isNull</td>\n</tr>\n<tr>\n<td>==</td>\n<td>eq</td>\n<td>or</td>\n<td>or</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>in</td>\n<td>and</td>\n<td>and</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"原生SQL查询\"><a href=\"#原生SQL查询\" class=\"headerlink\" title=\"原生SQL查询\"></a>原生SQL查询</h5><p>复杂的业务查询</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原生SQL查询</span></span><br><span class=\"line\">\t<span class=\"comment\">//String sql = \"select * from cst_customer\";</span></span><br><span class=\"line\">\t<span class=\"comment\">//条件查询与分页</span></span><br><span class=\"line\">\t<span class=\"built_in\">String</span> sqlString  = <span class=\"string\">\"select * from csy_customer limit ?,?\"</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tSQLQuery&lt;<span class=\"built_in\">Object</span>[]&gt; query2 = session.createSQLQuery(sql);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tquery2.setParameter(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tquery2.setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//查询到的每行结果放到一个object数组</span></span><br><span class=\"line\">\t<span class=\"comment\">//List&lt;Object[]&gt; list3 = query2.list();</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//封装结果</span></span><br><span class=\"line\">\tquery2.addEntity(Customer.class);</span><br><span class=\"line\">\tList&lt;Customer&gt; list3 = query2.list();</span><br></pre></td></tr></table></figure>\n<h4 id=\"多对多关系\"><a href=\"#多对多关系\" class=\"headerlink\" title=\"多对多关系\"></a>多对多关系</h4><h5 id=\"一对多、多对一\"><a href=\"#一对多、多对一\" class=\"headerlink\" title=\"一对多、多对一\"></a>一对多、多对一</h5><h6 id=\"关系的表达\"><a href=\"#关系的表达\" class=\"headerlink\" title=\"关系的表达\"></a>关系的表达</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 集合，一对多关系的配置 --&gt;</span><br><span class=\"line\">\t\t&lt;!--</span><br><span class=\"line\">\t\t name:集合属性名</span><br><span class=\"line\">\t\t column:外键列名</span><br><span class=\"line\">\t\t class：关联的对象的完整类名</span><br><span class=\"line\">\t\t --&gt;</span><br><span class=\"line\">\t\t&lt;set name=&quot;LinkMen&quot; cascade：save-update&gt;</span><br><span class=\"line\">\t\t\t&lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt;</span><br><span class=\"line\">\t\t\t&lt;one-to-many class=&quot;LinkMan&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;/set&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;!-- 多对一的配置 --&gt;</span><br><span class=\"line\">\t\t&lt;many-to-one name=&quot;customer&quot; column=&quot;lkm_cust_id&quot; class=&quot;Customer&quot;&gt;&lt;/many-to-one&gt;</span><br></pre></td></tr></table></figure>\n<h6 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//保存客户以及客户下的联系人</span><br><span class=\"line\">\tCustomer customer = new Customer();</span><br><span class=\"line\">\tcustomer.setCust_name(&quot;blog&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tLinkMan lMan1 = new LinkMan();</span><br><span class=\"line\">\tlMan1.setLkm_name(&quot;man1&quot;);</span><br><span class=\"line\">\tLinkMan lMan2 = new LinkMan();</span><br><span class=\"line\">\tlMan2.setLkm_name(&quot;man2&quot;);</span><br><span class=\"line\">\tLinkMan lMan3 = new LinkMan();</span><br><span class=\"line\">\tlMan3.setLkm_name(&quot;man3&quot;);</span><br><span class=\"line\">\t//表达一对多，一个客户有多个联系人</span><br><span class=\"line\">\tcustomer.getLinkmen().add(lMan1);</span><br><span class=\"line\">\tcustomer.getLinkmen().add(lMan2);</span><br><span class=\"line\">\t//表达多对一，联系人属于哪个客户</span><br><span class=\"line\">\tlMan1.setCustomer(customer);</span><br><span class=\"line\">\tlMan2.setCustomer(customer);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsession.save(customer);</span><br><span class=\"line\">\tsession.save(lMan1);</span><br><span class=\"line\">\tsession.save(lMan2);</span><br></pre></td></tr></table></figure>\n<h6 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h6><p><strong>联操作</strong></p>\n<p>cascade（配置文件配置）</p>\n<p>​    save-update:级联保存更新</p>\n<p>​    delete：级联删除</p>\n<p>​    all：save-update+delete</p>\n<p><strong>关系维护</strong></p>\n<p>在保存时，两方都会维护关系，冗余</p>\n<p>inverse属性：配置关系是否维护，默认是false(维护），但是多的一方不能放弃维护</p>\n<h5 id=\"多对多\"><a href=\"#多对多\" class=\"headerlink\" title=\"多对多\"></a>多对多</h5><p>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;set name=&quot;set集合名&quot; table=&quot;中间表名&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;key column=&quot;对方引用的自己的外键名&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;many-to-many class=&quot;与哪个别的类多对多&quot; column=&quot;引用的别人的外键&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<p>注：开发中利用inverse属性，根据业务方向选择一方放弃维护关系</p>\n<p><strong>小结</strong></p>\n<p><strong>一对多/多对一</strong></p>\n<ul>\n<li><p>O：对象  </p>\n<p>  一的一方使用集合，多的一方直接引用一的一方</p>\n</li>\n<li><p>R：关系型数据库      </p>\n<p>多的一方使用外键引用一的一方主键</p>\n</li>\n<li><p>M：映射文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一：&lt;set name=&quot;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;key column = &quot;&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;one-to-many name=&quot;&quot; column=&quot;&quot; class=&quot;&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;/set&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">多：&lt;many-to-one name=&quot;&quot; column=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>关系操作：级别属性</p>\n<p>进阶：</p>\n<p>​    inverse：反转关系维护,性能优化（true：放弃，默认false维护），一对多中，一的一方可放弃维护关系</p>\n<p>​    casecade：级联操作，减少代码（nono(默认)：不级联save-update、delete、all)</p>\n</li>\n</ul>\n<p><strong>多对多</strong></p>\n<ul>\n<li><p>O：对象</p>\n<p>两方都使用集合</p>\n</li>\n<li><p>R：使用中间表，至少两列，作为外键引用两张表的主键</p>\n</li>\n<li><p>M：映射文件</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多：</span><br><span class=\"line\">&lt;set name=&quot;&quot; table=&quot;中间表名&quot;&gt;</span><br><span class=\"line\">\t&lt;key column=&quot;别人引用的自己的外键&quot;&gt;</span><br><span class=\"line\">\t&lt;many-to-many class=&quot;&quot; column=&quot;引用别人的外键名&quot;/&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<p>操作：操作管理级别属性</p>\n<ul>\n<li>casede:级联属性，减少代码书写</li>\n</ul>\n<p>​    nono(默认)：不级联</p>\n<p>​    save-update、delete、all</p>\n<ul>\n<li>inverse:反转关系维护，属于性能优化，必须根据业务关系选择一方放弃维护主键关系</li>\n</ul>\n<h5 id=\"检索\"><a href=\"#检索\" class=\"headerlink\" title=\"检索\"></a>检索</h5><h6 id=\"查询小结\"><a href=\"#查询小结\" class=\"headerlink\" title=\"查询小结\"></a>查询小结</h6><p>oid查询-get</p>\n<p>对象属性导航查询</p>\n<p>HQL</p>\n<p>Criteria</p>\n<p>原生SQL</p>\n<h6 id=\"HQL查询-1\"><a href=\"#HQL查询-1\" class=\"headerlink\" title=\"HQL查询\"></a>HQL查询</h6><p><strong>基本语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = “from java.lang.Object&quot;//查询所有Object及其子类</span><br></pre></td></tr></table></figure>\n<p><strong>排序语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;from Customer order by id asc&quot;//asc：升序</span><br><span class=\"line\"></span><br><span class=\"line\">String hql = &quot;from Customer order by id desc，xxxx  desc/asc</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;//desc：降序,如果相同，可根据别的列按照desc/asc再排序</span><br></pre></td></tr></table></figure>\n<p><strong>条件查询</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;from Customer where id =？&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">String hql = &quot;from Customer where id: id&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>分页查询</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;from con.itcast.domain.Customer&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">query query = session.creatQuery(hql);</span><br><span class=\"line\"></span><br><span class=\"line\">//limit ?， ?</span><br><span class=\"line\"></span><br><span class=\"line\">query.setFirstResult(0);//从第0条开始查询</span><br><span class=\"line\"></span><br><span class=\"line\">query.setFirstResult(2);//每页查询两条</span><br></pre></td></tr></table></figure>\n<p><strong>统计查询</strong></p>\n<p>聚合函数：count（计数）、sum(求和）、avg（平均数）、max、min</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;select count(*) from Customer&quot;//总记录数 </span><br><span class=\"line\">//String hq2 = &quot;select sum(id) from Customer&quot;</span><br><span class=\"line\">//String hql = &quot;select avg(id) from Customer&quot;</span><br><span class=\"line\">//String hql = &quot;select max(id) from Customer&quot;</span><br><span class=\"line\">//String hql = &quot;select min(id) from Customer&quot;</span><br><span class=\"line\">Query query = session.creatQuery(hql);</span><br><span class=\"line\"></span><br><span class=\"line\">Number number = (Number) query.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p><strong>投影查询</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;select cust_name from Customer&quot;//查询name</span><br><span class=\"line\">String hql = &quot;select cust_name,cust_id from Customer&quot;;//查询name和id两列，返回数组</span><br><span class=\"line\">String hql = &quot;select newCustomer(cust_name,cust_id) from Customer&quot;;//将查询的每个name和id封装到对应Customer对象中</span><br><span class=\"line\">//注：必须在Customerclass类中添加参数为name和id的构造方法以及无参构造方法</span><br></pre></td></tr></table></figure>\n<p><strong>多表查询</strong></p>\n<ul>\n<li><p>原生SQL：</p>\n<p>交叉连接：笛卡尔积selecte * from A,B</p>\n<p>内连接：</p>\n<p>​    隐式内连接：selecte * from A,B where 条件</p>\n<p>​    显式外连接：selecte * from A inner join B on  条件</p>\n<p>外连接：</p>\n<p>​    左外连接：selecte * from A left [outer] join B on 条件</p>\n<p>​    右外连接:selecte * from A right [outer] join B on 条件</p>\n</li>\n<li><p>HQL查询：</p>\n<ul>\n<li>内连接：</li>\n</ul>\n<p>​    String hql = “from Customer c inner join c.LinkMen”;//将对应的两个对象分别封装到数组</p>\n<p>​    迫切：String hql = “from Customer c inner join fetch c.LinkMen”;//把第二个表的东西封装到第一个对象中</p>\n<ul>\n<li><p>左外连接：String hql = “from Customer c left join c.LinkMen”</p>\n</li>\n<li><p>右外连接：String hql = “from Customer c right join c.LinkMen”</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Criterla查询（QBC）\"><a href=\"#Criterla查询（QBC）\" class=\"headerlink\" title=\"Criterla查询（QBC）\"></a>Criterla查询（QBC）</h6><p><strong>基本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Criteria查询</span><br><span class=\"line\">\t//查询所有Customer对象</span><br><span class=\"line\">\tCriteria criteria = session.createCriteria(Customer.class);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//普通查询</span><br><span class=\"line\">\tList&lt;Customer&gt; list2  = criteria.list();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//条件查询</span><br><span class=\"line\">\tcriteria.add(Restrictions.eq(&quot;cust_id&quot;,1));</span><br><span class=\"line\">\t//criteria.add(Restrictions.IdEq(1));</span><br><span class=\"line\">\tCustomer c = (Customer) criteria.uniqueResult();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//分页</span><br><span class=\"line\">\tcriteria.setFirstResult(1);</span><br><span class=\"line\">\tcriteria.setMaxResults(1);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//查询总记录</span><br><span class=\"line\">\t//设置查询的聚合函数=》总行数</span><br><span class=\"line\">\tcriteria.setProjection(Projections.rowCount());</span><br><span class=\"line\">\tLong count = (Long) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p><strong>条件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">criteria.add(Restrictions.eq(&quot;cust_id&quot;,1));</span><br><span class=\"line\">//criteria.add(Restrictions.IdEq(1));</span><br><span class=\"line\">Customer c = (Customer) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">c.setFirstResult(0);</span><br><span class=\"line\">c.setMaxResult(2);</span><br><span class=\"line\">List&lt;Customer&gt; list = c.list;</span><br></pre></td></tr></table></figure>\n<p><strong>排序</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">c.addOrder(Order.asc(&quot;cust_id&quot;));</span><br><span class=\"line\">List&lt;Customer&gt; list = c.list;</span><br></pre></td></tr></table></figure>\n<p><strong>统计</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">c.setProject(Projections.rowCount());</span><br><span class=\"line\">List&lt;Long&gt; list = c.list;</span><br></pre></td></tr></table></figure>\n<p><strong>离线查询</strong></p>\n<p>传统的criteria依赖于session创建（dao层）</p>\n<p>离线的criteria，可脱离session，在任意层均可凭空创建（扩大session的作用范围）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//web或service层</span><br><span class=\"line\">DetachedCriteria dc = DetachedCriteria.forClass(Customer.class);</span><br><span class=\"line\">dc.add(Restrictions.idEq(61));//拼装条件与普通一致</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//dao层</span><br><span class=\"line\">Criteria c = dc.getExecutableCriteria(session)</span><br><span class=\"line\">List list = c.list();</span><br></pre></td></tr></table></figure>\n<h5 id=\"查询优化\"><a href=\"#查询优化\" class=\"headerlink\" title=\"查询优化\"></a>查询优化</h5><h6 id=\"类级别查询\"><a href=\"#类级别查询\" class=\"headerlink\" title=\"类级别查询\"></a>类级别查询</h6><p>懒加载|延迟加载</p>\n<p>get:立即加载，执行方法时立即发送SQL语句查询结果</p>\n<p>load(默认)：结果和get一样，执行时，不发送任何SQL语句，返回一个对象，使用该对象时，才执行查询</p>\n<p>延时加载：仅仅获得不使用，不会查询，使用时才进行查询，（针对load方法），原理是动态代理<br>是否对类进行延迟加载，可通过在class元素上配置lazy属性控制：<br>​    lazy=true：加载时，不查询，使用时才查询<br>​    lazy=false：加载时立刻查询</p>\n<h6 id=\"关联级别查询\"><a href=\"#关联级别查询\" class=\"headerlink\" title=\"关联级别查询\"></a>关联级别查询</h6><p><strong>集合级别的关联</strong></p>\n<p>lazy属性:决定是否延迟加载：</p>\n<p>​    true(默认):延迟加载，懒加载；</p>\n<p>​    false：立即加载</p>\n<p>​    extra：及其懒惰（集合级别）</p>\n<p>fetch属性：决定加载策略，使用什么类型的SQL语句加载集合数据</p>\n<p>​    select(默认)：单表查询加载</p>\n<p>​    join：使用多表查询加载集合</p>\n<p>​    subselect:使用子查询加载集合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;set name=&quot;&quot; lazy=&quot;&quot; fetch=&quot;&quot;&gt;</span><br><span class=\"line\">\t&lt;key volumn=&quot;lkm_cust_id&gt;&lt;/key&gt;</span><br><span class=\"line\">\t&lt;one_to_many class=&quot;&quot;/&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fetch:select（单表查询） , lazy=true(使用时才加载集合数据)，该组合为默认</li>\n<li><p>fetch:select（/单表查询） , lazy=false(立即加载集合数据）</p>\n</li>\n<li><p>fetch:select（/单表查询） , lazy=extra(与懒加载效果基本一致，但如果只获得集合的size，extra只获得集合的size：‘count语句’）</p>\n</li>\n<li><p>fetch:join , lazy=true/false/extra：多表查询立即加载集合，lazy属性失效</p>\n</li>\n<li><p>fetch:subselect，lazy=true:如果用不到子查询，效果相当于select，先单表查询，集合使用时才立即查询加载</p>\n</li>\n<li><p>fetch:subselect，lazy=false:立即查询加载相关集合数据</p>\n</li>\n<li><p>fetch:subselect，lazy=extra:先单表查询，集合使用时才立即查询加载，如果只获得集合的size，extra只获得集合的size：‘count语句’</p>\n</li>\n</ul>\n<p><strong>属性级别的关联</strong></p>\n<p>根据被关联的对象获得主对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linkman lm = session.get(Linkman.class,2);</span><br><span class=\"line\">Customer c = lm.getCustomer();</span><br><span class=\"line\">System.out.println(customer);</span><br></pre></td></tr></table></figure>\n<p>配置中属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;many-to-one name=&quot;Customer&quot; column=&quot;&quot; class=&quot;&quot; fetch=&quot;&quot; lazy=&quot;&gt;</span><br><span class=\"line\">&lt;/many-to-one&gt;</span><br></pre></td></tr></table></figure>\n<p>fetch属性：决定加载策略，使用什么类型的SQL语句加载数据</p>\n<p>​    select(默认)：单表查询加载</p>\n<p>​    join：使用多表查询加载集合</p>\n<p>lazy属性:决定是否延迟加载：</p>\n<p>​    false：立即加载</p>\n<p>​    proxy：由主类的类级别策略决定</p>\n<ul>\n<li>fetch:select,lazy=proxy(true),单表查询，懒加载</li>\n<li>fetch:select,lazy=proxy(false，extra),多表立即加载</li>\n<li>fetch:join,lazy属性失效,</li>\n</ul>\n<p><strong>结论</strong>：为了提高效率，fetch的选择应选择select，lazy应选择true（默认）</p>\n<h5 id=\"批量抓取\"><a href=\"#批量抓取\" class=\"headerlink\" title=\"批量抓取\"></a>批量抓取</h5><p>每次抓取几个集合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--每次抓取3个客户的集合--&gt;</span><br><span class=\"line\">&lt;set name=&quot;&quot; batch-size=&quot;3&quot;&gt;</span><br><span class=\"line\">\t&lt;key volumn=&quot;lkm_cust_id&gt;&lt;/key&gt;</span><br><span class=\"line\">\t&lt;one_to_many class=&quot;&quot;/&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>​    hibernate是我学习JavaEE framework的开始，分享学习的笔记给大家~</p>\n<h4 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h4><p>1）导包</p>\n<p>2）创建数据库</p>\n<p>3）书写Orm元数据(对象与表的映射配置文件)</p>\n<p>导入约束、实体、orm元数据</p>\n<p>4）书写主配置文件</p>\n<p>hibernate.cfg.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class=\"line\"><span class=\"meta\">\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.dirver_class\"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql:///hibernate?useSSL=false&amp;amp;serverTimezone=GMT%2b8&amp;amp;allowPublicKeyRetrieval=true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.connection.password\"</span>&gt;</span>yue18800422369<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.format_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.hbm2ddl.auto\"</span>&gt;</span>update<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">mapping</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"domain/Customer.hbm.xml\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">session-factory</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>5）书写代码测试</p>\n<p>映射文件:Customer.hbm.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class=\"line\"><span class=\"meta\">\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置表与实体对象的关系 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hibernate-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">class</span> <span class=\"attr\">name</span>=<span class=\"string\">\"domain.Customer\"</span> <span class=\"attr\">table</span>=<span class=\"string\">\"cst_customer\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_id\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_id\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">generator</span> <span class=\"attr\">class</span>=<span class=\"string\">\"native\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">generator</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_name\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_source\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_source\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_industry\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_industry\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_level\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_level\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_linkman\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_linkman\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_phone\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_phone\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cust_mobile\"</span> <span class=\"attr\">column</span>=<span class=\"string\">\"cust_mobile\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"hibernateAPI详解\"><a href=\"#hibernateAPI详解\" class=\"headerlink\" title=\"hibernateAPI详解\"></a>hibernateAPI详解</h4><h5 id=\"configuration\"><a href=\"#configuration\" class=\"headerlink\" title=\"configuration\"></a>configuration</h5><p>读取配置文件：主配置和orm元数据</p>\n<h5 id=\"SessionFactory\"><a href=\"#SessionFactory\" class=\"headerlink\" title=\"SessionFactory\"></a>SessionFactory</h5><p>用于创建操作数据库核心对象session对象的工厂<br>注：1、sessionFactory负责保存和使用所有配置信息，消耗内存资源非常大<br>​    2、sessionFactory属于线程安全的对象设计<br>结论：保证在web项目中，只创建一个sessionFactory</p>\n<h5 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h5><p>表达hibernate框架与数据库之间的连接（会话），类似于JDBC的connection对象，可实现数据库的增删改查</p>\n<h5 id=\"Transaction\"><a href=\"#Transaction\" class=\"headerlink\" title=\"Transaction\"></a>Transaction</h5><p>封装了事务的操作：打开事务、提交事务、回滚事务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、创建</span></span><br><span class=\"line\">\t\tConfiguration conf = <span class=\"keyword\">new</span> Configuration().configure();</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、读取主配置文件,无参读取：hibernate.cfg.xml</span></span><br><span class=\"line\">\t\tconf.configure();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"comment\">//\t\t//读取指定orm元数据(old)</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tconf.addResource(resourceName);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tconf.addClass(persistentClass);</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//4、根据配置信息，创建sessionFactory对象</span></span><br><span class=\"line\">\t\tSessionFactory sessionFactory = conf.buildSessionFactory();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//5、获得session</span></span><br><span class=\"line\">\t\tSession session = sessionFactory.openSession();</span><br><span class=\"line\">\t\t<span class=\"comment\">//打开一个新的session对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//sessionFactory.openSession();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//获得一个与线程绑定的session对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//sessionFactory.getCurrentSession();</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//6、session获得操作事务的Transaction对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//获得操作事务的tx对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//Transaction tx = session.getTransaction();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//tx.begin();</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//开启事务并获得操作事务的tx对象（建议使用）</span></span><br><span class=\"line\">\t\tTransaction tx2 = session.beginTransaction();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//...................</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//增</span></span><br><span class=\"line\">\t\tCustomer customer = <span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">\t\tcustomer.setCust_name(<span class=\"string\">\"best\"</span>);</span><br><span class=\"line\">\t\tsession.save(customer);\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//查询</span></span><br><span class=\"line\">\t\tCustomer customer2 = session.get(Customer.class, <span class=\"number\">1l</span>);\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//修改</span></span><br><span class=\"line\">\t\tCustomer customer3  = session.get(Customer.class,<span class=\"number\">1L</span>);</span><br><span class=\"line\">\t\tcustomer3.setCust_name(<span class=\"string\">\"angle\"</span>);</span><br><span class=\"line\">\t\tsession.update(customer3);</span><br><span class=\"line\">\t\t<span class=\"comment\">//删除</span></span><br><span class=\"line\">\t\tCustomer customer4 = session.get(Customer.class, <span class=\"number\">1l</span>);</span><br><span class=\"line\">\t\tsession.delete(customer4);</span><br><span class=\"line\">\t\t<span class=\"comment\">//...............</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttx2.commit();</span><br><span class=\"line\">\t\tsession.close();</span><br><span class=\"line\">\t\tsessionFactory.close();</span><br></pre></td></tr></table></figure>\n<h4 id=\"实体规则\"><a href=\"#实体规则\" class=\"headerlink\" title=\"实体规则\"></a>实体规则</h4><h5 id=\"创建规则\"><a href=\"#创建规则\" class=\"headerlink\" title=\"创建规则\"></a>创建规则</h5><ul>\n<li><p>持久化类提供无参构造(通过反射创建对象)</p>\n</li>\n<li><p>成员变量私有，需提供get/set（属性）</p>\n</li>\n<li><p>持久化类中的属性，应尽量使用包装类型</p>\n</li>\n<li><p>持久化类需要oid与数据库中的主键列对应</p>\n</li>\n<li>不要用final修饰class（hibernate使用cglib代理生成代理对象，代理对象继承被代理对象，如果被final修饰，将无法代理）</li>\n</ul>\n<h5 id=\"主键类型\"><a href=\"#主键类型\" class=\"headerlink\" title=\"主键类型\"></a>主键类型</h5><h6 id=\"自然主键\"><a href=\"#自然主键\" class=\"headerlink\" title=\"自然主键\"></a>自然主键</h6><p>表的业务列中，其中必须有且不可重复的列可作为主键使用</p>\n<h6 id=\"代理主键\"><a href=\"#代理主键\" class=\"headerlink\" title=\"代理主键\"></a>代理主键</h6><p>表的业务列中，没有可作为主键的列，则创建一个没有业务的列作为主键</p>\n<h5 id=\"主键生成策略\"><a href=\"#主键生成策略\" class=\"headerlink\" title=\"主键生成策略\"></a>主键生成策略</h5><p>每条记录生成时，主键的生成规则（7个）</p>\n<ul>\n<li>identity：主键自增，由数据库来维护主键值，录入时不需指定主键</li>\n<li>sequence：Oracle中的主键生成策略</li>\n<li><p>increment（了解）：主键自增，由hibernate来维护，每次插入前，会先查询表中id最大值，然后加1作为主键值（线程不安全）</p>\n</li>\n<li><p>hilo（了解）：高低位算法，由hibernate维护</p>\n</li>\n<li>native：hilo+sequence+identity，自动三选一</li>\n<li>uuid： 产生随机字符串作为主串</li>\n<li>assigned：自然主键生成，由用户录入生成</li>\n</ul>\n<h4 id=\"hibernate的对象状态\"><a href=\"#hibernate的对象状态\" class=\"headerlink\" title=\"hibernate的对象状态\"></a>hibernate的对象状态</h4><p>对象分为三种状态：</p>\n<ul>\n<li><p>瞬时状态：没有id，没有与session关联</p>\n</li>\n<li><p>持久化状态：有id，与session关联</p>\n<p>持久化状态的对象的任何变化都会自动同步到数据库中，不需要执行update方法</p>\n</li>\n<li><p>游离/托管状态：有id，没有与session关联</p>\n</li>\n</ul>\n<p>注：有id指的是有和数据库中对应的id</p>\n<p>状态转化：</p>\n<p>起点$\\rightarrow$瞬时（new）</p>\n<p>起点$\\rightarrow$持久化（get）</p>\n<p>瞬时 $\\rightarrow $持久化(save) $\\rightarrow $游离/托管状态(close)</p>\n<p>瞬时 $\\leftarrow $持久化(delete) $\\leftarrow $游离/托管状态(update)</p>\n<p>saveOrUpdate:将所有对象转化为持久化状态</p>\n<p>（持久化对象就是放入session缓存的对象）</p>\n<h4 id=\"hibernate的进阶–缓存\"><a href=\"#hibernate的进阶–缓存\" class=\"headerlink\" title=\"hibernate的进阶–缓存\"></a>hibernate的进阶–缓存</h4><p>提高效率的方式：</p>\n<ul>\n<li>提高查询效率（缓冲区）</li>\n<li>减少不必要的修改语句发送（利用快照）</li>\n</ul>\n<h4 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h4><ul>\n<li><p>性质：</p>\n<ul>\n<li><p>原子性</p>\n</li>\n<li><p>一致性：数据在提交前和提交后总量保持一致</p>\n</li>\n<li><p>隔离性</p>\n</li>\n<li><p>持久性：数据提交之后必须要被持久化保存</p>\n</li>\n</ul>\n</li>\n<li><p>并发问题：</p>\n<ul>\n<li><p>脏读：读取到了正在操作并未保存的数据；B事务读取了A事务没有提交的数据</p>\n</li>\n<li><p>不可重复读：在一个事务中，两次读取的事务不一致</p>\n</li>\n<li><p>幻/虚读：一般针对整表的操作；一个事务中，两次读取的数据的数量不一致</p>\n</li>\n</ul>\n</li>\n<li><p>事务的隔离级别：</p>\n<ul>\n<li><p>读未提交 1*：脏读、不可重复读、幻读（可产生问题）</p>\n</li>\n<li><p>读已提交 2*：不可重复读、幻读</p>\n</li>\n<li><p>可重复读 4*（MySQL默认级别）：幻读</p>\n</li>\n<li><p>串行化 8*</p>\n</li>\n</ul>\n</li>\n<li><p>在hibernate指定隔离级别：1 2 4 8</p>\n</li>\n<li><p>在项目中管理项目</p>\n<p>dao层数据操作和service层控制事务都需要session对象，要确保使用的是同一个session对象：</p>\n<p>1）在hibernate中调用getCurrentSession方法获得与线程绑定的session对象，调用该方法时，必须在主配置中主配置中说明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hibernate.current_session_context_class\"</span>&gt;</span>thread<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2）通过getCurrentSession方法获得session对象，当事务提交时session会自动关闭，不许手动。</p>\n</li>\n</ul>\n<h4 id=\"批量查询\"><a href=\"#批量查询\" class=\"headerlink\" title=\"批量查询\"></a>批量查询</h4><h5 id=\"HQL查询\"><a href=\"#HQL查询\" class=\"headerlink\" title=\"HQL查询\"></a>HQL查询</h5><p>多表查询，但不复杂时使用</p>\n<p>hibernate独家查询语言，面向对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、书写HQL语句</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from 对象的完整类名\";</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from Customer where cust_id = 1\";//cust_id是属性</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from Customer\";//查询所有Customer对象</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//String hql = \"from Customer where cust_id = ?\";//问号占位符</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">String</span> hql = <span class=\"string\">\"from Customer where cust_id ：id\"</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//2、根据HQL语句创建查询对象</span></span><br><span class=\"line\">\t\tQuery&lt;Customer&gt; query = session.createQuery(hql);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//分页查询</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//设置分页信息</span></span><br><span class=\"line\">\t\tquery.setFirstResult(<span class=\"number\">0</span>);<span class=\"comment\">//第0条开始查询</span></span><br><span class=\"line\">\t\tquery.setMaxResults(<span class=\"number\">2</span>);<span class=\"comment\">//最多查询两条</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置参数(占位符）</span></span><br><span class=\"line\">\t\tquery.setLong(<span class=\"number\">0</span>, <span class=\"number\">1</span>);<span class=\"comment\">//问号占位符</span></span><br><span class=\"line\">\t\tquery.setParameter(<span class=\"number\">0</span>, <span class=\"number\">1</span>);<span class=\"comment\">//类型通用</span></span><br><span class=\"line\">\t\tquery.setParameter(<span class=\"string\">\"id\"</span>, <span class=\"number\">1</span>);<span class=\"comment\">//命名占位符</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//3、根据查询对象获得查询结果</span></span><br><span class=\"line\">\t\tList list = (List) query.list();</span><br><span class=\"line\">\t\t<span class=\"comment\">//query.uniqueResult();//接收唯一的查询对象</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Criteria查询\"><a href=\"#Criteria查询\" class=\"headerlink\" title=\"Criteria查询\"></a>Criteria查询</h5><p>单表查询</p>\n<p>hibernate自创的无语句面向对象查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Criteria查询</span><br><span class=\"line\">//查询所有Customer对象</span><br><span class=\"line\">Criteria criteria = session.createCriteria(Customer.class);</span><br><span class=\"line\">//普通查询</span><br><span class=\"line\">List&lt;Customer&gt; list2  = criteria.list();</span><br><span class=\"line\">//条件查询</span><br><span class=\"line\">criteria.add(Restrictions.eq(&quot;cust_id&quot;,1));</span><br><span class=\"line\">//criteria.add(Restrictions.IdEq(1));</span><br><span class=\"line\">Customer c = (Customer) criteria.uniqueResult();</span><br><span class=\"line\">//分页</span><br><span class=\"line\">criteria.setFirstResult(1);</span><br><span class=\"line\">criteria.setMaxResults(1);</span><br><span class=\"line\">//查询总记录</span><br><span class=\"line\">//设置查询的聚合函数=》总行数</span><br><span class=\"line\">criteria.setProjection(Projections.rowCount());</span><br><span class=\"line\">Long count = (Long) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p>常见查询条件:</p>\n<table>\n<thead>\n<tr>\n<th>&gt;</th>\n<th>gt</th>\n<th>between and</th>\n<th>between</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&gt;=</td>\n<td>lt</td>\n<td>like</td>\n<td>like</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>lt</td>\n<td>is not null</td>\n<td>isNotNull</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>le</td>\n<td>is null</td>\n<td>isNull</td>\n</tr>\n<tr>\n<td>==</td>\n<td>eq</td>\n<td>or</td>\n<td>or</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>in</td>\n<td>and</td>\n<td>and</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"原生SQL查询\"><a href=\"#原生SQL查询\" class=\"headerlink\" title=\"原生SQL查询\"></a>原生SQL查询</h5><p>复杂的业务查询</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原生SQL查询</span></span><br><span class=\"line\">\t<span class=\"comment\">//String sql = \"select * from cst_customer\";</span></span><br><span class=\"line\">\t<span class=\"comment\">//条件查询与分页</span></span><br><span class=\"line\">\t<span class=\"built_in\">String</span> sqlString  = <span class=\"string\">\"select * from csy_customer limit ?,?\"</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tSQLQuery&lt;<span class=\"built_in\">Object</span>[]&gt; query2 = session.createSQLQuery(sql);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tquery2.setParameter(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tquery2.setParameter(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//查询到的每行结果放到一个object数组</span></span><br><span class=\"line\">\t<span class=\"comment\">//List&lt;Object[]&gt; list3 = query2.list();</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//封装结果</span></span><br><span class=\"line\">\tquery2.addEntity(Customer.class);</span><br><span class=\"line\">\tList&lt;Customer&gt; list3 = query2.list();</span><br></pre></td></tr></table></figure>\n<h4 id=\"多对多关系\"><a href=\"#多对多关系\" class=\"headerlink\" title=\"多对多关系\"></a>多对多关系</h4><h5 id=\"一对多、多对一\"><a href=\"#一对多、多对一\" class=\"headerlink\" title=\"一对多、多对一\"></a>一对多、多对一</h5><h6 id=\"关系的表达\"><a href=\"#关系的表达\" class=\"headerlink\" title=\"关系的表达\"></a>关系的表达</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 集合，一对多关系的配置 --&gt;</span><br><span class=\"line\">\t\t&lt;!--</span><br><span class=\"line\">\t\t name:集合属性名</span><br><span class=\"line\">\t\t column:外键列名</span><br><span class=\"line\">\t\t class：关联的对象的完整类名</span><br><span class=\"line\">\t\t --&gt;</span><br><span class=\"line\">\t\t&lt;set name=&quot;LinkMen&quot; cascade：save-update&gt;</span><br><span class=\"line\">\t\t\t&lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt;</span><br><span class=\"line\">\t\t\t&lt;one-to-many class=&quot;LinkMan&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;/set&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;!-- 多对一的配置 --&gt;</span><br><span class=\"line\">\t\t&lt;many-to-one name=&quot;customer&quot; column=&quot;lkm_cust_id&quot; class=&quot;Customer&quot;&gt;&lt;/many-to-one&gt;</span><br></pre></td></tr></table></figure>\n<h6 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//保存客户以及客户下的联系人</span><br><span class=\"line\">\tCustomer customer = new Customer();</span><br><span class=\"line\">\tcustomer.setCust_name(&quot;blog&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tLinkMan lMan1 = new LinkMan();</span><br><span class=\"line\">\tlMan1.setLkm_name(&quot;man1&quot;);</span><br><span class=\"line\">\tLinkMan lMan2 = new LinkMan();</span><br><span class=\"line\">\tlMan2.setLkm_name(&quot;man2&quot;);</span><br><span class=\"line\">\tLinkMan lMan3 = new LinkMan();</span><br><span class=\"line\">\tlMan3.setLkm_name(&quot;man3&quot;);</span><br><span class=\"line\">\t//表达一对多，一个客户有多个联系人</span><br><span class=\"line\">\tcustomer.getLinkmen().add(lMan1);</span><br><span class=\"line\">\tcustomer.getLinkmen().add(lMan2);</span><br><span class=\"line\">\t//表达多对一，联系人属于哪个客户</span><br><span class=\"line\">\tlMan1.setCustomer(customer);</span><br><span class=\"line\">\tlMan2.setCustomer(customer);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsession.save(customer);</span><br><span class=\"line\">\tsession.save(lMan1);</span><br><span class=\"line\">\tsession.save(lMan2);</span><br></pre></td></tr></table></figure>\n<h6 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h6><p><strong>联操作</strong></p>\n<p>cascade（配置文件配置）</p>\n<p>​    save-update:级联保存更新</p>\n<p>​    delete：级联删除</p>\n<p>​    all：save-update+delete</p>\n<p><strong>关系维护</strong></p>\n<p>在保存时，两方都会维护关系，冗余</p>\n<p>inverse属性：配置关系是否维护，默认是false(维护），但是多的一方不能放弃维护</p>\n<h5 id=\"多对多\"><a href=\"#多对多\" class=\"headerlink\" title=\"多对多\"></a>多对多</h5><p>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;set name=&quot;set集合名&quot; table=&quot;中间表名&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;key column=&quot;对方引用的自己的外键名&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;many-to-many class=&quot;与哪个别的类多对多&quot; column=&quot;引用的别人的外键&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<p>注：开发中利用inverse属性，根据业务方向选择一方放弃维护关系</p>\n<p><strong>小结</strong></p>\n<p><strong>一对多/多对一</strong></p>\n<ul>\n<li><p>O：对象  </p>\n<p>  一的一方使用集合，多的一方直接引用一的一方</p>\n</li>\n<li><p>R：关系型数据库      </p>\n<p>多的一方使用外键引用一的一方主键</p>\n</li>\n<li><p>M：映射文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一：&lt;set name=&quot;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;key column = &quot;&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;one-to-many name=&quot;&quot; column=&quot;&quot; class=&quot;&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;/set&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">多：&lt;many-to-one name=&quot;&quot; column=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>关系操作：级别属性</p>\n<p>进阶：</p>\n<p>​    inverse：反转关系维护,性能优化（true：放弃，默认false维护），一对多中，一的一方可放弃维护关系</p>\n<p>​    casecade：级联操作，减少代码（nono(默认)：不级联save-update、delete、all)</p>\n</li>\n</ul>\n<p><strong>多对多</strong></p>\n<ul>\n<li><p>O：对象</p>\n<p>两方都使用集合</p>\n</li>\n<li><p>R：使用中间表，至少两列，作为外键引用两张表的主键</p>\n</li>\n<li><p>M：映射文件</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多：</span><br><span class=\"line\">&lt;set name=&quot;&quot; table=&quot;中间表名&quot;&gt;</span><br><span class=\"line\">\t&lt;key column=&quot;别人引用的自己的外键&quot;&gt;</span><br><span class=\"line\">\t&lt;many-to-many class=&quot;&quot; column=&quot;引用别人的外键名&quot;/&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<p>操作：操作管理级别属性</p>\n<ul>\n<li>casede:级联属性，减少代码书写</li>\n</ul>\n<p>​    nono(默认)：不级联</p>\n<p>​    save-update、delete、all</p>\n<ul>\n<li>inverse:反转关系维护，属于性能优化，必须根据业务关系选择一方放弃维护主键关系</li>\n</ul>\n<h5 id=\"检索\"><a href=\"#检索\" class=\"headerlink\" title=\"检索\"></a>检索</h5><h6 id=\"查询小结\"><a href=\"#查询小结\" class=\"headerlink\" title=\"查询小结\"></a>查询小结</h6><p>oid查询-get</p>\n<p>对象属性导航查询</p>\n<p>HQL</p>\n<p>Criteria</p>\n<p>原生SQL</p>\n<h6 id=\"HQL查询-1\"><a href=\"#HQL查询-1\" class=\"headerlink\" title=\"HQL查询\"></a>HQL查询</h6><p><strong>基本语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = “from java.lang.Object&quot;//查询所有Object及其子类</span><br></pre></td></tr></table></figure>\n<p><strong>排序语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;from Customer order by id asc&quot;//asc：升序</span><br><span class=\"line\"></span><br><span class=\"line\">String hql = &quot;from Customer order by id desc，xxxx  desc/asc</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;//desc：降序,如果相同，可根据别的列按照desc/asc再排序</span><br></pre></td></tr></table></figure>\n<p><strong>条件查询</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;from Customer where id =？&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">String hql = &quot;from Customer where id: id&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>分页查询</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;from con.itcast.domain.Customer&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">query query = session.creatQuery(hql);</span><br><span class=\"line\"></span><br><span class=\"line\">//limit ?， ?</span><br><span class=\"line\"></span><br><span class=\"line\">query.setFirstResult(0);//从第0条开始查询</span><br><span class=\"line\"></span><br><span class=\"line\">query.setFirstResult(2);//每页查询两条</span><br></pre></td></tr></table></figure>\n<p><strong>统计查询</strong></p>\n<p>聚合函数：count（计数）、sum(求和）、avg（平均数）、max、min</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;select count(*) from Customer&quot;//总记录数 </span><br><span class=\"line\">//String hq2 = &quot;select sum(id) from Customer&quot;</span><br><span class=\"line\">//String hql = &quot;select avg(id) from Customer&quot;</span><br><span class=\"line\">//String hql = &quot;select max(id) from Customer&quot;</span><br><span class=\"line\">//String hql = &quot;select min(id) from Customer&quot;</span><br><span class=\"line\">Query query = session.creatQuery(hql);</span><br><span class=\"line\"></span><br><span class=\"line\">Number number = (Number) query.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p><strong>投影查询</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String hql = &quot;select cust_name from Customer&quot;//查询name</span><br><span class=\"line\">String hql = &quot;select cust_name,cust_id from Customer&quot;;//查询name和id两列，返回数组</span><br><span class=\"line\">String hql = &quot;select newCustomer(cust_name,cust_id) from Customer&quot;;//将查询的每个name和id封装到对应Customer对象中</span><br><span class=\"line\">//注：必须在Customerclass类中添加参数为name和id的构造方法以及无参构造方法</span><br></pre></td></tr></table></figure>\n<p><strong>多表查询</strong></p>\n<ul>\n<li><p>原生SQL：</p>\n<p>交叉连接：笛卡尔积selecte * from A,B</p>\n<p>内连接：</p>\n<p>​    隐式内连接：selecte * from A,B where 条件</p>\n<p>​    显式外连接：selecte * from A inner join B on  条件</p>\n<p>外连接：</p>\n<p>​    左外连接：selecte * from A left [outer] join B on 条件</p>\n<p>​    右外连接:selecte * from A right [outer] join B on 条件</p>\n</li>\n<li><p>HQL查询：</p>\n<ul>\n<li>内连接：</li>\n</ul>\n<p>​    String hql = “from Customer c inner join c.LinkMen”;//将对应的两个对象分别封装到数组</p>\n<p>​    迫切：String hql = “from Customer c inner join fetch c.LinkMen”;//把第二个表的东西封装到第一个对象中</p>\n<ul>\n<li><p>左外连接：String hql = “from Customer c left join c.LinkMen”</p>\n</li>\n<li><p>右外连接：String hql = “from Customer c right join c.LinkMen”</p>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"Criterla查询（QBC）\"><a href=\"#Criterla查询（QBC）\" class=\"headerlink\" title=\"Criterla查询（QBC）\"></a>Criterla查询（QBC）</h6><p><strong>基本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Criteria查询</span><br><span class=\"line\">\t//查询所有Customer对象</span><br><span class=\"line\">\tCriteria criteria = session.createCriteria(Customer.class);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//普通查询</span><br><span class=\"line\">\tList&lt;Customer&gt; list2  = criteria.list();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//条件查询</span><br><span class=\"line\">\tcriteria.add(Restrictions.eq(&quot;cust_id&quot;,1));</span><br><span class=\"line\">\t//criteria.add(Restrictions.IdEq(1));</span><br><span class=\"line\">\tCustomer c = (Customer) criteria.uniqueResult();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//分页</span><br><span class=\"line\">\tcriteria.setFirstResult(1);</span><br><span class=\"line\">\tcriteria.setMaxResults(1);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//查询总记录</span><br><span class=\"line\">\t//设置查询的聚合函数=》总行数</span><br><span class=\"line\">\tcriteria.setProjection(Projections.rowCount());</span><br><span class=\"line\">\tLong count = (Long) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p><strong>条件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">criteria.add(Restrictions.eq(&quot;cust_id&quot;,1));</span><br><span class=\"line\">//criteria.add(Restrictions.IdEq(1));</span><br><span class=\"line\">Customer c = (Customer) criteria.uniqueResult();</span><br></pre></td></tr></table></figure>\n<p><strong>分页</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">c.setFirstResult(0);</span><br><span class=\"line\">c.setMaxResult(2);</span><br><span class=\"line\">List&lt;Customer&gt; list = c.list;</span><br></pre></td></tr></table></figure>\n<p><strong>排序</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">c.addOrder(Order.asc(&quot;cust_id&quot;));</span><br><span class=\"line\">List&lt;Customer&gt; list = c.list;</span><br></pre></td></tr></table></figure>\n<p><strong>统计</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Criteria c = session.creatCriteria(Customer.class);</span><br><span class=\"line\">c.setProject(Projections.rowCount());</span><br><span class=\"line\">List&lt;Long&gt; list = c.list;</span><br></pre></td></tr></table></figure>\n<p><strong>离线查询</strong></p>\n<p>传统的criteria依赖于session创建（dao层）</p>\n<p>离线的criteria，可脱离session，在任意层均可凭空创建（扩大session的作用范围）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//web或service层</span><br><span class=\"line\">DetachedCriteria dc = DetachedCriteria.forClass(Customer.class);</span><br><span class=\"line\">dc.add(Restrictions.idEq(61));//拼装条件与普通一致</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//dao层</span><br><span class=\"line\">Criteria c = dc.getExecutableCriteria(session)</span><br><span class=\"line\">List list = c.list();</span><br></pre></td></tr></table></figure>\n<h5 id=\"查询优化\"><a href=\"#查询优化\" class=\"headerlink\" title=\"查询优化\"></a>查询优化</h5><h6 id=\"类级别查询\"><a href=\"#类级别查询\" class=\"headerlink\" title=\"类级别查询\"></a>类级别查询</h6><p>懒加载|延迟加载</p>\n<p>get:立即加载，执行方法时立即发送SQL语句查询结果</p>\n<p>load(默认)：结果和get一样，执行时，不发送任何SQL语句，返回一个对象，使用该对象时，才执行查询</p>\n<p>延时加载：仅仅获得不使用，不会查询，使用时才进行查询，（针对load方法），原理是动态代理<br>是否对类进行延迟加载，可通过在class元素上配置lazy属性控制：<br>​    lazy=true：加载时，不查询，使用时才查询<br>​    lazy=false：加载时立刻查询</p>\n<h6 id=\"关联级别查询\"><a href=\"#关联级别查询\" class=\"headerlink\" title=\"关联级别查询\"></a>关联级别查询</h6><p><strong>集合级别的关联</strong></p>\n<p>lazy属性:决定是否延迟加载：</p>\n<p>​    true(默认):延迟加载，懒加载；</p>\n<p>​    false：立即加载</p>\n<p>​    extra：及其懒惰（集合级别）</p>\n<p>fetch属性：决定加载策略，使用什么类型的SQL语句加载集合数据</p>\n<p>​    select(默认)：单表查询加载</p>\n<p>​    join：使用多表查询加载集合</p>\n<p>​    subselect:使用子查询加载集合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;set name=&quot;&quot; lazy=&quot;&quot; fetch=&quot;&quot;&gt;</span><br><span class=\"line\">\t&lt;key volumn=&quot;lkm_cust_id&gt;&lt;/key&gt;</span><br><span class=\"line\">\t&lt;one_to_many class=&quot;&quot;/&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fetch:select（单表查询） , lazy=true(使用时才加载集合数据)，该组合为默认</li>\n<li><p>fetch:select（/单表查询） , lazy=false(立即加载集合数据）</p>\n</li>\n<li><p>fetch:select（/单表查询） , lazy=extra(与懒加载效果基本一致，但如果只获得集合的size，extra只获得集合的size：‘count语句’）</p>\n</li>\n<li><p>fetch:join , lazy=true/false/extra：多表查询立即加载集合，lazy属性失效</p>\n</li>\n<li><p>fetch:subselect，lazy=true:如果用不到子查询，效果相当于select，先单表查询，集合使用时才立即查询加载</p>\n</li>\n<li><p>fetch:subselect，lazy=false:立即查询加载相关集合数据</p>\n</li>\n<li><p>fetch:subselect，lazy=extra:先单表查询，集合使用时才立即查询加载，如果只获得集合的size，extra只获得集合的size：‘count语句’</p>\n</li>\n</ul>\n<p><strong>属性级别的关联</strong></p>\n<p>根据被关联的对象获得主对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linkman lm = session.get(Linkman.class,2);</span><br><span class=\"line\">Customer c = lm.getCustomer();</span><br><span class=\"line\">System.out.println(customer);</span><br></pre></td></tr></table></figure>\n<p>配置中属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;many-to-one name=&quot;Customer&quot; column=&quot;&quot; class=&quot;&quot; fetch=&quot;&quot; lazy=&quot;&gt;</span><br><span class=\"line\">&lt;/many-to-one&gt;</span><br></pre></td></tr></table></figure>\n<p>fetch属性：决定加载策略，使用什么类型的SQL语句加载数据</p>\n<p>​    select(默认)：单表查询加载</p>\n<p>​    join：使用多表查询加载集合</p>\n<p>lazy属性:决定是否延迟加载：</p>\n<p>​    false：立即加载</p>\n<p>​    proxy：由主类的类级别策略决定</p>\n<ul>\n<li>fetch:select,lazy=proxy(true),单表查询，懒加载</li>\n<li>fetch:select,lazy=proxy(false，extra),多表立即加载</li>\n<li>fetch:join,lazy属性失效,</li>\n</ul>\n<p><strong>结论</strong>：为了提高效率，fetch的选择应选择select，lazy应选择true（默认）</p>\n<h5 id=\"批量抓取\"><a href=\"#批量抓取\" class=\"headerlink\" title=\"批量抓取\"></a>批量抓取</h5><p>每次抓取几个集合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--每次抓取3个客户的集合--&gt;</span><br><span class=\"line\">&lt;set name=&quot;&quot; batch-size=&quot;3&quot;&gt;</span><br><span class=\"line\">\t&lt;key volumn=&quot;lkm_cust_id&gt;&lt;/key&gt;</span><br><span class=\"line\">\t&lt;one_to_many class=&quot;&quot;/&gt;</span><br><span class=\"line\">&lt;/set&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"软件构造实验一","date":"2019-04-18T06:05:48.000Z","description":"个人觉得软件构造的实验还是挺不错的，非常有锻炼价值","_content":"\n\n#### 实验目标概述\n\n本次实验通过求解四个问题（其中一个可选），训练基本Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。\n\n- 基本的Java OO编程\n\n-  基于Eclipse IDE进行Java编程\n\n-  基于JUnit的测试\n\n-  基于Git的代码配置管理\n\n \n\n####  实验环境配置\n\n简要陈述你配置本次实验所需开发、测试、运行环境的过程，必要时可以给出屏幕截图。\n\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n\n1）从助教给的压缩包中下载eclipse并安装，在使用Eclipse进行Junit单元测试时先右键项目->Build Path->Add Library并选择junit，导入junit4。\n\n2）重新注册Git账号，并绑定Classroom建立自己的仓库，并将其clone到本地。\n\n3）P1的MagicSquare.java中的main方法读取txt包下的测试文件时读取不到，使用相对路径读取文件总是找不到文件，使用绝对路径会由于项目提交之后路径发生改变而出错。所以，读取目录即可采用相对项目根目录读取的方式，用new File(\"\").getCanonicalPath()获取项目的根目录，然后拼接字符串“/src/P1/txt/1.txt”即可获取src下P1包中 的txt文件夹下的1.txt测试文件。 \n\n在这里给出你的GitHub Lab1仓库的URL地址（Lab1-学号）。\n\n​       https://github.com/ComputerScienceHIT/Lab1-1170300503\n\n#### 实验过程\n\n请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。\n\n为了条理清晰，可根据需要在各节增加三级标题。\n\n#####  Magic Squares\n\n在这里简要概述你对该任务的理解。\n\n该实验是判断一个矩阵是否是由正整数组成的方阵，并且文件中数字存储用“\\t”划分，每行、每列及对角线数字之和均相等，如果是，则该矩阵是MagicSquare，否则不是。判断过程中，主要步骤是读取文件并分割字符串，判断输入是否合法，其次是对每行每列及对角线数字之和是否相等进行判断。\n\n###### isLegalMagicSquare()\n\n按步骤给出你的设计和实现思路/过程/结果。\n\n1） 根据参数filename判断文件是否存在，如果不存在，返回false，结束；\n\n2） 按行读取文件，记录读取行数；\n\n3） 读取的每行数据按照“\\t”分割，并判断分割后的每部分是否是数字，如果是数字，接着判断是否正整数，将每一个数字依次存入数组numbers，记录每行读取数字个数即列数并存入数组cols，否则返回false，结束；\n\n4） 判断是否是方阵，若否，否则返回false，结束；\n\n5） 记录对角线数字之和，并比较是否相等，若否，否则返回false，结束；\n\n6） 判断每行每列数字之和是否都相等，若否，否则返回false，结束；\n\n7） 返回true，结束。\n\n结果：1.txt和2.txt矩阵以及生成的矩阵是MagicSquare，其余的不是。\n\n######  generateMagicSquare()\n\n按步骤给出你的设计和实现思路/过程/结果。\n\n设计思路流程图如下：\n\n   \n\n该方法生成MagicSquare，如果输入的参数为偶数，在循环过程中会出现数组下标越界，抛出java.lang.ArrayIndexOutOfBoundsException异常，如果输入参数为父，则开始建立大小为负的数组，会抛出java.lang.NegativeArraySizeException异常。\n\n#####  Turtle Graphics\n\n在这里简要概述你对该任务的理解。\n\n通过控制乌龟的转向和划线的距离完成图形的绘制，相当于整个图形由一笔完成，绘图过程中只要控制好划线的方向和转向即可。其中两个坐标间距离的只需要套用公式，但是计算转向还要考虑到当前乌龟的方向。\n\n######  Problem 1: Clone and import\n\n如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。\n\n由于无法连接MIT的didit服务器，所以只能从：<https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2>获取代码。\n\n打开git控制台，使用命令 git clone “[https://github.com/rainywang/Spring2019_HITCS_SC_Lab1](https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2).git”\n\n###### Problem 3: Turtle graphics and drawSquare\n\n​    首先，乌龟前行一段距离，即正方形的边长，然后转90，接着再爬行正方形的边长距离，转90度，爬行正方形的边长距离，转90度，最后爬行正方形的边长距离即可得到一个正方形。\n\n######  Problem 5: Drawing polygons\n\n​    首先，计算出该多边形的外角，然后乌龟爬行多边形的边长距离，接着进行（n-1）次下列循环（n为多边形边数）：转一个外角的度数，然后爬行一个多边形的边长距离。\n\n###### Problem 6: Calculating Bearings\n\n（1）calculateBearingToPoint（）：这个函数相对繁琐，因为需要分情况讨论，针对当前点和目的点的相对位置，分为横坐标相等、大于、小于三种情况，每种情况内又分别讨论纵坐标的相对情况，根据不同的相对位置关系，分别计算需要返回的转角度数。\n\n（2）calculateBearings（）：循环（n-1）次（n为所有点的个数）：调用calculateBearingToPoint（）方法，计算转角，其中角度为当前乌龟的角度；然后更新当前乌龟的角度，计算方法是：上一次乌龟的角度加上转角度数，如果结果度数大于360度，则减去360度即可。\n\n###### Problem 7: Convex Hulls\n\n​       如果点的个数小于4，则所有点都是要找的点，否则：\n\n1） 找到当前最左下的点为起始点和终结点，并加入结果集\n\n2） 执行如下循环，直到终结点等于起始点：\n\n​       计算当前点到其余每个点的转角度数，然后遍历，找出转角度数相同的点，如果转角度数相同的点不止一个，先将这些点加入temPoints集合，然后遍历该集合，找出距离当前点最远的那个点即为下一个要找的点，将其更新为当前点，并加入结果集。\n\n######  Problem 8: Personal art\n\n​       首先进行三次循环，每次划线距离60，转角120度，画出一个三角形；然后循环六次，每次划线120，转角60度，画出一个边长2倍的六边形；然后为了效果更佳美观，循环上述操作59次，每一遍循环转角62.11度，防止线的重合。\n\n   \n\n######  Submitting\n\n如何通过Git提交当前版本到GitHub上你的Lab1仓库。\n\n首先，将eclipse文件中的P2包复制更新到本地仓库，然后右键运行Git Bash here，依次输入下列三行命令：\n\ngit add .\n\ngit commit -m “lab1_P3”\n\ngit push origin master\n\n#####  Social Network\n\n在这里简要概述你对该任务的理解。\n\n将每个人看做一个点，有关系的人用线（有向或无向）连接，模拟社交网络。其中比较有难度的是两个人之间最短距离getDistance（）函数的编写，这里用到的广度优先算法，并在循环中记录每一层关系中人的个数以判断广搜的层数即距离。\n\n###### 设计/实现FriendshipGraph类\n\n给出你的设计和实现思路/过程/结果。\n\n首先定义ArrayList<ArrayList<Integer>>类型的可变长度的数组，用0和1来存储每个人之间的关系，也方便社交网络从无向图扩展到有向图，定义ArrayList<Person>类型的可变长度的数组来存储每个人。然后是各个函数的构造。\n\n###### 设计/实现Person类\n\n给出你的设计和实现思路/过程/结果。\n\n这里设计较为简单，只用名字来唯一标识每个人，然后设计了参数为name的默认构造方法，以及getName()和setName()方法。\n\n###### 设计/实现客户端代码main()\n\n给出你的设计和实现思路/过程/结果。\n\n首先，new 一个FriendshipGraph对象，接着new四个不同名字的Person并以此添加到FriendshipGraph网络社交图中，然后根据设计的社交网络图，调用addEdge（）方法添加有向边，最后调用getDistance函数计算并输出人与人之间的距离。\n\n###### 设计/实现测试用例\n\n给出你的设计和实现思路/过程/结果。\n\n测试用例为实验指导文档给出的测试用例，创建了四个姓名不同的Person对象，然后分别调用了addVertex(); addEdge() 和graph.getDistance()方法，结果测试完美通过。\n\n##### Tweet Tweet\n\n请自行组织子目录结构。\n\nEclipse中为方便测试，将Test.java文件一并放入了同一个包下，目录结构如下：\n\n   \n\n然后，各个函数完成后，在本地仓库下建立test文件夹，在该文件夹下建立P3文件夹，将所有的Test.java文件复制到该文件夹下，目录结构如下：\n\nsrc \n\n​       P3\n\n​              FriendshipGraph.java\n\n​              Person.java\n\ntest\n\n​       P3\n\n​              FriendshipGraphTest.java\n\n \n\n######  Problem 1: Extracting data from tweets\n\n（1）      getTimespan()：如果tweets为空，则返回null，结束，否则：\n\n​                     定义minTweet和maxTweet，初值均设置为第一个Tweet，然后遍历Tweet集合，得到每一个Tweet的Timestamp()，分别和minTweet、maxTweet比较，找出最早和最晚的Tweet；循环结束后，最晚的Tweet时间和最早Tweet时间跨度即为结果。\n\n（2）      getMentionedUsers():如果tweets为空，则返回null，结束，否则：\n\n​       建立Set\\<String>集合，遍历Tweet：得到每一条Tweet的text内容，然后根据正则表达式抽取其中符合要求的MentionedUsers，如果找到了这样的MentionedUsers，就放入set结果集；最终返回set结果集。\n\n \n\n######  Problem 2: Filtering lists of tweets\n\n（1）   writtenBy()：建立ArrayList\\<Tweet>结果集，然后遍历tweets：得到每一个Tweet的作者，将作者名和参数username进行比较，如果一致，则将该Tweet加入结果集；最终返回结果集。\n\n（2）   inTimespan()：建立List\\<Tweet>结果集，得到timespan的初始和结束时间，然后遍历tweets：得到每一个Tweet的instant，如果在timespan的初始和结束时间之间，则将该Tweet存入结果集；最终返回结果集。\n\n（3）   containing()：建立List\\<Tweet>结果集，如果tweets为空，则返回null，结束，否则：遍历tweets：得到每个Tweet的text，并将每个字符转化为小写字母，遍历List\\<String> words集合，如果text包含了words集合其中一个String，则将该Tweet加入结果集，并进行下一次外层循环；最终返回结果集。\n\n######   Problem 3: Inferring a social network\n\n（1）     guessFollowsGraph()：建立Map<String, Set\\<String>> 结果集和Set\\<String> followers集合，构造提取Follows的正则表达式，然后遍历tweets：建立new HashSet<>()存储followers，获取每个Tweet的text，然后用正则表达式进行匹配，如果有follower，就将其加入followers集合，匹配完成后，如果followers集合不为空，就将该Tweet的作者名和对应的followers集合加入map结果集；最终返回map结果集。\n\n（2）     influencers():建立Map<String, Integer> influenceMap，遍历followsGraph：将username先加入influenceMap，然后得到 该Tweet的followers集合并统计人数，最后将结果更新到influenceMap中；遍历完成后创建Comparator对象，遍历influenceMap根据每个tweet的followers人数比较影响力大小并排序，最后将排序结果加入结果集并返回即可。\n\n###### Problem 4: Get smarter\n\n这里判断每一个tweet用户的followers时除了直接添加@到的人之外，还根据Triadic closure原则和是否有Common hashtags添加followers。前者的判断是每次在循环内部增加一次循环搜索，后者主要是用正则表达式提取text里的hashtags，然后判断是否和当前tweet用户有相同的，如果有，则该tweet用户是当前tweet用户的follower。\n\n#### 实验进度记录\n\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n\n| 日期       | 时间段          | 任务                           | 实际完成情况       |\n| ---------- | --------------- | ------------------------------ | ------------------ |\n| 2019-02-26 | 14:00-18:32     | 完成整个P1和P2的Problem1-4     | 延期一个小时半完成 |\n| 2019-02-26 | 18:35-19：03    | 编写P2的Problem5               | 按计划完成         |\n| 2019-02-26 | 19:15-19:46     | 编写P2的Problem6               | 按计划完成         |\n| 2019-02-28 | 前天19:30-10:12 | 编写P3                         | 延期半天完成       |\n| 2019-02-28 | 19:20-20:48     | 编写P4的Problem1               | 按计划完成         |\n| 2019-03-02 | 10:00-14:40     | 编写P4、完善P2                 | 推迟一天完成       |\n| 2019-03-04 | 16:30-17:04     | Lab1代码的完善及个别方法的优化 | 按计划完成         |\n\n#### 实验过程中遇到的困难与解决途径\n\n| 遇到的难点                                              | 解决途径                                                     |\n| ------------------------------------------------------- | ------------------------------------------------------------ |\n| P1实验中测试文件的读取以及生成矩阵写入文件              | 采用相对项目根目录读取的方式，用new File(\"\").getCanonicalPath()获取项目的根目录，然后拼接src下具体文件路径 “/src/P1/txt/1.txt” |\n| P2 Convex Hulls中对凸包上同一条直线出现多个点情况的处理 | 如果出现最少角度的直线上出现多个点，则先将这些点加入一个暂存的集合，循环完毕，遍历该集合，找出该集合中这些点到当前点的距离最大的那个点，即为下一个要找的点。 |\n| P4中对每一个Tweet用户的求followers方法及其改进          | 首先提取text中符合要求的followers用户名需要使用正则表达式，由于之前没学习过正则表达式，所以在这里花了一晚上的时间先补充了这部分的知识；其次是求解followers方法的改进中，在根据Triadic closure原则添加用户时，需要在当前循环内再次遍历tweets集合，构建正则表达式，根据text的内容再次匹配。 |\n\n#### 实验过程中收获的经验、教训、感想\n\n##### 实验过程中收获的经验和教训\n\n利用一些工具如：Git、eclipse、Junit单元测试等能够显著的提高编程效率，熟悉工程的管理、了解Git的运作方式也至关重要。\n\n#####  针对以下方面的感受\n\n(1)  Java编程语言是否对你的口味？yes\n\n(2)  关于Eclipse IDE:\n\n自认为Eclipse 是一个比较上手的免费IDE，平时写java代码时基本都是使用的eclipse，所以相对来说，对eclipse的使用已经相对熟练。\n\n(3)  关于Git和GitHub\n\n​              之前没有使用过Git，对其还是相对陌生的，但是实验要求不高，只需要        掌握git的几个比较常用的命令即可；github平时接触过，但运用也不是             特别熟练，还需要课下勤于使用。\n\n(4)  关于CMU和MIT的作业\n\n​              由于已经有了java语言基础，所以这次实验感觉不是很难，方法的解决        思路也都基本清晰明了，只是个别问题的细节处理还需要注意。\n\n(5)  关于本实验的工作量、难度、deadline\n\n​              第一次实验的安排很合理，难度适合，时间充足。\n\n(6)  关于初接触“软件构造”课程\n\n​              对最近课程讲解的都是一些理论知识内容比较感兴趣，希望进一步学习        更多具体的相关知识。\n\n ","source":"_posts/软件构造实验一.md","raw":"---\ntitle: 软件构造实验一\ndate: 2019-04-18 14:05:48\ndescription: 个人觉得软件构造的实验还是挺不错的，非常有锻炼价值\ntags:\n - 软件构造\ncategories: 软件构造\n---\n\n\n#### 实验目标概述\n\n本次实验通过求解四个问题（其中一个可选），训练基本Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。\n\n- 基本的Java OO编程\n\n-  基于Eclipse IDE进行Java编程\n\n-  基于JUnit的测试\n\n-  基于Git的代码配置管理\n\n \n\n####  实验环境配置\n\n简要陈述你配置本次实验所需开发、测试、运行环境的过程，必要时可以给出屏幕截图。\n\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n\n1）从助教给的压缩包中下载eclipse并安装，在使用Eclipse进行Junit单元测试时先右键项目->Build Path->Add Library并选择junit，导入junit4。\n\n2）重新注册Git账号，并绑定Classroom建立自己的仓库，并将其clone到本地。\n\n3）P1的MagicSquare.java中的main方法读取txt包下的测试文件时读取不到，使用相对路径读取文件总是找不到文件，使用绝对路径会由于项目提交之后路径发生改变而出错。所以，读取目录即可采用相对项目根目录读取的方式，用new File(\"\").getCanonicalPath()获取项目的根目录，然后拼接字符串“/src/P1/txt/1.txt”即可获取src下P1包中 的txt文件夹下的1.txt测试文件。 \n\n在这里给出你的GitHub Lab1仓库的URL地址（Lab1-学号）。\n\n​       https://github.com/ComputerScienceHIT/Lab1-1170300503\n\n#### 实验过程\n\n请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。\n\n为了条理清晰，可根据需要在各节增加三级标题。\n\n#####  Magic Squares\n\n在这里简要概述你对该任务的理解。\n\n该实验是判断一个矩阵是否是由正整数组成的方阵，并且文件中数字存储用“\\t”划分，每行、每列及对角线数字之和均相等，如果是，则该矩阵是MagicSquare，否则不是。判断过程中，主要步骤是读取文件并分割字符串，判断输入是否合法，其次是对每行每列及对角线数字之和是否相等进行判断。\n\n###### isLegalMagicSquare()\n\n按步骤给出你的设计和实现思路/过程/结果。\n\n1） 根据参数filename判断文件是否存在，如果不存在，返回false，结束；\n\n2） 按行读取文件，记录读取行数；\n\n3） 读取的每行数据按照“\\t”分割，并判断分割后的每部分是否是数字，如果是数字，接着判断是否正整数，将每一个数字依次存入数组numbers，记录每行读取数字个数即列数并存入数组cols，否则返回false，结束；\n\n4） 判断是否是方阵，若否，否则返回false，结束；\n\n5） 记录对角线数字之和，并比较是否相等，若否，否则返回false，结束；\n\n6） 判断每行每列数字之和是否都相等，若否，否则返回false，结束；\n\n7） 返回true，结束。\n\n结果：1.txt和2.txt矩阵以及生成的矩阵是MagicSquare，其余的不是。\n\n######  generateMagicSquare()\n\n按步骤给出你的设计和实现思路/过程/结果。\n\n设计思路流程图如下：\n\n   \n\n该方法生成MagicSquare，如果输入的参数为偶数，在循环过程中会出现数组下标越界，抛出java.lang.ArrayIndexOutOfBoundsException异常，如果输入参数为父，则开始建立大小为负的数组，会抛出java.lang.NegativeArraySizeException异常。\n\n#####  Turtle Graphics\n\n在这里简要概述你对该任务的理解。\n\n通过控制乌龟的转向和划线的距离完成图形的绘制，相当于整个图形由一笔完成，绘图过程中只要控制好划线的方向和转向即可。其中两个坐标间距离的只需要套用公式，但是计算转向还要考虑到当前乌龟的方向。\n\n######  Problem 1: Clone and import\n\n如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。\n\n由于无法连接MIT的didit服务器，所以只能从：<https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2>获取代码。\n\n打开git控制台，使用命令 git clone “[https://github.com/rainywang/Spring2019_HITCS_SC_Lab1](https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2).git”\n\n###### Problem 3: Turtle graphics and drawSquare\n\n​    首先，乌龟前行一段距离，即正方形的边长，然后转90，接着再爬行正方形的边长距离，转90度，爬行正方形的边长距离，转90度，最后爬行正方形的边长距离即可得到一个正方形。\n\n######  Problem 5: Drawing polygons\n\n​    首先，计算出该多边形的外角，然后乌龟爬行多边形的边长距离，接着进行（n-1）次下列循环（n为多边形边数）：转一个外角的度数，然后爬行一个多边形的边长距离。\n\n###### Problem 6: Calculating Bearings\n\n（1）calculateBearingToPoint（）：这个函数相对繁琐，因为需要分情况讨论，针对当前点和目的点的相对位置，分为横坐标相等、大于、小于三种情况，每种情况内又分别讨论纵坐标的相对情况，根据不同的相对位置关系，分别计算需要返回的转角度数。\n\n（2）calculateBearings（）：循环（n-1）次（n为所有点的个数）：调用calculateBearingToPoint（）方法，计算转角，其中角度为当前乌龟的角度；然后更新当前乌龟的角度，计算方法是：上一次乌龟的角度加上转角度数，如果结果度数大于360度，则减去360度即可。\n\n###### Problem 7: Convex Hulls\n\n​       如果点的个数小于4，则所有点都是要找的点，否则：\n\n1） 找到当前最左下的点为起始点和终结点，并加入结果集\n\n2） 执行如下循环，直到终结点等于起始点：\n\n​       计算当前点到其余每个点的转角度数，然后遍历，找出转角度数相同的点，如果转角度数相同的点不止一个，先将这些点加入temPoints集合，然后遍历该集合，找出距离当前点最远的那个点即为下一个要找的点，将其更新为当前点，并加入结果集。\n\n######  Problem 8: Personal art\n\n​       首先进行三次循环，每次划线距离60，转角120度，画出一个三角形；然后循环六次，每次划线120，转角60度，画出一个边长2倍的六边形；然后为了效果更佳美观，循环上述操作59次，每一遍循环转角62.11度，防止线的重合。\n\n   \n\n######  Submitting\n\n如何通过Git提交当前版本到GitHub上你的Lab1仓库。\n\n首先，将eclipse文件中的P2包复制更新到本地仓库，然后右键运行Git Bash here，依次输入下列三行命令：\n\ngit add .\n\ngit commit -m “lab1_P3”\n\ngit push origin master\n\n#####  Social Network\n\n在这里简要概述你对该任务的理解。\n\n将每个人看做一个点，有关系的人用线（有向或无向）连接，模拟社交网络。其中比较有难度的是两个人之间最短距离getDistance（）函数的编写，这里用到的广度优先算法，并在循环中记录每一层关系中人的个数以判断广搜的层数即距离。\n\n###### 设计/实现FriendshipGraph类\n\n给出你的设计和实现思路/过程/结果。\n\n首先定义ArrayList<ArrayList<Integer>>类型的可变长度的数组，用0和1来存储每个人之间的关系，也方便社交网络从无向图扩展到有向图，定义ArrayList<Person>类型的可变长度的数组来存储每个人。然后是各个函数的构造。\n\n###### 设计/实现Person类\n\n给出你的设计和实现思路/过程/结果。\n\n这里设计较为简单，只用名字来唯一标识每个人，然后设计了参数为name的默认构造方法，以及getName()和setName()方法。\n\n###### 设计/实现客户端代码main()\n\n给出你的设计和实现思路/过程/结果。\n\n首先，new 一个FriendshipGraph对象，接着new四个不同名字的Person并以此添加到FriendshipGraph网络社交图中，然后根据设计的社交网络图，调用addEdge（）方法添加有向边，最后调用getDistance函数计算并输出人与人之间的距离。\n\n###### 设计/实现测试用例\n\n给出你的设计和实现思路/过程/结果。\n\n测试用例为实验指导文档给出的测试用例，创建了四个姓名不同的Person对象，然后分别调用了addVertex(); addEdge() 和graph.getDistance()方法，结果测试完美通过。\n\n##### Tweet Tweet\n\n请自行组织子目录结构。\n\nEclipse中为方便测试，将Test.java文件一并放入了同一个包下，目录结构如下：\n\n   \n\n然后，各个函数完成后，在本地仓库下建立test文件夹，在该文件夹下建立P3文件夹，将所有的Test.java文件复制到该文件夹下，目录结构如下：\n\nsrc \n\n​       P3\n\n​              FriendshipGraph.java\n\n​              Person.java\n\ntest\n\n​       P3\n\n​              FriendshipGraphTest.java\n\n \n\n######  Problem 1: Extracting data from tweets\n\n（1）      getTimespan()：如果tweets为空，则返回null，结束，否则：\n\n​                     定义minTweet和maxTweet，初值均设置为第一个Tweet，然后遍历Tweet集合，得到每一个Tweet的Timestamp()，分别和minTweet、maxTweet比较，找出最早和最晚的Tweet；循环结束后，最晚的Tweet时间和最早Tweet时间跨度即为结果。\n\n（2）      getMentionedUsers():如果tweets为空，则返回null，结束，否则：\n\n​       建立Set\\<String>集合，遍历Tweet：得到每一条Tweet的text内容，然后根据正则表达式抽取其中符合要求的MentionedUsers，如果找到了这样的MentionedUsers，就放入set结果集；最终返回set结果集。\n\n \n\n######  Problem 2: Filtering lists of tweets\n\n（1）   writtenBy()：建立ArrayList\\<Tweet>结果集，然后遍历tweets：得到每一个Tweet的作者，将作者名和参数username进行比较，如果一致，则将该Tweet加入结果集；最终返回结果集。\n\n（2）   inTimespan()：建立List\\<Tweet>结果集，得到timespan的初始和结束时间，然后遍历tweets：得到每一个Tweet的instant，如果在timespan的初始和结束时间之间，则将该Tweet存入结果集；最终返回结果集。\n\n（3）   containing()：建立List\\<Tweet>结果集，如果tweets为空，则返回null，结束，否则：遍历tweets：得到每个Tweet的text，并将每个字符转化为小写字母，遍历List\\<String> words集合，如果text包含了words集合其中一个String，则将该Tweet加入结果集，并进行下一次外层循环；最终返回结果集。\n\n######   Problem 3: Inferring a social network\n\n（1）     guessFollowsGraph()：建立Map<String, Set\\<String>> 结果集和Set\\<String> followers集合，构造提取Follows的正则表达式，然后遍历tweets：建立new HashSet<>()存储followers，获取每个Tweet的text，然后用正则表达式进行匹配，如果有follower，就将其加入followers集合，匹配完成后，如果followers集合不为空，就将该Tweet的作者名和对应的followers集合加入map结果集；最终返回map结果集。\n\n（2）     influencers():建立Map<String, Integer> influenceMap，遍历followsGraph：将username先加入influenceMap，然后得到 该Tweet的followers集合并统计人数，最后将结果更新到influenceMap中；遍历完成后创建Comparator对象，遍历influenceMap根据每个tweet的followers人数比较影响力大小并排序，最后将排序结果加入结果集并返回即可。\n\n###### Problem 4: Get smarter\n\n这里判断每一个tweet用户的followers时除了直接添加@到的人之外，还根据Triadic closure原则和是否有Common hashtags添加followers。前者的判断是每次在循环内部增加一次循环搜索，后者主要是用正则表达式提取text里的hashtags，然后判断是否和当前tweet用户有相同的，如果有，则该tweet用户是当前tweet用户的follower。\n\n#### 实验进度记录\n\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n\n| 日期       | 时间段          | 任务                           | 实际完成情况       |\n| ---------- | --------------- | ------------------------------ | ------------------ |\n| 2019-02-26 | 14:00-18:32     | 完成整个P1和P2的Problem1-4     | 延期一个小时半完成 |\n| 2019-02-26 | 18:35-19：03    | 编写P2的Problem5               | 按计划完成         |\n| 2019-02-26 | 19:15-19:46     | 编写P2的Problem6               | 按计划完成         |\n| 2019-02-28 | 前天19:30-10:12 | 编写P3                         | 延期半天完成       |\n| 2019-02-28 | 19:20-20:48     | 编写P4的Problem1               | 按计划完成         |\n| 2019-03-02 | 10:00-14:40     | 编写P4、完善P2                 | 推迟一天完成       |\n| 2019-03-04 | 16:30-17:04     | Lab1代码的完善及个别方法的优化 | 按计划完成         |\n\n#### 实验过程中遇到的困难与解决途径\n\n| 遇到的难点                                              | 解决途径                                                     |\n| ------------------------------------------------------- | ------------------------------------------------------------ |\n| P1实验中测试文件的读取以及生成矩阵写入文件              | 采用相对项目根目录读取的方式，用new File(\"\").getCanonicalPath()获取项目的根目录，然后拼接src下具体文件路径 “/src/P1/txt/1.txt” |\n| P2 Convex Hulls中对凸包上同一条直线出现多个点情况的处理 | 如果出现最少角度的直线上出现多个点，则先将这些点加入一个暂存的集合，循环完毕，遍历该集合，找出该集合中这些点到当前点的距离最大的那个点，即为下一个要找的点。 |\n| P4中对每一个Tweet用户的求followers方法及其改进          | 首先提取text中符合要求的followers用户名需要使用正则表达式，由于之前没学习过正则表达式，所以在这里花了一晚上的时间先补充了这部分的知识；其次是求解followers方法的改进中，在根据Triadic closure原则添加用户时，需要在当前循环内再次遍历tweets集合，构建正则表达式，根据text的内容再次匹配。 |\n\n#### 实验过程中收获的经验、教训、感想\n\n##### 实验过程中收获的经验和教训\n\n利用一些工具如：Git、eclipse、Junit单元测试等能够显著的提高编程效率，熟悉工程的管理、了解Git的运作方式也至关重要。\n\n#####  针对以下方面的感受\n\n(1)  Java编程语言是否对你的口味？yes\n\n(2)  关于Eclipse IDE:\n\n自认为Eclipse 是一个比较上手的免费IDE，平时写java代码时基本都是使用的eclipse，所以相对来说，对eclipse的使用已经相对熟练。\n\n(3)  关于Git和GitHub\n\n​              之前没有使用过Git，对其还是相对陌生的，但是实验要求不高，只需要        掌握git的几个比较常用的命令即可；github平时接触过，但运用也不是             特别熟练，还需要课下勤于使用。\n\n(4)  关于CMU和MIT的作业\n\n​              由于已经有了java语言基础，所以这次实验感觉不是很难，方法的解决        思路也都基本清晰明了，只是个别问题的细节处理还需要注意。\n\n(5)  关于本实验的工作量、难度、deadline\n\n​              第一次实验的安排很合理，难度适合，时间充足。\n\n(6)  关于初接触“软件构造”课程\n\n​              对最近课程讲解的都是一些理论知识内容比较感兴趣，希望进一步学习        更多具体的相关知识。\n\n ","slug":"软件构造实验一","published":1,"updated":"2019-05-17T08:38:06.538Z","_id":"cjvrtri55000rtku3jrhl2h8q","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"实验目标概述\"><a href=\"#实验目标概述\" class=\"headerlink\" title=\"实验目标概述\"></a>实验目标概述</h4><p>本次实验通过求解四个问题（其中一个可选），训练基本Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。</p>\n<ul>\n<li><p>基本的Java OO编程</p>\n</li>\n<li><p>基于Eclipse IDE进行Java编程</p>\n</li>\n<li><p>基于JUnit的测试</p>\n</li>\n<li><p>基于Git的代码配置管理</p>\n</li>\n</ul>\n<h4 id=\"实验环境配置\"><a href=\"#实验环境配置\" class=\"headerlink\" title=\"实验环境配置\"></a>实验环境配置</h4><p>简要陈述你配置本次实验所需开发、测试、运行环境的过程，必要时可以给出屏幕截图。</p>\n<p>特别是要记录配置过程中遇到的问题和困难，以及如何解决的。</p>\n<p>1）从助教给的压缩包中下载eclipse并安装，在使用Eclipse进行Junit单元测试时先右键项目-&gt;Build Path-&gt;Add Library并选择junit，导入junit4。</p>\n<p>2）重新注册Git账号，并绑定Classroom建立自己的仓库，并将其clone到本地。</p>\n<p>3）P1的MagicSquare.java中的main方法读取txt包下的测试文件时读取不到，使用相对路径读取文件总是找不到文件，使用绝对路径会由于项目提交之后路径发生改变而出错。所以，读取目录即可采用相对项目根目录读取的方式，用new File(“”).getCanonicalPath()获取项目的根目录，然后拼接字符串“/src/P1/txt/1.txt”即可获取src下P1包中 的txt文件夹下的1.txt测试文件。 </p>\n<p>在这里给出你的GitHub Lab1仓库的URL地址（Lab1-学号）。</p>\n<p>​       <a href=\"https://github.com/ComputerScienceHIT/Lab1-1170300503\" target=\"_blank\" rel=\"noopener\">https://github.com/ComputerScienceHIT/Lab1-1170300503</a></p>\n<h4 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h4><p>请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。</p>\n<p>为了条理清晰，可根据需要在各节增加三级标题。</p>\n<h5 id=\"Magic-Squares\"><a href=\"#Magic-Squares\" class=\"headerlink\" title=\"Magic Squares\"></a>Magic Squares</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>该实验是判断一个矩阵是否是由正整数组成的方阵，并且文件中数字存储用“\\t”划分，每行、每列及对角线数字之和均相等，如果是，则该矩阵是MagicSquare，否则不是。判断过程中，主要步骤是读取文件并分割字符串，判断输入是否合法，其次是对每行每列及对角线数字之和是否相等进行判断。</p>\n<h6 id=\"isLegalMagicSquare\"><a href=\"#isLegalMagicSquare\" class=\"headerlink\" title=\"isLegalMagicSquare()\"></a>isLegalMagicSquare()</h6><p>按步骤给出你的设计和实现思路/过程/结果。</p>\n<p>1） 根据参数filename判断文件是否存在，如果不存在，返回false，结束；</p>\n<p>2） 按行读取文件，记录读取行数；</p>\n<p>3） 读取的每行数据按照“\\t”分割，并判断分割后的每部分是否是数字，如果是数字，接着判断是否正整数，将每一个数字依次存入数组numbers，记录每行读取数字个数即列数并存入数组cols，否则返回false，结束；</p>\n<p>4） 判断是否是方阵，若否，否则返回false，结束；</p>\n<p>5） 记录对角线数字之和，并比较是否相等，若否，否则返回false，结束；</p>\n<p>6） 判断每行每列数字之和是否都相等，若否，否则返回false，结束；</p>\n<p>7） 返回true，结束。</p>\n<p>结果：1.txt和2.txt矩阵以及生成的矩阵是MagicSquare，其余的不是。</p>\n<h6 id=\"generateMagicSquare\"><a href=\"#generateMagicSquare\" class=\"headerlink\" title=\"generateMagicSquare()\"></a>generateMagicSquare()</h6><p>按步骤给出你的设计和实现思路/过程/结果。</p>\n<p>设计思路流程图如下：</p>\n<p>该方法生成MagicSquare，如果输入的参数为偶数，在循环过程中会出现数组下标越界，抛出java.lang.ArrayIndexOutOfBoundsException异常，如果输入参数为父，则开始建立大小为负的数组，会抛出java.lang.NegativeArraySizeException异常。</p>\n<h5 id=\"Turtle-Graphics\"><a href=\"#Turtle-Graphics\" class=\"headerlink\" title=\"Turtle Graphics\"></a>Turtle Graphics</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>通过控制乌龟的转向和划线的距离完成图形的绘制，相当于整个图形由一笔完成，绘图过程中只要控制好划线的方向和转向即可。其中两个坐标间距离的只需要套用公式，但是计算转向还要考虑到当前乌龟的方向。</p>\n<h6 id=\"Problem-1-Clone-and-import\"><a href=\"#Problem-1-Clone-and-import\" class=\"headerlink\" title=\"Problem 1: Clone and import\"></a>Problem 1: Clone and import</h6><p>如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。</p>\n<p>由于无法连接MIT的didit服务器，所以只能从：<a href=\"https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2\" target=\"_blank\" rel=\"noopener\">https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2</a>获取代码。</p>\n<p>打开git控制台，使用命令 git clone “<a href=\"https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2\" target=\"_blank\" rel=\"noopener\">https://github.com/rainywang/Spring2019_HITCS_SC_Lab1</a>.git”</p>\n<h6 id=\"Problem-3-Turtle-graphics-and-drawSquare\"><a href=\"#Problem-3-Turtle-graphics-and-drawSquare\" class=\"headerlink\" title=\"Problem 3: Turtle graphics and drawSquare\"></a>Problem 3: Turtle graphics and drawSquare</h6><p>​    首先，乌龟前行一段距离，即正方形的边长，然后转90，接着再爬行正方形的边长距离，转90度，爬行正方形的边长距离，转90度，最后爬行正方形的边长距离即可得到一个正方形。</p>\n<h6 id=\"Problem-5-Drawing-polygons\"><a href=\"#Problem-5-Drawing-polygons\" class=\"headerlink\" title=\"Problem 5: Drawing polygons\"></a>Problem 5: Drawing polygons</h6><p>​    首先，计算出该多边形的外角，然后乌龟爬行多边形的边长距离，接着进行（n-1）次下列循环（n为多边形边数）：转一个外角的度数，然后爬行一个多边形的边长距离。</p>\n<h6 id=\"Problem-6-Calculating-Bearings\"><a href=\"#Problem-6-Calculating-Bearings\" class=\"headerlink\" title=\"Problem 6: Calculating Bearings\"></a>Problem 6: Calculating Bearings</h6><p>（1）calculateBearingToPoint（）：这个函数相对繁琐，因为需要分情况讨论，针对当前点和目的点的相对位置，分为横坐标相等、大于、小于三种情况，每种情况内又分别讨论纵坐标的相对情况，根据不同的相对位置关系，分别计算需要返回的转角度数。</p>\n<p>（2）calculateBearings（）：循环（n-1）次（n为所有点的个数）：调用calculateBearingToPoint（）方法，计算转角，其中角度为当前乌龟的角度；然后更新当前乌龟的角度，计算方法是：上一次乌龟的角度加上转角度数，如果结果度数大于360度，则减去360度即可。</p>\n<h6 id=\"Problem-7-Convex-Hulls\"><a href=\"#Problem-7-Convex-Hulls\" class=\"headerlink\" title=\"Problem 7: Convex Hulls\"></a>Problem 7: Convex Hulls</h6><p>​       如果点的个数小于4，则所有点都是要找的点，否则：</p>\n<p>1） 找到当前最左下的点为起始点和终结点，并加入结果集</p>\n<p>2） 执行如下循环，直到终结点等于起始点：</p>\n<p>​       计算当前点到其余每个点的转角度数，然后遍历，找出转角度数相同的点，如果转角度数相同的点不止一个，先将这些点加入temPoints集合，然后遍历该集合，找出距离当前点最远的那个点即为下一个要找的点，将其更新为当前点，并加入结果集。</p>\n<h6 id=\"Problem-8-Personal-art\"><a href=\"#Problem-8-Personal-art\" class=\"headerlink\" title=\"Problem 8: Personal art\"></a>Problem 8: Personal art</h6><p>​       首先进行三次循环，每次划线距离60，转角120度，画出一个三角形；然后循环六次，每次划线120，转角60度，画出一个边长2倍的六边形；然后为了效果更佳美观，循环上述操作59次，每一遍循环转角62.11度，防止线的重合。</p>\n<h6 id=\"Submitting\"><a href=\"#Submitting\" class=\"headerlink\" title=\"Submitting\"></a>Submitting</h6><p>如何通过Git提交当前版本到GitHub上你的Lab1仓库。</p>\n<p>首先，将eclipse文件中的P2包复制更新到本地仓库，然后右键运行Git Bash here，依次输入下列三行命令：</p>\n<p>git add .</p>\n<p>git commit -m “lab1_P3”</p>\n<p>git push origin master</p>\n<h5 id=\"Social-Network\"><a href=\"#Social-Network\" class=\"headerlink\" title=\"Social Network\"></a>Social Network</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>将每个人看做一个点，有关系的人用线（有向或无向）连接，模拟社交网络。其中比较有难度的是两个人之间最短距离getDistance（）函数的编写，这里用到的广度优先算法，并在循环中记录每一层关系中人的个数以判断广搜的层数即距离。</p>\n<h6 id=\"设计-实现FriendshipGraph类\"><a href=\"#设计-实现FriendshipGraph类\" class=\"headerlink\" title=\"设计/实现FriendshipGraph类\"></a>设计/实现FriendshipGraph类</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>首先定义ArrayList&lt;ArrayList<integer>&gt;类型的可变长度的数组，用0和1来存储每个人之间的关系，也方便社交网络从无向图扩展到有向图，定义ArrayList<person>类型的可变长度的数组来存储每个人。然后是各个函数的构造。</person></integer></p>\n<h6 id=\"设计-实现Person类\"><a href=\"#设计-实现Person类\" class=\"headerlink\" title=\"设计/实现Person类\"></a>设计/实现Person类</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>这里设计较为简单，只用名字来唯一标识每个人，然后设计了参数为name的默认构造方法，以及getName()和setName()方法。</p>\n<h6 id=\"设计-实现客户端代码main\"><a href=\"#设计-实现客户端代码main\" class=\"headerlink\" title=\"设计/实现客户端代码main()\"></a>设计/实现客户端代码main()</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>首先，new 一个FriendshipGraph对象，接着new四个不同名字的Person并以此添加到FriendshipGraph网络社交图中，然后根据设计的社交网络图，调用addEdge（）方法添加有向边，最后调用getDistance函数计算并输出人与人之间的距离。</p>\n<h6 id=\"设计-实现测试用例\"><a href=\"#设计-实现测试用例\" class=\"headerlink\" title=\"设计/实现测试用例\"></a>设计/实现测试用例</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>测试用例为实验指导文档给出的测试用例，创建了四个姓名不同的Person对象，然后分别调用了addVertex(); addEdge() 和graph.getDistance()方法，结果测试完美通过。</p>\n<h5 id=\"Tweet-Tweet\"><a href=\"#Tweet-Tweet\" class=\"headerlink\" title=\"Tweet Tweet\"></a>Tweet Tweet</h5><p>请自行组织子目录结构。</p>\n<p>Eclipse中为方便测试，将Test.java文件一并放入了同一个包下，目录结构如下：</p>\n<p>然后，各个函数完成后，在本地仓库下建立test文件夹，在该文件夹下建立P3文件夹，将所有的Test.java文件复制到该文件夹下，目录结构如下：</p>\n<p>src </p>\n<p>​       P3</p>\n<p>​              FriendshipGraph.java</p>\n<p>​              Person.java</p>\n<p>test</p>\n<p>​       P3</p>\n<p>​              FriendshipGraphTest.java</p>\n<h6 id=\"Problem-1-Extracting-data-from-tweets\"><a href=\"#Problem-1-Extracting-data-from-tweets\" class=\"headerlink\" title=\"Problem 1: Extracting data from tweets\"></a>Problem 1: Extracting data from tweets</h6><p>（1）      getTimespan()：如果tweets为空，则返回null，结束，否则：</p>\n<p>​                     定义minTweet和maxTweet，初值均设置为第一个Tweet，然后遍历Tweet集合，得到每一个Tweet的Timestamp()，分别和minTweet、maxTweet比较，找出最早和最晚的Tweet；循环结束后，最晚的Tweet时间和最早Tweet时间跨度即为结果。</p>\n<p>（2）      getMentionedUsers():如果tweets为空，则返回null，结束，否则：</p>\n<p>​       建立Set\\<string>集合，遍历Tweet：得到每一条Tweet的text内容，然后根据正则表达式抽取其中符合要求的MentionedUsers，如果找到了这样的MentionedUsers，就放入set结果集；最终返回set结果集。</string></p>\n<h6 id=\"Problem-2-Filtering-lists-of-tweets\"><a href=\"#Problem-2-Filtering-lists-of-tweets\" class=\"headerlink\" title=\"Problem 2: Filtering lists of tweets\"></a>Problem 2: Filtering lists of tweets</h6><p>（1）   writtenBy()：建立ArrayList\\<tweet>结果集，然后遍历tweets：得到每一个Tweet的作者，将作者名和参数username进行比较，如果一致，则将该Tweet加入结果集；最终返回结果集。</tweet></p>\n<p>（2）   inTimespan()：建立List\\<tweet>结果集，得到timespan的初始和结束时间，然后遍历tweets：得到每一个Tweet的instant，如果在timespan的初始和结束时间之间，则将该Tweet存入结果集；最终返回结果集。</tweet></p>\n<p>（3）   containing()：建立List\\<tweet>结果集，如果tweets为空，则返回null，结束，否则：遍历tweets：得到每个Tweet的text，并将每个字符转化为小写字母，遍历List\\<string> words集合，如果text包含了words集合其中一个String，则将该Tweet加入结果集，并进行下一次外层循环；最终返回结果集。</string></tweet></p>\n<h6 id=\"Problem-3-Inferring-a-social-network\"><a href=\"#Problem-3-Inferring-a-social-network\" class=\"headerlink\" title=\"Problem 3: Inferring a social network\"></a>Problem 3: Inferring a social network</h6><p>（1）     guessFollowsGraph()：建立Map&lt;String, Set\\<string>&gt; 结果集和Set\\<string> followers集合，构造提取Follows的正则表达式，然后遍历tweets：建立new HashSet&lt;&gt;()存储followers，获取每个Tweet的text，然后用正则表达式进行匹配，如果有follower，就将其加入followers集合，匹配完成后，如果followers集合不为空，就将该Tweet的作者名和对应的followers集合加入map结果集；最终返回map结果集。</string></string></p>\n<p>（2）     influencers():建立Map&lt;String, Integer&gt; influenceMap，遍历followsGraph：将username先加入influenceMap，然后得到 该Tweet的followers集合并统计人数，最后将结果更新到influenceMap中；遍历完成后创建Comparator对象，遍历influenceMap根据每个tweet的followers人数比较影响力大小并排序，最后将排序结果加入结果集并返回即可。</p>\n<h6 id=\"Problem-4-Get-smarter\"><a href=\"#Problem-4-Get-smarter\" class=\"headerlink\" title=\"Problem 4: Get smarter\"></a>Problem 4: Get smarter</h6><p>这里判断每一个tweet用户的followers时除了直接添加@到的人之外，还根据Triadic closure原则和是否有Common hashtags添加followers。前者的判断是每次在循环内部增加一次循环搜索，后者主要是用正则表达式提取text里的hashtags，然后判断是否和当前tweet用户有相同的，如果有，则该tweet用户是当前tweet用户的follower。</p>\n<h4 id=\"实验进度记录\"><a href=\"#实验进度记录\" class=\"headerlink\" title=\"实验进度记录\"></a>实验进度记录</h4><p>请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。</p>\n<table>\n<thead>\n<tr>\n<th>日期</th>\n<th>时间段</th>\n<th>任务</th>\n<th>实际完成情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2019-02-26</td>\n<td>14:00-18:32</td>\n<td>完成整个P1和P2的Problem1-4</td>\n<td>延期一个小时半完成</td>\n</tr>\n<tr>\n<td>2019-02-26</td>\n<td>18:35-19：03</td>\n<td>编写P2的Problem5</td>\n<td>按计划完成</td>\n</tr>\n<tr>\n<td>2019-02-26</td>\n<td>19:15-19:46</td>\n<td>编写P2的Problem6</td>\n<td>按计划完成</td>\n</tr>\n<tr>\n<td>2019-02-28</td>\n<td>前天19:30-10:12</td>\n<td>编写P3</td>\n<td>延期半天完成</td>\n</tr>\n<tr>\n<td>2019-02-28</td>\n<td>19:20-20:48</td>\n<td>编写P4的Problem1</td>\n<td>按计划完成</td>\n</tr>\n<tr>\n<td>2019-03-02</td>\n<td>10:00-14:40</td>\n<td>编写P4、完善P2</td>\n<td>推迟一天完成</td>\n</tr>\n<tr>\n<td>2019-03-04</td>\n<td>16:30-17:04</td>\n<td>Lab1代码的完善及个别方法的优化</td>\n<td>按计划完成</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验过程中遇到的困难与解决途径\"><a href=\"#实验过程中遇到的困难与解决途径\" class=\"headerlink\" title=\"实验过程中遇到的困难与解决途径\"></a>实验过程中遇到的困难与解决途径</h4><table>\n<thead>\n<tr>\n<th>遇到的难点</th>\n<th>解决途径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>P1实验中测试文件的读取以及生成矩阵写入文件</td>\n<td>采用相对项目根目录读取的方式，用new File(“”).getCanonicalPath()获取项目的根目录，然后拼接src下具体文件路径 “/src/P1/txt/1.txt”</td>\n</tr>\n<tr>\n<td>P2 Convex Hulls中对凸包上同一条直线出现多个点情况的处理</td>\n<td>如果出现最少角度的直线上出现多个点，则先将这些点加入一个暂存的集合，循环完毕，遍历该集合，找出该集合中这些点到当前点的距离最大的那个点，即为下一个要找的点。</td>\n</tr>\n<tr>\n<td>P4中对每一个Tweet用户的求followers方法及其改进</td>\n<td>首先提取text中符合要求的followers用户名需要使用正则表达式，由于之前没学习过正则表达式，所以在这里花了一晚上的时间先补充了这部分的知识；其次是求解followers方法的改进中，在根据Triadic closure原则添加用户时，需要在当前循环内再次遍历tweets集合，构建正则表达式，根据text的内容再次匹配。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验过程中收获的经验、教训、感想\"><a href=\"#实验过程中收获的经验、教训、感想\" class=\"headerlink\" title=\"实验过程中收获的经验、教训、感想\"></a>实验过程中收获的经验、教训、感想</h4><h5 id=\"实验过程中收获的经验和教训\"><a href=\"#实验过程中收获的经验和教训\" class=\"headerlink\" title=\"实验过程中收获的经验和教训\"></a>实验过程中收获的经验和教训</h5><p>利用一些工具如：Git、eclipse、Junit单元测试等能够显著的提高编程效率，熟悉工程的管理、了解Git的运作方式也至关重要。</p>\n<h5 id=\"针对以下方面的感受\"><a href=\"#针对以下方面的感受\" class=\"headerlink\" title=\"针对以下方面的感受\"></a>针对以下方面的感受</h5><p>(1)  Java编程语言是否对你的口味？yes</p>\n<p>(2)  关于Eclipse IDE:</p>\n<p>自认为Eclipse 是一个比较上手的免费IDE，平时写java代码时基本都是使用的eclipse，所以相对来说，对eclipse的使用已经相对熟练。</p>\n<p>(3)  关于Git和GitHub</p>\n<p>​              之前没有使用过Git，对其还是相对陌生的，但是实验要求不高，只需要        掌握git的几个比较常用的命令即可；github平时接触过，但运用也不是             特别熟练，还需要课下勤于使用。</p>\n<p>(4)  关于CMU和MIT的作业</p>\n<p>​              由于已经有了java语言基础，所以这次实验感觉不是很难，方法的解决        思路也都基本清晰明了，只是个别问题的细节处理还需要注意。</p>\n<p>(5)  关于本实验的工作量、难度、deadline</p>\n<p>​              第一次实验的安排很合理，难度适合，时间充足。</p>\n<p>(6)  关于初接触“软件构造”课程</p>\n<p>​              对最近课程讲解的都是一些理论知识内容比较感兴趣，希望进一步学习        更多具体的相关知识。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"实验目标概述\"><a href=\"#实验目标概述\" class=\"headerlink\" title=\"实验目标概述\"></a>实验目标概述</h4><p>本次实验通过求解四个问题（其中一个可选），训练基本Java编程技能，能够利用Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用Git作为代码配置管理的工具，学会Git的基本使用方法。</p>\n<ul>\n<li><p>基本的Java OO编程</p>\n</li>\n<li><p>基于Eclipse IDE进行Java编程</p>\n</li>\n<li><p>基于JUnit的测试</p>\n</li>\n<li><p>基于Git的代码配置管理</p>\n</li>\n</ul>\n<h4 id=\"实验环境配置\"><a href=\"#实验环境配置\" class=\"headerlink\" title=\"实验环境配置\"></a>实验环境配置</h4><p>简要陈述你配置本次实验所需开发、测试、运行环境的过程，必要时可以给出屏幕截图。</p>\n<p>特别是要记录配置过程中遇到的问题和困难，以及如何解决的。</p>\n<p>1）从助教给的压缩包中下载eclipse并安装，在使用Eclipse进行Junit单元测试时先右键项目-&gt;Build Path-&gt;Add Library并选择junit，导入junit4。</p>\n<p>2）重新注册Git账号，并绑定Classroom建立自己的仓库，并将其clone到本地。</p>\n<p>3）P1的MagicSquare.java中的main方法读取txt包下的测试文件时读取不到，使用相对路径读取文件总是找不到文件，使用绝对路径会由于项目提交之后路径发生改变而出错。所以，读取目录即可采用相对项目根目录读取的方式，用new File(“”).getCanonicalPath()获取项目的根目录，然后拼接字符串“/src/P1/txt/1.txt”即可获取src下P1包中 的txt文件夹下的1.txt测试文件。 </p>\n<p>在这里给出你的GitHub Lab1仓库的URL地址（Lab1-学号）。</p>\n<p>​       <a href=\"https://github.com/ComputerScienceHIT/Lab1-1170300503\" target=\"_blank\" rel=\"noopener\">https://github.com/ComputerScienceHIT/Lab1-1170300503</a></p>\n<h4 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h4><p>请仔细对照实验手册，针对四个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但无需把你的源代码全部粘贴过来！）。</p>\n<p>为了条理清晰，可根据需要在各节增加三级标题。</p>\n<h5 id=\"Magic-Squares\"><a href=\"#Magic-Squares\" class=\"headerlink\" title=\"Magic Squares\"></a>Magic Squares</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>该实验是判断一个矩阵是否是由正整数组成的方阵，并且文件中数字存储用“\\t”划分，每行、每列及对角线数字之和均相等，如果是，则该矩阵是MagicSquare，否则不是。判断过程中，主要步骤是读取文件并分割字符串，判断输入是否合法，其次是对每行每列及对角线数字之和是否相等进行判断。</p>\n<h6 id=\"isLegalMagicSquare\"><a href=\"#isLegalMagicSquare\" class=\"headerlink\" title=\"isLegalMagicSquare()\"></a>isLegalMagicSquare()</h6><p>按步骤给出你的设计和实现思路/过程/结果。</p>\n<p>1） 根据参数filename判断文件是否存在，如果不存在，返回false，结束；</p>\n<p>2） 按行读取文件，记录读取行数；</p>\n<p>3） 读取的每行数据按照“\\t”分割，并判断分割后的每部分是否是数字，如果是数字，接着判断是否正整数，将每一个数字依次存入数组numbers，记录每行读取数字个数即列数并存入数组cols，否则返回false，结束；</p>\n<p>4） 判断是否是方阵，若否，否则返回false，结束；</p>\n<p>5） 记录对角线数字之和，并比较是否相等，若否，否则返回false，结束；</p>\n<p>6） 判断每行每列数字之和是否都相等，若否，否则返回false，结束；</p>\n<p>7） 返回true，结束。</p>\n<p>结果：1.txt和2.txt矩阵以及生成的矩阵是MagicSquare，其余的不是。</p>\n<h6 id=\"generateMagicSquare\"><a href=\"#generateMagicSquare\" class=\"headerlink\" title=\"generateMagicSquare()\"></a>generateMagicSquare()</h6><p>按步骤给出你的设计和实现思路/过程/结果。</p>\n<p>设计思路流程图如下：</p>\n<p>该方法生成MagicSquare，如果输入的参数为偶数，在循环过程中会出现数组下标越界，抛出java.lang.ArrayIndexOutOfBoundsException异常，如果输入参数为父，则开始建立大小为负的数组，会抛出java.lang.NegativeArraySizeException异常。</p>\n<h5 id=\"Turtle-Graphics\"><a href=\"#Turtle-Graphics\" class=\"headerlink\" title=\"Turtle Graphics\"></a>Turtle Graphics</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>通过控制乌龟的转向和划线的距离完成图形的绘制，相当于整个图形由一笔完成，绘图过程中只要控制好划线的方向和转向即可。其中两个坐标间距离的只需要套用公式，但是计算转向还要考虑到当前乌龟的方向。</p>\n<h6 id=\"Problem-1-Clone-and-import\"><a href=\"#Problem-1-Clone-and-import\" class=\"headerlink\" title=\"Problem 1: Clone and import\"></a>Problem 1: Clone and import</h6><p>如何从GitHub获取该任务的代码、在本地创建git仓库、使用git管理本地开发。</p>\n<p>由于无法连接MIT的didit服务器，所以只能从：<a href=\"https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2\" target=\"_blank\" rel=\"noopener\">https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2</a>获取代码。</p>\n<p>打开git控制台，使用命令 git clone “<a href=\"https://github.com/rainywang/Spring2019_HITCS_SC_Lab1/tree/master/P2\" target=\"_blank\" rel=\"noopener\">https://github.com/rainywang/Spring2019_HITCS_SC_Lab1</a>.git”</p>\n<h6 id=\"Problem-3-Turtle-graphics-and-drawSquare\"><a href=\"#Problem-3-Turtle-graphics-and-drawSquare\" class=\"headerlink\" title=\"Problem 3: Turtle graphics and drawSquare\"></a>Problem 3: Turtle graphics and drawSquare</h6><p>​    首先，乌龟前行一段距离，即正方形的边长，然后转90，接着再爬行正方形的边长距离，转90度，爬行正方形的边长距离，转90度，最后爬行正方形的边长距离即可得到一个正方形。</p>\n<h6 id=\"Problem-5-Drawing-polygons\"><a href=\"#Problem-5-Drawing-polygons\" class=\"headerlink\" title=\"Problem 5: Drawing polygons\"></a>Problem 5: Drawing polygons</h6><p>​    首先，计算出该多边形的外角，然后乌龟爬行多边形的边长距离，接着进行（n-1）次下列循环（n为多边形边数）：转一个外角的度数，然后爬行一个多边形的边长距离。</p>\n<h6 id=\"Problem-6-Calculating-Bearings\"><a href=\"#Problem-6-Calculating-Bearings\" class=\"headerlink\" title=\"Problem 6: Calculating Bearings\"></a>Problem 6: Calculating Bearings</h6><p>（1）calculateBearingToPoint（）：这个函数相对繁琐，因为需要分情况讨论，针对当前点和目的点的相对位置，分为横坐标相等、大于、小于三种情况，每种情况内又分别讨论纵坐标的相对情况，根据不同的相对位置关系，分别计算需要返回的转角度数。</p>\n<p>（2）calculateBearings（）：循环（n-1）次（n为所有点的个数）：调用calculateBearingToPoint（）方法，计算转角，其中角度为当前乌龟的角度；然后更新当前乌龟的角度，计算方法是：上一次乌龟的角度加上转角度数，如果结果度数大于360度，则减去360度即可。</p>\n<h6 id=\"Problem-7-Convex-Hulls\"><a href=\"#Problem-7-Convex-Hulls\" class=\"headerlink\" title=\"Problem 7: Convex Hulls\"></a>Problem 7: Convex Hulls</h6><p>​       如果点的个数小于4，则所有点都是要找的点，否则：</p>\n<p>1） 找到当前最左下的点为起始点和终结点，并加入结果集</p>\n<p>2） 执行如下循环，直到终结点等于起始点：</p>\n<p>​       计算当前点到其余每个点的转角度数，然后遍历，找出转角度数相同的点，如果转角度数相同的点不止一个，先将这些点加入temPoints集合，然后遍历该集合，找出距离当前点最远的那个点即为下一个要找的点，将其更新为当前点，并加入结果集。</p>\n<h6 id=\"Problem-8-Personal-art\"><a href=\"#Problem-8-Personal-art\" class=\"headerlink\" title=\"Problem 8: Personal art\"></a>Problem 8: Personal art</h6><p>​       首先进行三次循环，每次划线距离60，转角120度，画出一个三角形；然后循环六次，每次划线120，转角60度，画出一个边长2倍的六边形；然后为了效果更佳美观，循环上述操作59次，每一遍循环转角62.11度，防止线的重合。</p>\n<h6 id=\"Submitting\"><a href=\"#Submitting\" class=\"headerlink\" title=\"Submitting\"></a>Submitting</h6><p>如何通过Git提交当前版本到GitHub上你的Lab1仓库。</p>\n<p>首先，将eclipse文件中的P2包复制更新到本地仓库，然后右键运行Git Bash here，依次输入下列三行命令：</p>\n<p>git add .</p>\n<p>git commit -m “lab1_P3”</p>\n<p>git push origin master</p>\n<h5 id=\"Social-Network\"><a href=\"#Social-Network\" class=\"headerlink\" title=\"Social Network\"></a>Social Network</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>将每个人看做一个点，有关系的人用线（有向或无向）连接，模拟社交网络。其中比较有难度的是两个人之间最短距离getDistance（）函数的编写，这里用到的广度优先算法，并在循环中记录每一层关系中人的个数以判断广搜的层数即距离。</p>\n<h6 id=\"设计-实现FriendshipGraph类\"><a href=\"#设计-实现FriendshipGraph类\" class=\"headerlink\" title=\"设计/实现FriendshipGraph类\"></a>设计/实现FriendshipGraph类</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>首先定义ArrayList&lt;ArrayList<integer>&gt;类型的可变长度的数组，用0和1来存储每个人之间的关系，也方便社交网络从无向图扩展到有向图，定义ArrayList<person>类型的可变长度的数组来存储每个人。然后是各个函数的构造。</person></integer></p>\n<h6 id=\"设计-实现Person类\"><a href=\"#设计-实现Person类\" class=\"headerlink\" title=\"设计/实现Person类\"></a>设计/实现Person类</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>这里设计较为简单，只用名字来唯一标识每个人，然后设计了参数为name的默认构造方法，以及getName()和setName()方法。</p>\n<h6 id=\"设计-实现客户端代码main\"><a href=\"#设计-实现客户端代码main\" class=\"headerlink\" title=\"设计/实现客户端代码main()\"></a>设计/实现客户端代码main()</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>首先，new 一个FriendshipGraph对象，接着new四个不同名字的Person并以此添加到FriendshipGraph网络社交图中，然后根据设计的社交网络图，调用addEdge（）方法添加有向边，最后调用getDistance函数计算并输出人与人之间的距离。</p>\n<h6 id=\"设计-实现测试用例\"><a href=\"#设计-实现测试用例\" class=\"headerlink\" title=\"设计/实现测试用例\"></a>设计/实现测试用例</h6><p>给出你的设计和实现思路/过程/结果。</p>\n<p>测试用例为实验指导文档给出的测试用例，创建了四个姓名不同的Person对象，然后分别调用了addVertex(); addEdge() 和graph.getDistance()方法，结果测试完美通过。</p>\n<h5 id=\"Tweet-Tweet\"><a href=\"#Tweet-Tweet\" class=\"headerlink\" title=\"Tweet Tweet\"></a>Tweet Tweet</h5><p>请自行组织子目录结构。</p>\n<p>Eclipse中为方便测试，将Test.java文件一并放入了同一个包下，目录结构如下：</p>\n<p>然后，各个函数完成后，在本地仓库下建立test文件夹，在该文件夹下建立P3文件夹，将所有的Test.java文件复制到该文件夹下，目录结构如下：</p>\n<p>src </p>\n<p>​       P3</p>\n<p>​              FriendshipGraph.java</p>\n<p>​              Person.java</p>\n<p>test</p>\n<p>​       P3</p>\n<p>​              FriendshipGraphTest.java</p>\n<h6 id=\"Problem-1-Extracting-data-from-tweets\"><a href=\"#Problem-1-Extracting-data-from-tweets\" class=\"headerlink\" title=\"Problem 1: Extracting data from tweets\"></a>Problem 1: Extracting data from tweets</h6><p>（1）      getTimespan()：如果tweets为空，则返回null，结束，否则：</p>\n<p>​                     定义minTweet和maxTweet，初值均设置为第一个Tweet，然后遍历Tweet集合，得到每一个Tweet的Timestamp()，分别和minTweet、maxTweet比较，找出最早和最晚的Tweet；循环结束后，最晚的Tweet时间和最早Tweet时间跨度即为结果。</p>\n<p>（2）      getMentionedUsers():如果tweets为空，则返回null，结束，否则：</p>\n<p>​       建立Set\\<string>集合，遍历Tweet：得到每一条Tweet的text内容，然后根据正则表达式抽取其中符合要求的MentionedUsers，如果找到了这样的MentionedUsers，就放入set结果集；最终返回set结果集。</string></p>\n<h6 id=\"Problem-2-Filtering-lists-of-tweets\"><a href=\"#Problem-2-Filtering-lists-of-tweets\" class=\"headerlink\" title=\"Problem 2: Filtering lists of tweets\"></a>Problem 2: Filtering lists of tweets</h6><p>（1）   writtenBy()：建立ArrayList\\<tweet>结果集，然后遍历tweets：得到每一个Tweet的作者，将作者名和参数username进行比较，如果一致，则将该Tweet加入结果集；最终返回结果集。</tweet></p>\n<p>（2）   inTimespan()：建立List\\<tweet>结果集，得到timespan的初始和结束时间，然后遍历tweets：得到每一个Tweet的instant，如果在timespan的初始和结束时间之间，则将该Tweet存入结果集；最终返回结果集。</tweet></p>\n<p>（3）   containing()：建立List\\<tweet>结果集，如果tweets为空，则返回null，结束，否则：遍历tweets：得到每个Tweet的text，并将每个字符转化为小写字母，遍历List\\<string> words集合，如果text包含了words集合其中一个String，则将该Tweet加入结果集，并进行下一次外层循环；最终返回结果集。</string></tweet></p>\n<h6 id=\"Problem-3-Inferring-a-social-network\"><a href=\"#Problem-3-Inferring-a-social-network\" class=\"headerlink\" title=\"Problem 3: Inferring a social network\"></a>Problem 3: Inferring a social network</h6><p>（1）     guessFollowsGraph()：建立Map&lt;String, Set\\<string>&gt; 结果集和Set\\<string> followers集合，构造提取Follows的正则表达式，然后遍历tweets：建立new HashSet&lt;&gt;()存储followers，获取每个Tweet的text，然后用正则表达式进行匹配，如果有follower，就将其加入followers集合，匹配完成后，如果followers集合不为空，就将该Tweet的作者名和对应的followers集合加入map结果集；最终返回map结果集。</string></string></p>\n<p>（2）     influencers():建立Map&lt;String, Integer&gt; influenceMap，遍历followsGraph：将username先加入influenceMap，然后得到 该Tweet的followers集合并统计人数，最后将结果更新到influenceMap中；遍历完成后创建Comparator对象，遍历influenceMap根据每个tweet的followers人数比较影响力大小并排序，最后将排序结果加入结果集并返回即可。</p>\n<h6 id=\"Problem-4-Get-smarter\"><a href=\"#Problem-4-Get-smarter\" class=\"headerlink\" title=\"Problem 4: Get smarter\"></a>Problem 4: Get smarter</h6><p>这里判断每一个tweet用户的followers时除了直接添加@到的人之外，还根据Triadic closure原则和是否有Common hashtags添加followers。前者的判断是每次在循环内部增加一次循环搜索，后者主要是用正则表达式提取text里的hashtags，然后判断是否和当前tweet用户有相同的，如果有，则该tweet用户是当前tweet用户的follower。</p>\n<h4 id=\"实验进度记录\"><a href=\"#实验进度记录\" class=\"headerlink\" title=\"实验进度记录\"></a>实验进度记录</h4><p>请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。</p>\n<table>\n<thead>\n<tr>\n<th>日期</th>\n<th>时间段</th>\n<th>任务</th>\n<th>实际完成情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2019-02-26</td>\n<td>14:00-18:32</td>\n<td>完成整个P1和P2的Problem1-4</td>\n<td>延期一个小时半完成</td>\n</tr>\n<tr>\n<td>2019-02-26</td>\n<td>18:35-19：03</td>\n<td>编写P2的Problem5</td>\n<td>按计划完成</td>\n</tr>\n<tr>\n<td>2019-02-26</td>\n<td>19:15-19:46</td>\n<td>编写P2的Problem6</td>\n<td>按计划完成</td>\n</tr>\n<tr>\n<td>2019-02-28</td>\n<td>前天19:30-10:12</td>\n<td>编写P3</td>\n<td>延期半天完成</td>\n</tr>\n<tr>\n<td>2019-02-28</td>\n<td>19:20-20:48</td>\n<td>编写P4的Problem1</td>\n<td>按计划完成</td>\n</tr>\n<tr>\n<td>2019-03-02</td>\n<td>10:00-14:40</td>\n<td>编写P4、完善P2</td>\n<td>推迟一天完成</td>\n</tr>\n<tr>\n<td>2019-03-04</td>\n<td>16:30-17:04</td>\n<td>Lab1代码的完善及个别方法的优化</td>\n<td>按计划完成</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验过程中遇到的困难与解决途径\"><a href=\"#实验过程中遇到的困难与解决途径\" class=\"headerlink\" title=\"实验过程中遇到的困难与解决途径\"></a>实验过程中遇到的困难与解决途径</h4><table>\n<thead>\n<tr>\n<th>遇到的难点</th>\n<th>解决途径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>P1实验中测试文件的读取以及生成矩阵写入文件</td>\n<td>采用相对项目根目录读取的方式，用new File(“”).getCanonicalPath()获取项目的根目录，然后拼接src下具体文件路径 “/src/P1/txt/1.txt”</td>\n</tr>\n<tr>\n<td>P2 Convex Hulls中对凸包上同一条直线出现多个点情况的处理</td>\n<td>如果出现最少角度的直线上出现多个点，则先将这些点加入一个暂存的集合，循环完毕，遍历该集合，找出该集合中这些点到当前点的距离最大的那个点，即为下一个要找的点。</td>\n</tr>\n<tr>\n<td>P4中对每一个Tweet用户的求followers方法及其改进</td>\n<td>首先提取text中符合要求的followers用户名需要使用正则表达式，由于之前没学习过正则表达式，所以在这里花了一晚上的时间先补充了这部分的知识；其次是求解followers方法的改进中，在根据Triadic closure原则添加用户时，需要在当前循环内再次遍历tweets集合，构建正则表达式，根据text的内容再次匹配。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验过程中收获的经验、教训、感想\"><a href=\"#实验过程中收获的经验、教训、感想\" class=\"headerlink\" title=\"实验过程中收获的经验、教训、感想\"></a>实验过程中收获的经验、教训、感想</h4><h5 id=\"实验过程中收获的经验和教训\"><a href=\"#实验过程中收获的经验和教训\" class=\"headerlink\" title=\"实验过程中收获的经验和教训\"></a>实验过程中收获的经验和教训</h5><p>利用一些工具如：Git、eclipse、Junit单元测试等能够显著的提高编程效率，熟悉工程的管理、了解Git的运作方式也至关重要。</p>\n<h5 id=\"针对以下方面的感受\"><a href=\"#针对以下方面的感受\" class=\"headerlink\" title=\"针对以下方面的感受\"></a>针对以下方面的感受</h5><p>(1)  Java编程语言是否对你的口味？yes</p>\n<p>(2)  关于Eclipse IDE:</p>\n<p>自认为Eclipse 是一个比较上手的免费IDE，平时写java代码时基本都是使用的eclipse，所以相对来说，对eclipse的使用已经相对熟练。</p>\n<p>(3)  关于Git和GitHub</p>\n<p>​              之前没有使用过Git，对其还是相对陌生的，但是实验要求不高，只需要        掌握git的几个比较常用的命令即可；github平时接触过，但运用也不是             特别熟练，还需要课下勤于使用。</p>\n<p>(4)  关于CMU和MIT的作业</p>\n<p>​              由于已经有了java语言基础，所以这次实验感觉不是很难，方法的解决        思路也都基本清晰明了，只是个别问题的细节处理还需要注意。</p>\n<p>(5)  关于本实验的工作量、难度、deadline</p>\n<p>​              第一次实验的安排很合理，难度适合，时间充足。</p>\n<p>(6)  关于初接触“软件构造”课程</p>\n<p>​              对最近课程讲解的都是一些理论知识内容比较感兴趣，希望进一步学习        更多具体的相关知识。</p>\n"},{"title":"哈尔滨工业大学计算机系统2018年秋期末复习","urlname":"hit_data_structure_review","mathjax":true,"description":"一直想拥有一个自己的博客，但是却一拖再拖，始终没有推送一篇博文，仅以此篇--哈尔滨工业大学计算机系统的复习提纲，仅为期末复习所准备，慰藉以往无bolg的时光。","abbrlink":22353,"date":"2019-03-05T06:00:00.000Z","_content":"\n\n- 计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小\n\n- ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件\n\n- 核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。\n\n- 存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存\n\n- 操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 \n\n### 信息的表示和处理\n\n#### 信息存储\n\n- 信息：\n\n```\n数值：值   小数点  符号（三要素）\n\n非数值：文字 图像 视频 语言\n```\n\n- 软件：\n\n  ```\n  系统软件：（用来管理整个计算机系统）\n  \n  语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件\n  ```\n\n- 计算机系统的层次结构：\n\n| 高级语言          | 虚拟机器M3   |\n| ----------------- | ------------ |\n| 汇编语言          | 虚拟机器M2   |\n| 操作系统          | 虚拟机器     |\n| 机器语言          | 实际机器M1   |\n| 微指令语言（时间) | 微程序机器M0 |\n- 机器数（码）：原码 反码 移码  补码\n\n- 数的逻辑：逻辑   算术（+ - * /） c语言中的数\n\n- 逻辑运算符&&和||与对应的位级运算符&和|第二个区别：\n\n  如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&&5/a不会造成被零除，p&&*p++不会导致间接引用空指针 \n\n- 集合的表示与运算\n\n  - 表示：位向量表示有限集合\n\n```\neg：10100110   从右到左表示 该集合={1，2，5，7}\n```\n\n- 运算：& 交集     |  并集    ^  对称差集    ~  补集                  \n\n- 左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x>>k表示x算术右移k个位置，x>>>k表示逻辑右移\n\n#### 整数表示\n\n##### 整数编码\n\n有符号数：补码\n\nB2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$\n\n例：\n\n|      | 10进制 | 16进制 | 2进制                             |\n| ---- | ------ | ------ | --------------------------------- |\n| X    | 15213  | 3B 6D  | 0011011 01101101                  |\n| Y    | -15213 | C4 93  | 1100100 10010011(最高位1表示负数) |\n\n\n|      | 原码       | 反码      | 补码      |\n| ---- | ---------- | --------- | --------- |\n| 11   | 0000 1011  | 0000 1011 | 0000 1011 |\n| -11  | 1000  1011 | 1111 0100 | 1111 0101 |\n\n注:负数的补码为反码加1,  正数的 原码、反码、补码都相同\n\n##### 知识细节\n\n- 有符号数同一表示形式下，负数的表示范围 比正数的范围大1  \n\n  同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                        \t  \t同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​\t\t\t\t\n\n- 对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变\n\n​\teg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同\n\n​\t无符号数和有符号数之间的转换规则：T-->U:补码转化为无符号数       U-->T:无符号数转化为补码\n\n​\t参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\n- 扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n- 截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n#### 整数运算\n\n##### 有符号数和无符号数转换的基本原则：\n\n```\n-位模式不变\n\n-重新解读（按目标编码类型的规则解读）\n\n-会有意外的副作用：数值被 + 或 -$2^w$\n\n-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数\n```\n\n加法:\t无/有符号数的加法：正常加法后再截断，位级的运算相同\n\n​\t\t无符号数：加后对$2^w$求模\n\n##### 符号位扩展\n\n```\n-无符号数：填充0\n\n-有符号位：符号扩展\n\n\t\t\teg：-15213    二进制：11000100 10010011  ---> 11111111 11111111 11000100 10010011\n\n-结果都是明确的预期值\n```\n\n##### 截断\n\n```\n-无论有无符号数，多出的位数都被截断\n\n-结果重新解读\n\n-无符号数: 相当于求模运算\n\n-有符号数：和求模运算相似\n```\n\n​\t-对于小整数，结果是明确的预期值\n\n##### 检测无符号数加法中的溢出：\n\n​\ts =x+y,当且仅当s < x(或等价的s < y)时发生了溢出\n\n​\t无符号数逆元（求反）：x=0时：-x=0\n\n​\t\t\t\t   x > 0时: -x = $2^w$\n\n##### 补码加法：\n\n对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有\n$$\n\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w& 2^{w-1}\\le{x+y} & 正溢出\\\\x+y & -2^{w-1}\\le{x+y}<2^{w-1} & 正常\\\\x+y+2^w & x+y<-2^{w-1} & 负溢出\\end{cases}\\end{equation}\n$$\n​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x > 0,y > 0但s$\\le$0时发生了正溢出；当且仅当x < 0,y < 0但s$\\geq$0时发生了正溢出  \n\n##### 补码的非                                                                                    \n\n对满足$TMin_w\\le x\\le TMax_w$\t的$x$，其补码的非$-^t_wx$由下式给出：\n$$\n\\begin{equation}-^t_wx=\\begin{cases}TMin_w& x = TMin_w\\\\-x & x>TMin_w\\end{cases}\\end{equation}\n$$\n也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆\n\n##### 补码非的位级表示\n\n​\t方法一：对每一位求补，再对结果加1\n\n​\t方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反\n\n#### 浮点数\n\n- IEEE标准：\n\n![浮点数标准分类](/img/深入理解计算机系统/浮点数标准分类.PNG)\n\n- 浮点数规格化的值（frac、exp）\n\n![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG)\n\n- 对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 ![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG) \n\n- 舍入\n\n![浮点数舍入](/img/深入理解计算机系统/浮点数舍入.PNG)\n\n​\t将float或double转化成int，值将向零舍入                    \n\n### 程序的机器级表示\n\n#### 数据格式\n\nc数据类型的宽度\n\n| c数据类型   | 32位 | 64位 | x86-64 |\n| ----------- | ---- | ---- | ------ |\n| char        | 1    | 1    | 1      |\n| short       | 2    | 2    | 2      |\n| int         | 4    | 4    | 4      |\n| long        | 4    | 8    | 8      |\n| float       | 4    | 4    | 4      |\n| double      | 8    | 8    | 8      |\n| long double | -    | -    | 10/16  |\n| pointer     | 4    | 8    | 8      |\n\n\n#### 访问信息\n\n- 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；\n\n- MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。\n\n​\tMOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；\n\n​\tMOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax\n\n#### 算术和逻辑操作\n\n![算术和逻辑操作指令](/img/深入理解计算机系统/算术和逻辑操作指令.PNG)\n\n（1）leap指令目的操作数必须是寄存器\n\n（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0\n\n（3）特殊的算术操作\n\n![特殊的操作指令](/img/深入理解计算机系统/特殊的操作指令.PNG)\n\n有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx\n\ncqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位\n\n#### 控制\n\n（1）leaq指令不改变条件码\n\n（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and\n\n（3）条件码通常不会直接读取，常用使用方法：\n\n​\ta、根据条件码的某种组合将一个字节设置为0或1（即set指令）\n\n​\tb、条件跳转到程序的某个其他部分\n\n​\tc、有条件的传送数据\n\n（4）set指令：\n\n![set指令](/img/深入理解计算机系统/set指令.PNG)\n\n#### 过程\n\n （1）传递控制、传递数据、分配和释放内存\n\n![栈结构](/img/深入理解计算机系统/栈结构.PNG)\n\n（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数\n\n（3）栈上的局部变量（局部数据必须用主存的情况)\n\n​\t1）寄存器不足够存放所有的本地数据\n\n​\t2）对一个局部变量使用取址符&，因此必须为其产生一个地址\n\n​\t3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。\n\n注：寄存器是唯一被所有过程共享的资源\n\n#### 对抗缓冲区溢出\n\n方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域\n\n#### 过程中的浮点代码\n\n- XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。\n\n- 函数使用寄存器%xmm0来返回浮点值。\n\n- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器\n  中任意一个。\n\n  | 单精度 | 双精度 | 效果   | 描述                    |\n  | ------ | ------ | ------ | ----------------------- |\n  | vxorps | vorpd  | D<-x*y | 位级异或（EXCLUSIVE-OR) |\n  | vandps | andpd  | D<-x&y | 位级与（AND）           |\n\n| 指令        | 基于 | 描述         |\n| ----------- | ---- | ------------ |\n| ucomiss x,y | y-x  | 比较单精度值 |\n| ucomisd x,y | y-x  | 比较双精度值 |\n\n### 处理器体系结构\n\n1、程序计数器PC保存当前正在执行指令的地址\n\n2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址\n\n3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。\n\n4、指令集的一个重要性质就是每个字节编码必须有唯一的解释\n\n5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字\n\n6、指令处理：\n\n取指、译码、执行、访存、写回、更新PC\n\n7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。\n\n8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。\n\n9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。\n\n### 优化程序性能\n\n- 程序性能标准：每元素的周期数CPE\n\n- 优化方法：\n\n  1、消除循环低效率：代码移动：\n\n  2、减少过程调用\n\n  3、消除不必要的内存引用\n\n  4、循环展开：减少迭代次数\n\n  5、提高并行性：多个累计变量并行求、重新结合变换\n\n- 课本总结：\n\n  1）高级设计：算法和数据结构\n\n  2）基本编码原则：\n\n  - 消除连续的函数调用：将计算移动到循环外\n\n  - 消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量\n\n  3）低级优化：\n\n  - 展开循环，降低开销，并且使进一步优化成为可能\n\n  - 通过使用例如多个累积变量和重新结合等技术，提高指令集并行\n\n  - 用功能性的风格重写条件操作，使得编译采用条件数据传送\n\n- 限制因素：\n\n  1、寄存器溢出\n\n  2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码\n\n### 存储器层次结构\n\n#### 存储技术\n\n#####  随机访问存储器\n\n随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM\n\n（1）静态（SRAM）\n\nSRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一\n\n（2）动态（DRAM）\n\nDRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复\n\n对比：\n\n![SRAM和DRAM对比](/img/深入理解计算机系统/SRAM和DRAM对比.PNG)\n\n（3）传统的DRAM\n\nDRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。\n\n每个超单元存储一个字节\n\n(4)内存模块\n\n--DRAM芯片封装在内存模块中，插到主板的扩展槽上\n\n--内存地址A取值过程：\n\n![6.1.1内存地址取值](/img/深入理解计算机系统/6.1.1内存地址取值.PNG)\n\n\n\n（5）增强的DRAM\n\n快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM\n\n（6）非易失性存储器\n\nROM\n\n（7）访问主存\n\n总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线\n\n##### 磁盘存储\n\n磁盘读取时间计算：\n\n![磁盘读取时间计算](/img/深入理解计算机系统/磁盘读取时间计算.PNG)\n\n#### 局部性\n\n   (1)重复引用相同局部变量的程序具有良好的时间局部性\n\n（2）步长越小，空间局部性越好\n\n（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好\n\n#### 存储器层次结构\n\n存储器层次结构\n\n![存储器层次结构](/img/深入理解计算机系统/存储器层次结构.PNG)\n\n\n\n#### 高速缓存存储器\n\n缓存不命中：\n\n- 冷不命中（强制性不命中）：\n\n  k层缓存有空行，程序最开始运行时均为冷不命中\n\n- 冲突不命中\n\n  k层中没有空行 \n\n- 容量不命中\n\n组相连高速缓存、组相连高速缓存、全相连高速缓存\n\n#### 编写高速缓存存储器\n\n写命中：\n\n直写：高速缓存中更新的数据立即写回到低一层中\n\n写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中\n\n写不命中：\n\n写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块\n\n非写分配：避开高速缓存，直接把这个字写到低一层中\n\n**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的\n\n#### 综合：高速缓存对程序性能的影响\n\n如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中\n\n### 异常控制流\n\n#### 异常\n\n（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现\n\n（2）事件处理：\n\n![8.1事件处理](/img/深入理解计算机系统/8.1事件处理.PNG)\n\n（3）异常分类\n\n![异常分类](/img/深入理解计算机系统/异常分类.PNG)\n\n![异常分类2](/img/深入理解计算机系统/异常分类2.PNG)\n\n#### 进程\n\n进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成\n\n进程提供的关键抽象：\n\n一个独立的逻辑控制流、一个私有的地址空间\n\n- 并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。\n\n- 如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行\n\n- 进程地址空间\n\n  ![进程地址空间](/img/深入理解计算机系统/进程地址空间.PNG)\n\n- 用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常\n\n- 上下文切换：\n\n  1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程\n\n#### 进程控制\n\n- 进程的三种状态：\n\n运行：进程要么被执行，要么等待被执行且被内核调度\n\n停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号\n\n终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数\n\n- 父进程和子进程最大的区别是PID不同。\n\nfork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；\n\n- 子进程和父进程：\n\n  1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件\n\n- pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1\n\n- unsigned int sleep(unsigned int secs)：返回还要休眠的秒数\n\n- int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号\n\n- execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。\n\n#### 编写信号处理程序\n\n1、安全的信号处理\n\n（1）处理程序要尽可能的简单\n\n（2）在处理程序中只调用异步信号安全的函数\n\n（3）保存和恢复errno\n\n（4）阻塞所有信号，保护对共享数据结构的访问\n\n（5）用volatile声明全局变量\n\n（6）用sig_atomic_t声明标志\n\n2、正确的信号处理：未处理的信号不排队\n\n3、可移植的信号处理\n\n\n\n由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦-----\n\n","source":"_posts/深入理解计算机系统.md","raw":"---\ntitle: 哈尔滨工业大学计算机系统2018年秋期末复习\nurlname: hit_data_structure_review\nmathjax: true\ntags:\n  - 计算机系统\n  - 期末复习\ncategories: 计算机系统\ndescription: 一直想拥有一个自己的博客，但是却一拖再拖，始终没有推送一篇博文，仅以此篇--哈尔滨工业大学计算机系统的复习提纲，仅为期末复习所准备，慰藉以往无bolg的时光。\nabbrlink: 22353\ndate: 2019-03-05 14:00:00\n---\n\n\n- 计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小\n\n- ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件\n\n- 核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。\n\n- 存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存\n\n- 操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 \n\n### 信息的表示和处理\n\n#### 信息存储\n\n- 信息：\n\n```\n数值：值   小数点  符号（三要素）\n\n非数值：文字 图像 视频 语言\n```\n\n- 软件：\n\n  ```\n  系统软件：（用来管理整个计算机系统）\n  \n  语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件\n  ```\n\n- 计算机系统的层次结构：\n\n| 高级语言          | 虚拟机器M3   |\n| ----------------- | ------------ |\n| 汇编语言          | 虚拟机器M2   |\n| 操作系统          | 虚拟机器     |\n| 机器语言          | 实际机器M1   |\n| 微指令语言（时间) | 微程序机器M0 |\n- 机器数（码）：原码 反码 移码  补码\n\n- 数的逻辑：逻辑   算术（+ - * /） c语言中的数\n\n- 逻辑运算符&&和||与对应的位级运算符&和|第二个区别：\n\n  如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&&5/a不会造成被零除，p&&*p++不会导致间接引用空指针 \n\n- 集合的表示与运算\n\n  - 表示：位向量表示有限集合\n\n```\neg：10100110   从右到左表示 该集合={1，2，5，7}\n```\n\n- 运算：& 交集     |  并集    ^  对称差集    ~  补集                  \n\n- 左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x>>k表示x算术右移k个位置，x>>>k表示逻辑右移\n\n#### 整数表示\n\n##### 整数编码\n\n有符号数：补码\n\nB2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$\n\n例：\n\n|      | 10进制 | 16进制 | 2进制                             |\n| ---- | ------ | ------ | --------------------------------- |\n| X    | 15213  | 3B 6D  | 0011011 01101101                  |\n| Y    | -15213 | C4 93  | 1100100 10010011(最高位1表示负数) |\n\n\n|      | 原码       | 反码      | 补码      |\n| ---- | ---------- | --------- | --------- |\n| 11   | 0000 1011  | 0000 1011 | 0000 1011 |\n| -11  | 1000  1011 | 1111 0100 | 1111 0101 |\n\n注:负数的补码为反码加1,  正数的 原码、反码、补码都相同\n\n##### 知识细节\n\n- 有符号数同一表示形式下，负数的表示范围 比正数的范围大1  \n\n  同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                        \t  \t同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​\t\t\t\t\n\n- 对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变\n\n​\teg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同\n\n​\t无符号数和有符号数之间的转换规则：T-->U:补码转化为无符号数       U-->T:无符号数转化为补码\n\n​\t参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\n- 扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n- 截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n#### 整数运算\n\n##### 有符号数和无符号数转换的基本原则：\n\n```\n-位模式不变\n\n-重新解读（按目标编码类型的规则解读）\n\n-会有意外的副作用：数值被 + 或 -$2^w$\n\n-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数\n```\n\n加法:\t无/有符号数的加法：正常加法后再截断，位级的运算相同\n\n​\t\t无符号数：加后对$2^w$求模\n\n##### 符号位扩展\n\n```\n-无符号数：填充0\n\n-有符号位：符号扩展\n\n\t\t\teg：-15213    二进制：11000100 10010011  ---> 11111111 11111111 11000100 10010011\n\n-结果都是明确的预期值\n```\n\n##### 截断\n\n```\n-无论有无符号数，多出的位数都被截断\n\n-结果重新解读\n\n-无符号数: 相当于求模运算\n\n-有符号数：和求模运算相似\n```\n\n​\t-对于小整数，结果是明确的预期值\n\n##### 检测无符号数加法中的溢出：\n\n​\ts =x+y,当且仅当s < x(或等价的s < y)时发生了溢出\n\n​\t无符号数逆元（求反）：x=0时：-x=0\n\n​\t\t\t\t   x > 0时: -x = $2^w$\n\n##### 补码加法：\n\n对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有\n$$\n\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w& 2^{w-1}\\le{x+y} & 正溢出\\\\x+y & -2^{w-1}\\le{x+y}<2^{w-1} & 正常\\\\x+y+2^w & x+y<-2^{w-1} & 负溢出\\end{cases}\\end{equation}\n$$\n​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x > 0,y > 0但s$\\le$0时发生了正溢出；当且仅当x < 0,y < 0但s$\\geq$0时发生了正溢出  \n\n##### 补码的非                                                                                    \n\n对满足$TMin_w\\le x\\le TMax_w$\t的$x$，其补码的非$-^t_wx$由下式给出：\n$$\n\\begin{equation}-^t_wx=\\begin{cases}TMin_w& x = TMin_w\\\\-x & x>TMin_w\\end{cases}\\end{equation}\n$$\n也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆\n\n##### 补码非的位级表示\n\n​\t方法一：对每一位求补，再对结果加1\n\n​\t方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反\n\n#### 浮点数\n\n- IEEE标准：\n\n![浮点数标准分类](/img/深入理解计算机系统/浮点数标准分类.PNG)\n\n- 浮点数规格化的值（frac、exp）\n\n![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG)\n\n- 对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 ![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG) \n\n- 舍入\n\n![浮点数舍入](/img/深入理解计算机系统/浮点数舍入.PNG)\n\n​\t将float或double转化成int，值将向零舍入                    \n\n### 程序的机器级表示\n\n#### 数据格式\n\nc数据类型的宽度\n\n| c数据类型   | 32位 | 64位 | x86-64 |\n| ----------- | ---- | ---- | ------ |\n| char        | 1    | 1    | 1      |\n| short       | 2    | 2    | 2      |\n| int         | 4    | 4    | 4      |\n| long        | 4    | 8    | 8      |\n| float       | 4    | 4    | 4      |\n| double      | 8    | 8    | 8      |\n| long double | -    | -    | 10/16  |\n| pointer     | 4    | 8    | 8      |\n\n\n#### 访问信息\n\n- 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；\n\n- MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。\n\n​\tMOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；\n\n​\tMOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax\n\n#### 算术和逻辑操作\n\n![算术和逻辑操作指令](/img/深入理解计算机系统/算术和逻辑操作指令.PNG)\n\n（1）leap指令目的操作数必须是寄存器\n\n（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0\n\n（3）特殊的算术操作\n\n![特殊的操作指令](/img/深入理解计算机系统/特殊的操作指令.PNG)\n\n有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx\n\ncqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位\n\n#### 控制\n\n（1）leaq指令不改变条件码\n\n（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and\n\n（3）条件码通常不会直接读取，常用使用方法：\n\n​\ta、根据条件码的某种组合将一个字节设置为0或1（即set指令）\n\n​\tb、条件跳转到程序的某个其他部分\n\n​\tc、有条件的传送数据\n\n（4）set指令：\n\n![set指令](/img/深入理解计算机系统/set指令.PNG)\n\n#### 过程\n\n （1）传递控制、传递数据、分配和释放内存\n\n![栈结构](/img/深入理解计算机系统/栈结构.PNG)\n\n（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数\n\n（3）栈上的局部变量（局部数据必须用主存的情况)\n\n​\t1）寄存器不足够存放所有的本地数据\n\n​\t2）对一个局部变量使用取址符&，因此必须为其产生一个地址\n\n​\t3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。\n\n注：寄存器是唯一被所有过程共享的资源\n\n#### 对抗缓冲区溢出\n\n方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域\n\n#### 过程中的浮点代码\n\n- XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。\n\n- 函数使用寄存器%xmm0来返回浮点值。\n\n- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器\n  中任意一个。\n\n  | 单精度 | 双精度 | 效果   | 描述                    |\n  | ------ | ------ | ------ | ----------------------- |\n  | vxorps | vorpd  | D<-x*y | 位级异或（EXCLUSIVE-OR) |\n  | vandps | andpd  | D<-x&y | 位级与（AND）           |\n\n| 指令        | 基于 | 描述         |\n| ----------- | ---- | ------------ |\n| ucomiss x,y | y-x  | 比较单精度值 |\n| ucomisd x,y | y-x  | 比较双精度值 |\n\n### 处理器体系结构\n\n1、程序计数器PC保存当前正在执行指令的地址\n\n2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址\n\n3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。\n\n4、指令集的一个重要性质就是每个字节编码必须有唯一的解释\n\n5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字\n\n6、指令处理：\n\n取指、译码、执行、访存、写回、更新PC\n\n7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。\n\n8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。\n\n9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。\n\n### 优化程序性能\n\n- 程序性能标准：每元素的周期数CPE\n\n- 优化方法：\n\n  1、消除循环低效率：代码移动：\n\n  2、减少过程调用\n\n  3、消除不必要的内存引用\n\n  4、循环展开：减少迭代次数\n\n  5、提高并行性：多个累计变量并行求、重新结合变换\n\n- 课本总结：\n\n  1）高级设计：算法和数据结构\n\n  2）基本编码原则：\n\n  - 消除连续的函数调用：将计算移动到循环外\n\n  - 消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量\n\n  3）低级优化：\n\n  - 展开循环，降低开销，并且使进一步优化成为可能\n\n  - 通过使用例如多个累积变量和重新结合等技术，提高指令集并行\n\n  - 用功能性的风格重写条件操作，使得编译采用条件数据传送\n\n- 限制因素：\n\n  1、寄存器溢出\n\n  2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码\n\n### 存储器层次结构\n\n#### 存储技术\n\n#####  随机访问存储器\n\n随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM\n\n（1）静态（SRAM）\n\nSRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一\n\n（2）动态（DRAM）\n\nDRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复\n\n对比：\n\n![SRAM和DRAM对比](/img/深入理解计算机系统/SRAM和DRAM对比.PNG)\n\n（3）传统的DRAM\n\nDRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。\n\n每个超单元存储一个字节\n\n(4)内存模块\n\n--DRAM芯片封装在内存模块中，插到主板的扩展槽上\n\n--内存地址A取值过程：\n\n![6.1.1内存地址取值](/img/深入理解计算机系统/6.1.1内存地址取值.PNG)\n\n\n\n（5）增强的DRAM\n\n快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM\n\n（6）非易失性存储器\n\nROM\n\n（7）访问主存\n\n总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线\n\n##### 磁盘存储\n\n磁盘读取时间计算：\n\n![磁盘读取时间计算](/img/深入理解计算机系统/磁盘读取时间计算.PNG)\n\n#### 局部性\n\n   (1)重复引用相同局部变量的程序具有良好的时间局部性\n\n（2）步长越小，空间局部性越好\n\n（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好\n\n#### 存储器层次结构\n\n存储器层次结构\n\n![存储器层次结构](/img/深入理解计算机系统/存储器层次结构.PNG)\n\n\n\n#### 高速缓存存储器\n\n缓存不命中：\n\n- 冷不命中（强制性不命中）：\n\n  k层缓存有空行，程序最开始运行时均为冷不命中\n\n- 冲突不命中\n\n  k层中没有空行 \n\n- 容量不命中\n\n组相连高速缓存、组相连高速缓存、全相连高速缓存\n\n#### 编写高速缓存存储器\n\n写命中：\n\n直写：高速缓存中更新的数据立即写回到低一层中\n\n写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中\n\n写不命中：\n\n写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块\n\n非写分配：避开高速缓存，直接把这个字写到低一层中\n\n**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的\n\n#### 综合：高速缓存对程序性能的影响\n\n如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中\n\n### 异常控制流\n\n#### 异常\n\n（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现\n\n（2）事件处理：\n\n![8.1事件处理](/img/深入理解计算机系统/8.1事件处理.PNG)\n\n（3）异常分类\n\n![异常分类](/img/深入理解计算机系统/异常分类.PNG)\n\n![异常分类2](/img/深入理解计算机系统/异常分类2.PNG)\n\n#### 进程\n\n进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成\n\n进程提供的关键抽象：\n\n一个独立的逻辑控制流、一个私有的地址空间\n\n- 并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。\n\n- 如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行\n\n- 进程地址空间\n\n  ![进程地址空间](/img/深入理解计算机系统/进程地址空间.PNG)\n\n- 用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常\n\n- 上下文切换：\n\n  1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程\n\n#### 进程控制\n\n- 进程的三种状态：\n\n运行：进程要么被执行，要么等待被执行且被内核调度\n\n停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号\n\n终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数\n\n- 父进程和子进程最大的区别是PID不同。\n\nfork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；\n\n- 子进程和父进程：\n\n  1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件\n\n- pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1\n\n- unsigned int sleep(unsigned int secs)：返回还要休眠的秒数\n\n- int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号\n\n- execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。\n\n#### 编写信号处理程序\n\n1、安全的信号处理\n\n（1）处理程序要尽可能的简单\n\n（2）在处理程序中只调用异步信号安全的函数\n\n（3）保存和恢复errno\n\n（4）阻塞所有信号，保护对共享数据结构的访问\n\n（5）用volatile声明全局变量\n\n（6）用sig_atomic_t声明标志\n\n2、正确的信号处理：未处理的信号不排队\n\n3、可移植的信号处理\n\n\n\n由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦-----\n\n","slug":"深入理解计算机系统","published":1,"updated":"2019-03-20T10:56:11.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvrtri57000stku3o5h3n120","content":"<ul>\n<li><p>计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小</p>\n</li>\n<li><p>ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件</p>\n</li>\n<li><p>核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。</p>\n</li>\n<li><p>存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存</p>\n</li>\n<li><p>操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 </p>\n</li>\n</ul>\n<h3 id=\"信息的表示和处理\"><a href=\"#信息的表示和处理\" class=\"headerlink\" title=\"信息的表示和处理\"></a>信息的表示和处理</h3><h4 id=\"信息存储\"><a href=\"#信息存储\" class=\"headerlink\" title=\"信息存储\"></a>信息存储</h4><ul>\n<li>信息：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数值：值   小数点  符号（三要素）</span><br><span class=\"line\"></span><br><span class=\"line\">非数值：文字 图像 视频 语言</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>软件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统软件：（用来管理整个计算机系统）</span><br><span class=\"line\"></span><br><span class=\"line\">语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计算机系统的层次结构：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>高级语言</th>\n<th>虚拟机器M3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>汇编语言</td>\n<td>虚拟机器M2</td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>虚拟机器</td>\n</tr>\n<tr>\n<td>机器语言</td>\n<td>实际机器M1</td>\n</tr>\n<tr>\n<td>微指令语言（时间)</td>\n<td>微程序机器M0</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>机器数（码）：原码 反码 移码  补码</p>\n</li>\n<li><p>数的逻辑：逻辑   算术（+ - * /） c语言中的数</p>\n</li>\n<li><p>逻辑运算符&amp;&amp;和||与对应的位级运算符&amp;和|第二个区别：</p>\n<p>如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&amp;&amp;5/a不会造成被零除，p&amp;&amp;*p++不会导致间接引用空指针 </p>\n</li>\n<li><p>集合的表示与运算</p>\n<ul>\n<li>表示：位向量表示有限集合</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：10100110   从右到左表示 该集合=&#123;1，2，5，7&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>运算：&amp; 交集     |  并集    ^  对称差集    ~  补集                  </p>\n</li>\n<li><p>左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x&gt;&gt;k表示x算术右移k个位置，x&gt;&gt;&gt;k表示逻辑右移</p>\n</li>\n</ul>\n<h4 id=\"整数表示\"><a href=\"#整数表示\" class=\"headerlink\" title=\"整数表示\"></a>整数表示</h4><h5 id=\"整数编码\"><a href=\"#整数编码\" class=\"headerlink\" title=\"整数编码\"></a>整数编码</h5><p>有符号数：补码</p>\n<p>B2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$</p>\n<p>例：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>10进制</th>\n<th>16进制</th>\n<th>2进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>15213</td>\n<td>3B 6D</td>\n<td>0011011 01101101</td>\n</tr>\n<tr>\n<td>Y</td>\n<td>-15213</td>\n<td>C4 93</td>\n<td>1100100 10010011(最高位1表示负数)</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>原码</th>\n<th>反码</th>\n<th>补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n</tr>\n<tr>\n<td>-11</td>\n<td>1000  1011</td>\n<td>1111 0100</td>\n<td>1111 0101</td>\n</tr>\n</tbody>\n</table>\n<p>注:负数的补码为反码加1,  正数的 原码、反码、补码都相同</p>\n<h5 id=\"知识细节\"><a href=\"#知识细节\" class=\"headerlink\" title=\"知识细节\"></a>知识细节</h5><ul>\n<li><p>有符号数同一表示形式下，负数的表示范围 比正数的范围大1  </p>\n<p>同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                                  同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​                </p>\n</li>\n<li><p>对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变</p>\n</li>\n</ul>\n<p>​    eg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同</p>\n<p>​    无符号数和有符号数之间的转换规则：T–&gt;U:补码转化为无符号数       U–&gt;T:无符号数转化为补码</p>\n<p>​    参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​                                                      </p>\n<ul>\n<li><p>扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​                                                        </p>\n</li>\n<li><p>截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​                                                    </p>\n</li>\n</ul>\n<h4 id=\"整数运算\"><a href=\"#整数运算\" class=\"headerlink\" title=\"整数运算\"></a>整数运算</h4><h5 id=\"有符号数和无符号数转换的基本原则：\"><a href=\"#有符号数和无符号数转换的基本原则：\" class=\"headerlink\" title=\"有符号数和无符号数转换的基本原则：\"></a>有符号数和无符号数转换的基本原则：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-位模式不变</span><br><span class=\"line\"></span><br><span class=\"line\">-重新解读（按目标编码类型的规则解读）</span><br><span class=\"line\"></span><br><span class=\"line\">-会有意外的副作用：数值被 + 或 -$2^w$</span><br><span class=\"line\"></span><br><span class=\"line\">-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数</span><br></pre></td></tr></table></figure>\n<p>加法:    无/有符号数的加法：正常加法后再截断，位级的运算相同</p>\n<p>​        无符号数：加后对$2^w$求模</p>\n<h5 id=\"符号位扩展\"><a href=\"#符号位扩展\" class=\"headerlink\" title=\"符号位扩展\"></a>符号位扩展</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-无符号数：填充0</span><br><span class=\"line\"></span><br><span class=\"line\">-有符号位：符号扩展</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\teg：-15213    二进制：11000100 10010011  ---&gt; 11111111 11111111 11000100 10010011</span><br><span class=\"line\"></span><br><span class=\"line\">-结果都是明确的预期值</span><br></pre></td></tr></table></figure>\n<h5 id=\"截断\"><a href=\"#截断\" class=\"headerlink\" title=\"截断\"></a>截断</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-无论有无符号数，多出的位数都被截断</span><br><span class=\"line\"></span><br><span class=\"line\">-结果重新解读</span><br><span class=\"line\"></span><br><span class=\"line\">-无符号数: 相当于求模运算</span><br><span class=\"line\"></span><br><span class=\"line\">-有符号数：和求模运算相似</span><br></pre></td></tr></table></figure>\n<p>​    -对于小整数，结果是明确的预期值</p>\n<h5 id=\"检测无符号数加法中的溢出：\"><a href=\"#检测无符号数加法中的溢出：\" class=\"headerlink\" title=\"检测无符号数加法中的溢出：\"></a>检测无符号数加法中的溢出：</h5><p>​    s =x+y,当且仅当s &lt; x(或等价的s &lt; y)时发生了溢出</p>\n<p>​    无符号数逆元（求反）：x=0时：-x=0</p>\n<p>​                   x &gt; 0时: -x = $2^w$</p>\n<h5 id=\"补码加法：\"><a href=\"#补码加法：\" class=\"headerlink\" title=\"补码加法：\"></a>补码加法：</h5><p>对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有<br>$$<br>\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w&amp; 2^{w-1}\\le{x+y} &amp; 正溢出\\x+y &amp; -2^{w-1}\\le{x+y}&lt;2^{w-1} &amp; 正常\\x+y+2^w &amp; x+y&lt;-2^{w-1} &amp; 负溢出\\end{cases}\\end{equation}<br>$$<br>​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x &gt; 0,y &gt; 0但s$\\le$0时发生了正溢出；当且仅当x &lt; 0,y &lt; 0但s$\\geq$0时发生了正溢出  </p>\n<h5 id=\"补码的非\"><a href=\"#补码的非\" class=\"headerlink\" title=\"补码的非\"></a>补码的非</h5><p>对满足$TMin_w\\le x\\le TMax_w$    的$x$，其补码的非$-^t_wx$由下式给出：<br>$$<br>\\begin{equation}-^t_wx=\\begin{cases}TMin_w&amp; x = TMin_w\\-x &amp; x&gt;TMin_w\\end{cases}\\end{equation}<br>$$<br>也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆</p>\n<h5 id=\"补码非的位级表示\"><a href=\"#补码非的位级表示\" class=\"headerlink\" title=\"补码非的位级表示\"></a>补码非的位级表示</h5><p>​    方法一：对每一位求补，再对结果加1</p>\n<p>​    方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反</p>\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><ul>\n<li>IEEE标准：</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数标准分类.PNG\" alt=\"浮点数标准分类\"></p>\n<ul>\n<li>浮点数规格化的值（frac、exp）</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"></p>\n<ul>\n<li><p>对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 <img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"> </p>\n</li>\n<li><p>舍入</p>\n</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数舍入.PNG\" alt=\"浮点数舍入\"></p>\n<p>​    将float或double转化成int，值将向零舍入                    </p>\n<h3 id=\"程序的机器级表示\"><a href=\"#程序的机器级表示\" class=\"headerlink\" title=\"程序的机器级表示\"></a>程序的机器级表示</h3><h4 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h4><p>c数据类型的宽度</p>\n<table>\n<thead>\n<tr>\n<th>c数据类型</th>\n<th>32位</th>\n<th>64位</th>\n<th>x86-64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>long</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>-</td>\n<td>-</td>\n<td>10/16</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"访问信息\"><a href=\"#访问信息\" class=\"headerlink\" title=\"访问信息\"></a>访问信息</h4><ul>\n<li><p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；</p>\n</li>\n<li><p>MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。</p>\n</li>\n</ul>\n<p>​    MOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；</p>\n<p>​    MOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax</p>\n<h4 id=\"算术和逻辑操作\"><a href=\"#算术和逻辑操作\" class=\"headerlink\" title=\"算术和逻辑操作\"></a>算术和逻辑操作</h4><p><img src=\"/img/深入理解计算机系统/算术和逻辑操作指令.PNG\" alt=\"算术和逻辑操作指令\"></p>\n<p>（1）leap指令目的操作数必须是寄存器</p>\n<p>（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0</p>\n<p>（3）特殊的算术操作</p>\n<p><img src=\"/img/深入理解计算机系统/特殊的操作指令.PNG\" alt=\"特殊的操作指令\"></p>\n<p>有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx</p>\n<p>cqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位</p>\n<h4 id=\"控制\"><a href=\"#控制\" class=\"headerlink\" title=\"控制\"></a>控制</h4><p>（1）leaq指令不改变条件码</p>\n<p>（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and</p>\n<p>（3）条件码通常不会直接读取，常用使用方法：</p>\n<p>​    a、根据条件码的某种组合将一个字节设置为0或1（即set指令）</p>\n<p>​    b、条件跳转到程序的某个其他部分</p>\n<p>​    c、有条件的传送数据</p>\n<p>（4）set指令：</p>\n<p><img src=\"/img/深入理解计算机系统/set指令.PNG\" alt=\"set指令\"></p>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p> （1）传递控制、传递数据、分配和释放内存</p>\n<p><img src=\"/img/深入理解计算机系统/栈结构.PNG\" alt=\"栈结构\"></p>\n<p>（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数</p>\n<p>（3）栈上的局部变量（局部数据必须用主存的情况)</p>\n<p>​    1）寄存器不足够存放所有的本地数据</p>\n<p>​    2）对一个局部变量使用取址符&amp;，因此必须为其产生一个地址</p>\n<p>​    3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。</p>\n<p>注：寄存器是唯一被所有过程共享的资源</p>\n<h4 id=\"对抗缓冲区溢出\"><a href=\"#对抗缓冲区溢出\" class=\"headerlink\" title=\"对抗缓冲区溢出\"></a>对抗缓冲区溢出</h4><p>方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域</p>\n<h4 id=\"过程中的浮点代码\"><a href=\"#过程中的浮点代码\" class=\"headerlink\" title=\"过程中的浮点代码\"></a>过程中的浮点代码</h4><ul>\n<li><p>XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</p>\n</li>\n<li><p>函数使用寄存器%xmm0来返回浮点值。</p>\n</li>\n<li><p>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器<br>中任意一个。</p>\n<p>| 单精度 | 双精度 | 效果   | 描述                    |<br>| —— | —— | —— | ———————– |<br>| vxorps | vorpd  | D&lt;-x*y | 位级异或（EXCLUSIVE-OR) |<br>| vandps | andpd  | D&lt;-x&amp;y | 位级与（AND）           |</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>基于</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ucomiss x,y</td>\n<td>y-x</td>\n<td>比较单精度值</td>\n</tr>\n<tr>\n<td>ucomisd x,y</td>\n<td>y-x</td>\n<td>比较双精度值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"处理器体系结构\"><a href=\"#处理器体系结构\" class=\"headerlink\" title=\"处理器体系结构\"></a>处理器体系结构</h3><p>1、程序计数器PC保存当前正在执行指令的地址</p>\n<p>2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址</p>\n<p>3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。</p>\n<p>4、指令集的一个重要性质就是每个字节编码必须有唯一的解释</p>\n<p>5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字</p>\n<p>6、指令处理：</p>\n<p>取指、译码、执行、访存、写回、更新PC</p>\n<p>7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。</p>\n<p>8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p>\n<p>9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。</p>\n<h3 id=\"优化程序性能\"><a href=\"#优化程序性能\" class=\"headerlink\" title=\"优化程序性能\"></a>优化程序性能</h3><ul>\n<li><p>程序性能标准：每元素的周期数CPE</p>\n</li>\n<li><p>优化方法：</p>\n<p>1、消除循环低效率：代码移动：</p>\n<p>2、减少过程调用</p>\n<p>3、消除不必要的内存引用</p>\n<p>4、循环展开：减少迭代次数</p>\n<p>5、提高并行性：多个累计变量并行求、重新结合变换</p>\n</li>\n<li><p>课本总结：</p>\n<p>1）高级设计：算法和数据结构</p>\n<p>2）基本编码原则：</p>\n<ul>\n<li><p>消除连续的函数调用：将计算移动到循环外</p>\n</li>\n<li><p>消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量</p>\n</li>\n</ul>\n<p>3）低级优化：</p>\n<ul>\n<li><p>展开循环，降低开销，并且使进一步优化成为可能</p>\n</li>\n<li><p>通过使用例如多个累积变量和重新结合等技术，提高指令集并行</p>\n</li>\n<li><p>用功能性的风格重写条件操作，使得编译采用条件数据传送</p>\n</li>\n</ul>\n</li>\n<li><p>限制因素：</p>\n<p>1、寄存器溢出</p>\n<p>2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码</p>\n</li>\n</ul>\n<h3 id=\"存储器层次结构\"><a href=\"#存储器层次结构\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h3><h4 id=\"存储技术\"><a href=\"#存储技术\" class=\"headerlink\" title=\"存储技术\"></a>存储技术</h4><h5 id=\"随机访问存储器\"><a href=\"#随机访问存储器\" class=\"headerlink\" title=\"随机访问存储器\"></a>随机访问存储器</h5><p>随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM</p>\n<p>（1）静态（SRAM）</p>\n<p>SRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一</p>\n<p>（2）动态（DRAM）</p>\n<p>DRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复</p>\n<p>对比：</p>\n<p><img src=\"/img/深入理解计算机系统/SRAM和DRAM对比.PNG\" alt=\"SRAM和DRAM对比\"></p>\n<p>（3）传统的DRAM</p>\n<p>DRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。</p>\n<p>每个超单元存储一个字节</p>\n<p>(4)内存模块</p>\n<p>–DRAM芯片封装在内存模块中，插到主板的扩展槽上</p>\n<p>–内存地址A取值过程：</p>\n<p><img src=\"/img/深入理解计算机系统/6.1.1内存地址取值.PNG\" alt=\"6.1.1内存地址取值\"></p>\n<p>（5）增强的DRAM</p>\n<p>快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM</p>\n<p>（6）非易失性存储器</p>\n<p>ROM</p>\n<p>（7）访问主存</p>\n<p>总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线</p>\n<h5 id=\"磁盘存储\"><a href=\"#磁盘存储\" class=\"headerlink\" title=\"磁盘存储\"></a>磁盘存储</h5><p>磁盘读取时间计算：</p>\n<p><img src=\"/img/深入理解计算机系统/磁盘读取时间计算.PNG\" alt=\"磁盘读取时间计算\"></p>\n<h4 id=\"局部性\"><a href=\"#局部性\" class=\"headerlink\" title=\"局部性\"></a>局部性</h4><p>   (1)重复引用相同局部变量的程序具有良好的时间局部性</p>\n<p>（2）步长越小，空间局部性越好</p>\n<p>（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好</p>\n<h4 id=\"存储器层次结构-1\"><a href=\"#存储器层次结构-1\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h4><p>存储器层次结构</p>\n<p><img src=\"/img/深入理解计算机系统/存储器层次结构.PNG\" alt=\"存储器层次结构\"></p>\n<h4 id=\"高速缓存存储器\"><a href=\"#高速缓存存储器\" class=\"headerlink\" title=\"高速缓存存储器\"></a>高速缓存存储器</h4><p>缓存不命中：</p>\n<ul>\n<li><p>冷不命中（强制性不命中）：</p>\n<p>k层缓存有空行，程序最开始运行时均为冷不命中</p>\n</li>\n<li><p>冲突不命中</p>\n<p>k层中没有空行 </p>\n</li>\n<li><p>容量不命中</p>\n</li>\n</ul>\n<p>组相连高速缓存、组相连高速缓存、全相连高速缓存</p>\n<h4 id=\"编写高速缓存存储器\"><a href=\"#编写高速缓存存储器\" class=\"headerlink\" title=\"编写高速缓存存储器\"></a>编写高速缓存存储器</h4><p>写命中：</p>\n<p>直写：高速缓存中更新的数据立即写回到低一层中</p>\n<p>写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中</p>\n<p>写不命中：</p>\n<p>写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块</p>\n<p>非写分配：避开高速缓存，直接把这个字写到低一层中</p>\n<p>**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的</p>\n<h4 id=\"综合：高速缓存对程序性能的影响\"><a href=\"#综合：高速缓存对程序性能的影响\" class=\"headerlink\" title=\"综合：高速缓存对程序性能的影响\"></a>综合：高速缓存对程序性能的影响</h4><p>如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中</p>\n<h3 id=\"异常控制流\"><a href=\"#异常控制流\" class=\"headerlink\" title=\"异常控制流\"></a>异常控制流</h3><h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现</p>\n<p>（2）事件处理：</p>\n<p><img src=\"/img/深入理解计算机系统/8.1事件处理.PNG\" alt=\"8.1事件处理\"></p>\n<p>（3）异常分类</p>\n<p><img src=\"/img/深入理解计算机系统/异常分类.PNG\" alt=\"异常分类\"></p>\n<p><img src=\"/img/深入理解计算机系统/异常分类2.PNG\" alt=\"异常分类2\"></p>\n<h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><p>进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成</p>\n<p>进程提供的关键抽象：</p>\n<p>一个独立的逻辑控制流、一个私有的地址空间</p>\n<ul>\n<li><p>并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。</p>\n</li>\n<li><p>如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行</p>\n</li>\n<li><p>进程地址空间</p>\n<p><img src=\"/img/深入理解计算机系统/进程地址空间.PNG\" alt=\"进程地址空间\"></p>\n</li>\n<li><p>用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常</p>\n</li>\n<li><p>上下文切换：</p>\n<p>1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程</p>\n</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><ul>\n<li>进程的三种状态：</li>\n</ul>\n<p>运行：进程要么被执行，要么等待被执行且被内核调度</p>\n<p>停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号</p>\n<p>终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数</p>\n<ul>\n<li>父进程和子进程最大的区别是PID不同。</li>\n</ul>\n<p>fork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；</p>\n<ul>\n<li><p>子进程和父进程：</p>\n<p>1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件</p>\n</li>\n<li><p>pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1</p>\n</li>\n<li><p>unsigned int sleep(unsigned int secs)：返回还要休眠的秒数</p>\n</li>\n<li><p>int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号</p>\n</li>\n<li><p>execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。</p>\n</li>\n</ul>\n<h4 id=\"编写信号处理程序\"><a href=\"#编写信号处理程序\" class=\"headerlink\" title=\"编写信号处理程序\"></a>编写信号处理程序</h4><p>1、安全的信号处理</p>\n<p>（1）处理程序要尽可能的简单</p>\n<p>（2）在处理程序中只调用异步信号安全的函数</p>\n<p>（3）保存和恢复errno</p>\n<p>（4）阻塞所有信号，保护对共享数据结构的访问</p>\n<p>（5）用volatile声明全局变量</p>\n<p>（6）用sig_atomic_t声明标志</p>\n<p>2、正确的信号处理：未处理的信号不排队</p>\n<p>3、可移植的信号处理</p>\n<p>由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦—–</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小</p>\n</li>\n<li><p>ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件</p>\n</li>\n<li><p>核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。</p>\n</li>\n<li><p>存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存</p>\n</li>\n<li><p>操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 </p>\n</li>\n</ul>\n<h3 id=\"信息的表示和处理\"><a href=\"#信息的表示和处理\" class=\"headerlink\" title=\"信息的表示和处理\"></a>信息的表示和处理</h3><h4 id=\"信息存储\"><a href=\"#信息存储\" class=\"headerlink\" title=\"信息存储\"></a>信息存储</h4><ul>\n<li>信息：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数值：值   小数点  符号（三要素）</span><br><span class=\"line\"></span><br><span class=\"line\">非数值：文字 图像 视频 语言</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>软件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统软件：（用来管理整个计算机系统）</span><br><span class=\"line\"></span><br><span class=\"line\">语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计算机系统的层次结构：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>高级语言</th>\n<th>虚拟机器M3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>汇编语言</td>\n<td>虚拟机器M2</td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>虚拟机器</td>\n</tr>\n<tr>\n<td>机器语言</td>\n<td>实际机器M1</td>\n</tr>\n<tr>\n<td>微指令语言（时间)</td>\n<td>微程序机器M0</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>机器数（码）：原码 反码 移码  补码</p>\n</li>\n<li><p>数的逻辑：逻辑   算术（+ - * /） c语言中的数</p>\n</li>\n<li><p>逻辑运算符&amp;&amp;和||与对应的位级运算符&amp;和|第二个区别：</p>\n<p>如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&amp;&amp;5/a不会造成被零除，p&amp;&amp;*p++不会导致间接引用空指针 </p>\n</li>\n<li><p>集合的表示与运算</p>\n<ul>\n<li>表示：位向量表示有限集合</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：10100110   从右到左表示 该集合=&#123;1，2，5，7&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>运算：&amp; 交集     |  并集    ^  对称差集    ~  补集                  </p>\n</li>\n<li><p>左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x&gt;&gt;k表示x算术右移k个位置，x&gt;&gt;&gt;k表示逻辑右移</p>\n</li>\n</ul>\n<h4 id=\"整数表示\"><a href=\"#整数表示\" class=\"headerlink\" title=\"整数表示\"></a>整数表示</h4><h5 id=\"整数编码\"><a href=\"#整数编码\" class=\"headerlink\" title=\"整数编码\"></a>整数编码</h5><p>有符号数：补码</p>\n<p>B2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$</p>\n<p>例：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>10进制</th>\n<th>16进制</th>\n<th>2进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>15213</td>\n<td>3B 6D</td>\n<td>0011011 01101101</td>\n</tr>\n<tr>\n<td>Y</td>\n<td>-15213</td>\n<td>C4 93</td>\n<td>1100100 10010011(最高位1表示负数)</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>原码</th>\n<th>反码</th>\n<th>补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n</tr>\n<tr>\n<td>-11</td>\n<td>1000  1011</td>\n<td>1111 0100</td>\n<td>1111 0101</td>\n</tr>\n</tbody>\n</table>\n<p>注:负数的补码为反码加1,  正数的 原码、反码、补码都相同</p>\n<h5 id=\"知识细节\"><a href=\"#知识细节\" class=\"headerlink\" title=\"知识细节\"></a>知识细节</h5><ul>\n<li><p>有符号数同一表示形式下，负数的表示范围 比正数的范围大1  </p>\n<p>同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                                  同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​                </p>\n</li>\n<li><p>对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变</p>\n</li>\n</ul>\n<p>​    eg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同</p>\n<p>​    无符号数和有符号数之间的转换规则：T–&gt;U:补码转化为无符号数       U–&gt;T:无符号数转化为补码</p>\n<p>​    参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​                                                      </p>\n<ul>\n<li><p>扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​                                                        </p>\n</li>\n<li><p>截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​                                                    </p>\n</li>\n</ul>\n<h4 id=\"整数运算\"><a href=\"#整数运算\" class=\"headerlink\" title=\"整数运算\"></a>整数运算</h4><h5 id=\"有符号数和无符号数转换的基本原则：\"><a href=\"#有符号数和无符号数转换的基本原则：\" class=\"headerlink\" title=\"有符号数和无符号数转换的基本原则：\"></a>有符号数和无符号数转换的基本原则：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-位模式不变</span><br><span class=\"line\"></span><br><span class=\"line\">-重新解读（按目标编码类型的规则解读）</span><br><span class=\"line\"></span><br><span class=\"line\">-会有意外的副作用：数值被 + 或 -$2^w$</span><br><span class=\"line\"></span><br><span class=\"line\">-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数</span><br></pre></td></tr></table></figure>\n<p>加法:    无/有符号数的加法：正常加法后再截断，位级的运算相同</p>\n<p>​        无符号数：加后对$2^w$求模</p>\n<h5 id=\"符号位扩展\"><a href=\"#符号位扩展\" class=\"headerlink\" title=\"符号位扩展\"></a>符号位扩展</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-无符号数：填充0</span><br><span class=\"line\"></span><br><span class=\"line\">-有符号位：符号扩展</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\teg：-15213    二进制：11000100 10010011  ---&gt; 11111111 11111111 11000100 10010011</span><br><span class=\"line\"></span><br><span class=\"line\">-结果都是明确的预期值</span><br></pre></td></tr></table></figure>\n<h5 id=\"截断\"><a href=\"#截断\" class=\"headerlink\" title=\"截断\"></a>截断</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-无论有无符号数，多出的位数都被截断</span><br><span class=\"line\"></span><br><span class=\"line\">-结果重新解读</span><br><span class=\"line\"></span><br><span class=\"line\">-无符号数: 相当于求模运算</span><br><span class=\"line\"></span><br><span class=\"line\">-有符号数：和求模运算相似</span><br></pre></td></tr></table></figure>\n<p>​    -对于小整数，结果是明确的预期值</p>\n<h5 id=\"检测无符号数加法中的溢出：\"><a href=\"#检测无符号数加法中的溢出：\" class=\"headerlink\" title=\"检测无符号数加法中的溢出：\"></a>检测无符号数加法中的溢出：</h5><p>​    s =x+y,当且仅当s &lt; x(或等价的s &lt; y)时发生了溢出</p>\n<p>​    无符号数逆元（求反）：x=0时：-x=0</p>\n<p>​                   x &gt; 0时: -x = $2^w$</p>\n<h5 id=\"补码加法：\"><a href=\"#补码加法：\" class=\"headerlink\" title=\"补码加法：\"></a>补码加法：</h5><p>对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有<br>$$<br>\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w&amp; 2^{w-1}\\le{x+y} &amp; 正溢出\\x+y &amp; -2^{w-1}\\le{x+y}&lt;2^{w-1} &amp; 正常\\x+y+2^w &amp; x+y&lt;-2^{w-1} &amp; 负溢出\\end{cases}\\end{equation}<br>$$<br>​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x &gt; 0,y &gt; 0但s$\\le$0时发生了正溢出；当且仅当x &lt; 0,y &lt; 0但s$\\geq$0时发生了正溢出  </p>\n<h5 id=\"补码的非\"><a href=\"#补码的非\" class=\"headerlink\" title=\"补码的非\"></a>补码的非</h5><p>对满足$TMin_w\\le x\\le TMax_w$    的$x$，其补码的非$-^t_wx$由下式给出：<br>$$<br>\\begin{equation}-^t_wx=\\begin{cases}TMin_w&amp; x = TMin_w\\-x &amp; x&gt;TMin_w\\end{cases}\\end{equation}<br>$$<br>也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆</p>\n<h5 id=\"补码非的位级表示\"><a href=\"#补码非的位级表示\" class=\"headerlink\" title=\"补码非的位级表示\"></a>补码非的位级表示</h5><p>​    方法一：对每一位求补，再对结果加1</p>\n<p>​    方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反</p>\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><ul>\n<li>IEEE标准：</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数标准分类.PNG\" alt=\"浮点数标准分类\"></p>\n<ul>\n<li>浮点数规格化的值（frac、exp）</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"></p>\n<ul>\n<li><p>对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 <img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"> </p>\n</li>\n<li><p>舍入</p>\n</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数舍入.PNG\" alt=\"浮点数舍入\"></p>\n<p>​    将float或double转化成int，值将向零舍入                    </p>\n<h3 id=\"程序的机器级表示\"><a href=\"#程序的机器级表示\" class=\"headerlink\" title=\"程序的机器级表示\"></a>程序的机器级表示</h3><h4 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h4><p>c数据类型的宽度</p>\n<table>\n<thead>\n<tr>\n<th>c数据类型</th>\n<th>32位</th>\n<th>64位</th>\n<th>x86-64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>long</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>-</td>\n<td>-</td>\n<td>10/16</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"访问信息\"><a href=\"#访问信息\" class=\"headerlink\" title=\"访问信息\"></a>访问信息</h4><ul>\n<li><p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；</p>\n</li>\n<li><p>MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。</p>\n</li>\n</ul>\n<p>​    MOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；</p>\n<p>​    MOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax</p>\n<h4 id=\"算术和逻辑操作\"><a href=\"#算术和逻辑操作\" class=\"headerlink\" title=\"算术和逻辑操作\"></a>算术和逻辑操作</h4><p><img src=\"/img/深入理解计算机系统/算术和逻辑操作指令.PNG\" alt=\"算术和逻辑操作指令\"></p>\n<p>（1）leap指令目的操作数必须是寄存器</p>\n<p>（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0</p>\n<p>（3）特殊的算术操作</p>\n<p><img src=\"/img/深入理解计算机系统/特殊的操作指令.PNG\" alt=\"特殊的操作指令\"></p>\n<p>有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx</p>\n<p>cqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位</p>\n<h4 id=\"控制\"><a href=\"#控制\" class=\"headerlink\" title=\"控制\"></a>控制</h4><p>（1）leaq指令不改变条件码</p>\n<p>（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and</p>\n<p>（3）条件码通常不会直接读取，常用使用方法：</p>\n<p>​    a、根据条件码的某种组合将一个字节设置为0或1（即set指令）</p>\n<p>​    b、条件跳转到程序的某个其他部分</p>\n<p>​    c、有条件的传送数据</p>\n<p>（4）set指令：</p>\n<p><img src=\"/img/深入理解计算机系统/set指令.PNG\" alt=\"set指令\"></p>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p> （1）传递控制、传递数据、分配和释放内存</p>\n<p><img src=\"/img/深入理解计算机系统/栈结构.PNG\" alt=\"栈结构\"></p>\n<p>（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数</p>\n<p>（3）栈上的局部变量（局部数据必须用主存的情况)</p>\n<p>​    1）寄存器不足够存放所有的本地数据</p>\n<p>​    2）对一个局部变量使用取址符&amp;，因此必须为其产生一个地址</p>\n<p>​    3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。</p>\n<p>注：寄存器是唯一被所有过程共享的资源</p>\n<h4 id=\"对抗缓冲区溢出\"><a href=\"#对抗缓冲区溢出\" class=\"headerlink\" title=\"对抗缓冲区溢出\"></a>对抗缓冲区溢出</h4><p>方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域</p>\n<h4 id=\"过程中的浮点代码\"><a href=\"#过程中的浮点代码\" class=\"headerlink\" title=\"过程中的浮点代码\"></a>过程中的浮点代码</h4><ul>\n<li><p>XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</p>\n</li>\n<li><p>函数使用寄存器%xmm0来返回浮点值。</p>\n</li>\n<li><p>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器<br>中任意一个。</p>\n<p>| 单精度 | 双精度 | 效果   | 描述                    |<br>| —— | —— | —— | ———————– |<br>| vxorps | vorpd  | D&lt;-x*y | 位级异或（EXCLUSIVE-OR) |<br>| vandps | andpd  | D&lt;-x&amp;y | 位级与（AND）           |</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>基于</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ucomiss x,y</td>\n<td>y-x</td>\n<td>比较单精度值</td>\n</tr>\n<tr>\n<td>ucomisd x,y</td>\n<td>y-x</td>\n<td>比较双精度值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"处理器体系结构\"><a href=\"#处理器体系结构\" class=\"headerlink\" title=\"处理器体系结构\"></a>处理器体系结构</h3><p>1、程序计数器PC保存当前正在执行指令的地址</p>\n<p>2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址</p>\n<p>3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。</p>\n<p>4、指令集的一个重要性质就是每个字节编码必须有唯一的解释</p>\n<p>5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字</p>\n<p>6、指令处理：</p>\n<p>取指、译码、执行、访存、写回、更新PC</p>\n<p>7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。</p>\n<p>8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p>\n<p>9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。</p>\n<h3 id=\"优化程序性能\"><a href=\"#优化程序性能\" class=\"headerlink\" title=\"优化程序性能\"></a>优化程序性能</h3><ul>\n<li><p>程序性能标准：每元素的周期数CPE</p>\n</li>\n<li><p>优化方法：</p>\n<p>1、消除循环低效率：代码移动：</p>\n<p>2、减少过程调用</p>\n<p>3、消除不必要的内存引用</p>\n<p>4、循环展开：减少迭代次数</p>\n<p>5、提高并行性：多个累计变量并行求、重新结合变换</p>\n</li>\n<li><p>课本总结：</p>\n<p>1）高级设计：算法和数据结构</p>\n<p>2）基本编码原则：</p>\n<ul>\n<li><p>消除连续的函数调用：将计算移动到循环外</p>\n</li>\n<li><p>消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量</p>\n</li>\n</ul>\n<p>3）低级优化：</p>\n<ul>\n<li><p>展开循环，降低开销，并且使进一步优化成为可能</p>\n</li>\n<li><p>通过使用例如多个累积变量和重新结合等技术，提高指令集并行</p>\n</li>\n<li><p>用功能性的风格重写条件操作，使得编译采用条件数据传送</p>\n</li>\n</ul>\n</li>\n<li><p>限制因素：</p>\n<p>1、寄存器溢出</p>\n<p>2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码</p>\n</li>\n</ul>\n<h3 id=\"存储器层次结构\"><a href=\"#存储器层次结构\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h3><h4 id=\"存储技术\"><a href=\"#存储技术\" class=\"headerlink\" title=\"存储技术\"></a>存储技术</h4><h5 id=\"随机访问存储器\"><a href=\"#随机访问存储器\" class=\"headerlink\" title=\"随机访问存储器\"></a>随机访问存储器</h5><p>随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM</p>\n<p>（1）静态（SRAM）</p>\n<p>SRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一</p>\n<p>（2）动态（DRAM）</p>\n<p>DRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复</p>\n<p>对比：</p>\n<p><img src=\"/img/深入理解计算机系统/SRAM和DRAM对比.PNG\" alt=\"SRAM和DRAM对比\"></p>\n<p>（3）传统的DRAM</p>\n<p>DRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。</p>\n<p>每个超单元存储一个字节</p>\n<p>(4)内存模块</p>\n<p>–DRAM芯片封装在内存模块中，插到主板的扩展槽上</p>\n<p>–内存地址A取值过程：</p>\n<p><img src=\"/img/深入理解计算机系统/6.1.1内存地址取值.PNG\" alt=\"6.1.1内存地址取值\"></p>\n<p>（5）增强的DRAM</p>\n<p>快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM</p>\n<p>（6）非易失性存储器</p>\n<p>ROM</p>\n<p>（7）访问主存</p>\n<p>总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线</p>\n<h5 id=\"磁盘存储\"><a href=\"#磁盘存储\" class=\"headerlink\" title=\"磁盘存储\"></a>磁盘存储</h5><p>磁盘读取时间计算：</p>\n<p><img src=\"/img/深入理解计算机系统/磁盘读取时间计算.PNG\" alt=\"磁盘读取时间计算\"></p>\n<h4 id=\"局部性\"><a href=\"#局部性\" class=\"headerlink\" title=\"局部性\"></a>局部性</h4><p>   (1)重复引用相同局部变量的程序具有良好的时间局部性</p>\n<p>（2）步长越小，空间局部性越好</p>\n<p>（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好</p>\n<h4 id=\"存储器层次结构-1\"><a href=\"#存储器层次结构-1\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h4><p>存储器层次结构</p>\n<p><img src=\"/img/深入理解计算机系统/存储器层次结构.PNG\" alt=\"存储器层次结构\"></p>\n<h4 id=\"高速缓存存储器\"><a href=\"#高速缓存存储器\" class=\"headerlink\" title=\"高速缓存存储器\"></a>高速缓存存储器</h4><p>缓存不命中：</p>\n<ul>\n<li><p>冷不命中（强制性不命中）：</p>\n<p>k层缓存有空行，程序最开始运行时均为冷不命中</p>\n</li>\n<li><p>冲突不命中</p>\n<p>k层中没有空行 </p>\n</li>\n<li><p>容量不命中</p>\n</li>\n</ul>\n<p>组相连高速缓存、组相连高速缓存、全相连高速缓存</p>\n<h4 id=\"编写高速缓存存储器\"><a href=\"#编写高速缓存存储器\" class=\"headerlink\" title=\"编写高速缓存存储器\"></a>编写高速缓存存储器</h4><p>写命中：</p>\n<p>直写：高速缓存中更新的数据立即写回到低一层中</p>\n<p>写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中</p>\n<p>写不命中：</p>\n<p>写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块</p>\n<p>非写分配：避开高速缓存，直接把这个字写到低一层中</p>\n<p>**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的</p>\n<h4 id=\"综合：高速缓存对程序性能的影响\"><a href=\"#综合：高速缓存对程序性能的影响\" class=\"headerlink\" title=\"综合：高速缓存对程序性能的影响\"></a>综合：高速缓存对程序性能的影响</h4><p>如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中</p>\n<h3 id=\"异常控制流\"><a href=\"#异常控制流\" class=\"headerlink\" title=\"异常控制流\"></a>异常控制流</h3><h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现</p>\n<p>（2）事件处理：</p>\n<p><img src=\"/img/深入理解计算机系统/8.1事件处理.PNG\" alt=\"8.1事件处理\"></p>\n<p>（3）异常分类</p>\n<p><img src=\"/img/深入理解计算机系统/异常分类.PNG\" alt=\"异常分类\"></p>\n<p><img src=\"/img/深入理解计算机系统/异常分类2.PNG\" alt=\"异常分类2\"></p>\n<h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><p>进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成</p>\n<p>进程提供的关键抽象：</p>\n<p>一个独立的逻辑控制流、一个私有的地址空间</p>\n<ul>\n<li><p>并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。</p>\n</li>\n<li><p>如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行</p>\n</li>\n<li><p>进程地址空间</p>\n<p><img src=\"/img/深入理解计算机系统/进程地址空间.PNG\" alt=\"进程地址空间\"></p>\n</li>\n<li><p>用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常</p>\n</li>\n<li><p>上下文切换：</p>\n<p>1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程</p>\n</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><ul>\n<li>进程的三种状态：</li>\n</ul>\n<p>运行：进程要么被执行，要么等待被执行且被内核调度</p>\n<p>停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号</p>\n<p>终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数</p>\n<ul>\n<li>父进程和子进程最大的区别是PID不同。</li>\n</ul>\n<p>fork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；</p>\n<ul>\n<li><p>子进程和父进程：</p>\n<p>1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件</p>\n</li>\n<li><p>pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1</p>\n</li>\n<li><p>unsigned int sleep(unsigned int secs)：返回还要休眠的秒数</p>\n</li>\n<li><p>int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号</p>\n</li>\n<li><p>execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。</p>\n</li>\n</ul>\n<h4 id=\"编写信号处理程序\"><a href=\"#编写信号处理程序\" class=\"headerlink\" title=\"编写信号处理程序\"></a>编写信号处理程序</h4><p>1、安全的信号处理</p>\n<p>（1）处理程序要尽可能的简单</p>\n<p>（2）在处理程序中只调用异步信号安全的函数</p>\n<p>（3）保存和恢复errno</p>\n<p>（4）阻塞所有信号，保护对共享数据结构的访问</p>\n<p>（5）用volatile声明全局变量</p>\n<p>（6）用sig_atomic_t声明标志</p>\n<p>2、正确的信号处理：未处理的信号不排队</p>\n<p>3、可移植的信号处理</p>\n<p>由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦—–</p>\n"},{"title":"软件构造实验二","date":"2019-04-18T06:05:48.000Z","description":"实验二相对来说难度不是很大，但实验中有一些考虑不周的地方，还请多多指教","_content":"\n#### 实验目标概述\n\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象 编程（OOP）技术实现 ADT。具体来说： \n\n1、针对给定的应用问题，从问题描述中识别所需的 ADT； \n\n2、设计 ADT 规约（pre-condition、post-condition）并评估规约的质量； \n\n3、根据 ADT 的规约设计测试用例； \n\n4、ADT 的泛型化；\n\n5、根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示 （representation）、表示不变性（rep invariant）、抽象过程（abstraction function）       6、使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表 示泄露（rep exposure）； \n\n7、 测试 ADT 的实现并评估测试的覆盖度； \n\n8、使用 ADT 及其实现，为应用问题开发程序； \n\n9、在测试代码中，能够写出 testing strategy 并据此设计测试用例。\n\n#### 实验环境配置\n\n简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。\n\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n\n处理Eclipse IDE和git的使用外，在Eclipse中安装配置了EclEmma，用于统计Junit测试用例的代码覆盖度的plugin。配置过程根据网上教程，直接在eclipse中的help的MarketPlace中搜索自动安装即可。\n\n该实验还增加了对不变量的测试，主要是书写checkRep函数，然后分别在每个函数执行前调用检查不变量。\n\n在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。\n\n<https://github.com/ComputerScienceHIT/Lab2-1170300503>\n\n#### 实验过程\n\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n\n#####  Poetic Walks\n\n在这里简要概述你对该任务的理解。\n\n根据Graph接口完成ConcreteEdgesGraph实例类和ConcreteVerticsGraph实例类，然后用这两个实例化类及其方法完成拼写诗句的操作。\n\nPoet创作的抽象过程中，首先要把每个单词当做一个节点，相邻两个单词之间用有向边连接。根据给定单词拼写诗句的方法中，如果给定的相邻两个单词之间有单词，则选择出现频率最高的单词插入，否则输出语句直接拼接上该给定单词。\n\n###### Get the code and prepare Git repository\n\n根据实验指导手册（PPT），点击给定的GitHub Classroom 中的 URL地址，创建GitHub Lab2仓库，然后点击下载，将仓库下载到本地即可。\n\n由于无法连接 MIT 的 Athena 服务器，P1的代码框架是从PPT上给定的地址点击下载的，点击地址链接，找到对应的git代码库，然后通过git clone 到本地并放到Eclipse中。\n\n###### Problem 1: Test Graph \\<String>\n\nProblem相对简单，由于Graph是个接口，所以需要完成的只有静态方法empty（），该方法可返回一个新的ConcreteEdgesGraph实例化类或ConcreteVerticsGraph实例化类。\n\n######  Problem 2: Implement Graph  \\<String>\n\n以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。\n\n**Implement ConcreteEdgesGraph**\n\n​       首先，该ConcreteEdgesGraph实例化类继承Graph接口并实现接口的对应方法。\n\n​       add方法中首先判断该vertex对象是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。\n\n​       Set方法相对复杂，首先需要判断要更新的边的两个顶点是否相同，如果相同，直接返回0；否则，接着判断该条边是否已经存在，如果已经存在，若weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。\n\n​       remove方法中需要先判断该条边是否存在，如果存在，删除该条边及其顶点集中边的两个顶点中的对应关系，返回true，否则返回false，结束。\n\n​       Sources和targets方法中需要对所有边进行遍历，如果存在一条边以该顶点为target（source），则将另一个顶点加入对应的sources（targets）map集合，最终将结果集返回。\n\n \n\n** Implement ConcreteVerticesGraph**\n\n​       该ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类类似，实现方法也大致类似，首先继承Graph接口并实现接口的对应方法。\n\n​       add方法中首先判断该vertex对象是否为空，如果为空，返回false，结束；否则，判断该顶点是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。\n\n​       set方法也相对复杂，但实现方法略有不同，首先将两个顶点加入顶点集。之后，判断该条边是否已经存在，若存在且weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。\n\n​       remove方法中需要先判断该顶点是否存在，如果存在，删除该顶点及该顶点涉及的各个边，返回true，否则返回false，结束。\n\n​       Sources和targets方法中需要对该顶点的sources（targets）map集合进行遍历，如果存一条边以该顶点为target（source），则将另一个顶点加入对应的最终将结果集返回。\n\n \n\n####### Problem 3: Implement generic Graph\\<L>\n\n######  Make the implementations generic\n\n在这里将所有String类型改为泛型L，例：\n\n   \n\n​       该泛型过程中，个别类型需要强转，其他并无太大问题。\n\n######  Implement Graph.empty()\n\n这里只需将对应接口改为泛型L即可：\n\n   \n\n####### Problem 4: Poetic walks\n\n######  Test GraphPoet\n\n完成GraphPoet的测试类，根据接口定义的函数对每个方法进行测试。\n\n###### Implement GraphPoet\n\n​       按行读取文件，将每行的字母先全部转化为小写便于匹配，按空格分割。将每个单词调用add方法加入顶点集，将与之相连的前一个和后一个单词用有向边连接，构成有向图。\n\n​       给定单词生成诗句的过程中，遍历，依次查找相邻两个单词之间是否有其他单词，使之组成两个顺次的有向边，如果有这样的单词，选择出现频率最大的加入到句子中，否则直接输出前一个单词。最后输出句子的时候，需要将对应单词的大小写还原。\n\n###### Graph poetry slam\n\n首先按照要求修改main函数，然后使用不同的单词输入对各个方法进行测试。\n\n##### Before you’re done\n\n请按照<http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done>的说明，检查你的程序。\n\n如何通过Git提交当前版本到GitHub上你的Lab2仓库。\n\n找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：\n\ngit add .\n\ngit commit -m “ ”\n\ngit push origin master\n\n在这里给出你的项目的目录结构树状示意图。\n\n \n\n##### Re-implement the Social Network in Lab1\n\n在这里简要概述你对该任务的理解。\n\n该实验是基于P1中的Graph及其两种实现类ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类，重新实现Lab1中的的 FriendshipGraph 类。ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类中的add方法、set方法等可在构建社交图的时候直接调用，使得网络图的构建变得十分简单。\n\n######  FriendshipGraph类\n\nAddVertex直接调用add方法，addEdge调用set方法，变得非常简单易操作。getDistance方法利用队列，采用广搜来完成。首先将该person加入队列，并标记为已访问过，当队列不为空的时候循环：\n\n队首元素出队，搜索和当前person相关的人，如果匹配到了另一个人，返回距离值，结束；否则将搜索到的相关person依次加入队列，标记为已访问过。如果遍历的层数增加，则两个人的距离加1。\n\n最终返回距离值，结束。如果循环结束未匹配到另一个，则返回-1。\n\n######  Person类\n\n属性和唯一表示均是name，带有set/get方法，默认构造方法中传入参数name。\n\n######  客户端main()\n\n构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离并输出。\n\n######  测试用例\n\n构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离进行Junit测试。\n\n \n\n###### 提交至Git仓库\n\n如何通过Git提交当前版本到GitHub上你的Lab3仓库。\n\n找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：\n\ngit add .\n\ngit commit -m “ ”\n\ngit push origin master\n\n \n\n在这里给出你的项目的目录结构树状示意图。\n\n#### Playing Chess\n\n#####  ADT设计/实现方案\n\n设计了哪些ADT（接口、类），各自的rep和实现，各自的mutability/ immutability说明、AF、RI、safety from rep exposure。\n\n必要时请使用UML class diagram（请自学）描述你设计的各ADT间的关系。\n\n接口：Piece、Player、Position、Game、ChessAction、GoAction\n\n类：Board、ChessGame实现Game接口和ChessAction接口、GoGame类实现Game接口和GoAaction接口，ChessPiece类实现Piece接口，GoPiece实现Piece接口，ChessPlayer类实现Player接口，GoPlayer类实现Player接口，ChessType枚举，MyChessAndGoGame类\n\n最终各个方法的在main函数中调用，main函数循环执行menu函数，menu函数根据用户的选择调用对应的方法执行对应操作，menu函数的设计如下：\n\n   \n\n#####  主程序MyChessAndGoGame设计/实现方案\n\n辅之以执行过程的截图，介绍主程序的设计和实现方案，特别是如何将用户在命令行输入的指令映射到各ADT的具体方法的执行。\n\n定义的全局变量如下：\n\n   \n\nMyChessAndGoGame类中设计了统计两个玩家棋子的方法和菜单。\n\nmain函数中，先让玩家确定游戏类型，根据所选择的类型初始化棋盘等，然后创建两个玩家对象，游戏开始，循环执行menu函数。\n\nMenu函数（菜单）主要是两次循环，以便让两个玩家交替进行游戏。然后根据他们所选择的游戏类型判断游戏过程中前两项是吃子还是提子等操作，后四项选择一样，分别是查询某位置的占用情况，计算棋子总数、跳过和end，根据玩家的选项执行对应的方法。\n\nChessGame实例类中有movePiece（移动棋子）方法和eatPiece（吃子）方法及棋盘的初始化方法。movePiece方法和eatPiece方法中需要先判断输入的两个位置是否越界，是否有对应玩家的棋子等情况。GoGame实例类中实现pickPiece（提子）方法和placePiece（放置棋子）方法，实现过程中也需要输入的位置是否越界，是否有对应玩家的棋子等情况。\n\n#####  ADT和主程序的测试方案\n\n介绍针对各ADT的各方法的测试方案和testing strategy。\n\n介绍你如何对该应用进行测试用例的设计，以及具体的测试过程。\n\n分别对两种游戏进行测试。\n\n对象棋的测试方法中，首先创建ChessGame实例化对象，并创建棋盘和两个玩家，分别调用eatPiece方法和movePiece方法测试吃子和移动棋子的方法。\n\n对围棋的测试方法中，首先创建GoGame实例化对象，并创建棋盘和两个玩家，分别调用placePiece方法和pickPiece方法测试放置棋子和提子的方法。\n\n######  Multi-Startup Set (MIT)\n\n目录结构如下：\n\n   \n\n#### 实验进度记录\n\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n\n| 日期       | 时间段       | 计划任务           | 实际完成情况     |\n| ---------- | ------------ | ------------------ | ---------------- |\n| 2019-03-12 | 09:02        | 完成P1的Problem1   | 按时完成         |\n| 2019-03-13 | 18:15-19:25  | 完成P1的Problem2   | 延迟一天完成     |\n| 2019-03-13 | 19:27-23:45  | 完善Problem2的测试 | 延迟两个小时完成 |\n| 2019-03-14 | 13:55-14:10  | 完成P1的Problem3   | 按时完成         |\n| 2019-03-14 | 14:35-16:32  | 完成P1的Problem4   | 按时完成         |\n| 2019-03-14 | 18:40-19:34  | 完成P2             | 按时完成         |\n| 2019-03-22 | 10:35-16：06 | 基本完成P3         | 顺延一周完成     |\n| 2019-03-22 | 16:06-16:41  | 完善P3             | 按时完成         |\n| 2019-03-22 | 16:41-17:15  | 完善P3测试         | 按时完成         |\n\n##### 实验过程中遇到的困难与解决途径\n\n| 遇到的难点                             | 解决途径                                                     |\n| -------------------------------------- | ------------------------------------------------------------ |\n| 第一遍测试代码覆盖率较低               | 通过跟踪查询，发现大部分是因为实例类中的get/set方法未被调用，就适当的删除了一些不必要的get/set方法 |\n| 棋盘各个类的接口和对应实现类的设计困难 | 画出各个对象直之间的联系，找出不同棋类之间的联系与区别，根据关系设计接口和对应方法及实现类 |\n\n#### 实验过程中收获的经验、教训、感想\n\n#####  实验过程中收获的经验和教训\n\n要进一步深入理解ADT，注意编程规范，测试的时候尽量考虑所有情况，尽可能的提高代码覆盖率。\n\n#####  针对以下方面的感受\n\n(1)  面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？\n\n​       面向ADT编程是每一个实例对象看做一个完整的实体，更符合人的感知，同时，代码效率也大大提高了。\n\n(2)  使用泛型和不使用泛型的编程，对你来说有何差异？\n\n​       泛型的使用使得函数具有通用性。\n\n(3)  在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n\n​       面向ADT编程的过程中适应性挺快，因为符合人类的思维习惯，基本能够适应这种测试方式。\n\n(4)  P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？\n\n​       切换不同场景的时候，代码的迁移能力强，相似的场景代码可复用。\n\n(5)  P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n\n​       基本能够适应，决定P3要求很高，没有框架的约束，对接口和类的设计就要有很好的全局把握，自顶向下的设计模式很重要。\n\n(6)  为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n\n​       检查不变量。为了提高代码的正确性，愿意坚持。\n\n(7)  关于本实验的工作量、难度、deadline。\n\n​       该实验工作量适中，P3的自主设计提高了实验的难度，但实验时间还是非常充足的。\n\n(8)  《软件构造》课程进展到目前，你对该课程有何体会和建议？\n\n能够提高编程规范、设计以及健壮性等，觉得受益匪浅。","source":"_posts/软件构造实验二.md","raw":"---\ntitle: 软件构造实验二\ndate: 2019-04-18 14:05:48\ndescription: 实验二相对来说难度不是很大，但实验中有一些考虑不周的地方，还请多多指教\ntags:\n - 软件构造\ncategories: 软件构造\n---\n\n#### 实验目标概述\n\n本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象 编程（OOP）技术实现 ADT。具体来说： \n\n1、针对给定的应用问题，从问题描述中识别所需的 ADT； \n\n2、设计 ADT 规约（pre-condition、post-condition）并评估规约的质量； \n\n3、根据 ADT 的规约设计测试用例； \n\n4、ADT 的泛型化；\n\n5、根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示 （representation）、表示不变性（rep invariant）、抽象过程（abstraction function）       6、使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表 示泄露（rep exposure）； \n\n7、 测试 ADT 的实现并评估测试的覆盖度； \n\n8、使用 ADT 及其实现，为应用问题开发程序； \n\n9、在测试代码中，能够写出 testing strategy 并据此设计测试用例。\n\n#### 实验环境配置\n\n简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。\n\n特别是要记录配置过程中遇到的问题和困难，以及如何解决的。\n\n处理Eclipse IDE和git的使用外，在Eclipse中安装配置了EclEmma，用于统计Junit测试用例的代码覆盖度的plugin。配置过程根据网上教程，直接在eclipse中的help的MarketPlace中搜索自动安装即可。\n\n该实验还增加了对不变量的测试，主要是书写checkRep函数，然后分别在每个函数执行前调用检查不变量。\n\n在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。\n\n<https://github.com/ComputerScienceHIT/Lab2-1170300503>\n\n#### 实验过程\n\n请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。\n\n#####  Poetic Walks\n\n在这里简要概述你对该任务的理解。\n\n根据Graph接口完成ConcreteEdgesGraph实例类和ConcreteVerticsGraph实例类，然后用这两个实例化类及其方法完成拼写诗句的操作。\n\nPoet创作的抽象过程中，首先要把每个单词当做一个节点，相邻两个单词之间用有向边连接。根据给定单词拼写诗句的方法中，如果给定的相邻两个单词之间有单词，则选择出现频率最高的单词插入，否则输出语句直接拼接上该给定单词。\n\n###### Get the code and prepare Git repository\n\n根据实验指导手册（PPT），点击给定的GitHub Classroom 中的 URL地址，创建GitHub Lab2仓库，然后点击下载，将仓库下载到本地即可。\n\n由于无法连接 MIT 的 Athena 服务器，P1的代码框架是从PPT上给定的地址点击下载的，点击地址链接，找到对应的git代码库，然后通过git clone 到本地并放到Eclipse中。\n\n###### Problem 1: Test Graph \\<String>\n\nProblem相对简单，由于Graph是个接口，所以需要完成的只有静态方法empty（），该方法可返回一个新的ConcreteEdgesGraph实例化类或ConcreteVerticsGraph实例化类。\n\n######  Problem 2: Implement Graph  \\<String>\n\n以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。\n\n**Implement ConcreteEdgesGraph**\n\n​       首先，该ConcreteEdgesGraph实例化类继承Graph接口并实现接口的对应方法。\n\n​       add方法中首先判断该vertex对象是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。\n\n​       Set方法相对复杂，首先需要判断要更新的边的两个顶点是否相同，如果相同，直接返回0；否则，接着判断该条边是否已经存在，如果已经存在，若weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。\n\n​       remove方法中需要先判断该条边是否存在，如果存在，删除该条边及其顶点集中边的两个顶点中的对应关系，返回true，否则返回false，结束。\n\n​       Sources和targets方法中需要对所有边进行遍历，如果存在一条边以该顶点为target（source），则将另一个顶点加入对应的sources（targets）map集合，最终将结果集返回。\n\n \n\n** Implement ConcreteVerticesGraph**\n\n​       该ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类类似，实现方法也大致类似，首先继承Graph接口并实现接口的对应方法。\n\n​       add方法中首先判断该vertex对象是否为空，如果为空，返回false，结束；否则，判断该顶点是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。\n\n​       set方法也相对复杂，但实现方法略有不同，首先将两个顶点加入顶点集。之后，判断该条边是否已经存在，若存在且weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。\n\n​       remove方法中需要先判断该顶点是否存在，如果存在，删除该顶点及该顶点涉及的各个边，返回true，否则返回false，结束。\n\n​       Sources和targets方法中需要对该顶点的sources（targets）map集合进行遍历，如果存一条边以该顶点为target（source），则将另一个顶点加入对应的最终将结果集返回。\n\n \n\n####### Problem 3: Implement generic Graph\\<L>\n\n######  Make the implementations generic\n\n在这里将所有String类型改为泛型L，例：\n\n   \n\n​       该泛型过程中，个别类型需要强转，其他并无太大问题。\n\n######  Implement Graph.empty()\n\n这里只需将对应接口改为泛型L即可：\n\n   \n\n####### Problem 4: Poetic walks\n\n######  Test GraphPoet\n\n完成GraphPoet的测试类，根据接口定义的函数对每个方法进行测试。\n\n###### Implement GraphPoet\n\n​       按行读取文件，将每行的字母先全部转化为小写便于匹配，按空格分割。将每个单词调用add方法加入顶点集，将与之相连的前一个和后一个单词用有向边连接，构成有向图。\n\n​       给定单词生成诗句的过程中，遍历，依次查找相邻两个单词之间是否有其他单词，使之组成两个顺次的有向边，如果有这样的单词，选择出现频率最大的加入到句子中，否则直接输出前一个单词。最后输出句子的时候，需要将对应单词的大小写还原。\n\n###### Graph poetry slam\n\n首先按照要求修改main函数，然后使用不同的单词输入对各个方法进行测试。\n\n##### Before you’re done\n\n请按照<http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done>的说明，检查你的程序。\n\n如何通过Git提交当前版本到GitHub上你的Lab2仓库。\n\n找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：\n\ngit add .\n\ngit commit -m “ ”\n\ngit push origin master\n\n在这里给出你的项目的目录结构树状示意图。\n\n \n\n##### Re-implement the Social Network in Lab1\n\n在这里简要概述你对该任务的理解。\n\n该实验是基于P1中的Graph及其两种实现类ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类，重新实现Lab1中的的 FriendshipGraph 类。ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类中的add方法、set方法等可在构建社交图的时候直接调用，使得网络图的构建变得十分简单。\n\n######  FriendshipGraph类\n\nAddVertex直接调用add方法，addEdge调用set方法，变得非常简单易操作。getDistance方法利用队列，采用广搜来完成。首先将该person加入队列，并标记为已访问过，当队列不为空的时候循环：\n\n队首元素出队，搜索和当前person相关的人，如果匹配到了另一个人，返回距离值，结束；否则将搜索到的相关person依次加入队列，标记为已访问过。如果遍历的层数增加，则两个人的距离加1。\n\n最终返回距离值，结束。如果循环结束未匹配到另一个，则返回-1。\n\n######  Person类\n\n属性和唯一表示均是name，带有set/get方法，默认构造方法中传入参数name。\n\n######  客户端main()\n\n构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离并输出。\n\n######  测试用例\n\n构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离进行Junit测试。\n\n \n\n###### 提交至Git仓库\n\n如何通过Git提交当前版本到GitHub上你的Lab3仓库。\n\n找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：\n\ngit add .\n\ngit commit -m “ ”\n\ngit push origin master\n\n \n\n在这里给出你的项目的目录结构树状示意图。\n\n#### Playing Chess\n\n#####  ADT设计/实现方案\n\n设计了哪些ADT（接口、类），各自的rep和实现，各自的mutability/ immutability说明、AF、RI、safety from rep exposure。\n\n必要时请使用UML class diagram（请自学）描述你设计的各ADT间的关系。\n\n接口：Piece、Player、Position、Game、ChessAction、GoAction\n\n类：Board、ChessGame实现Game接口和ChessAction接口、GoGame类实现Game接口和GoAaction接口，ChessPiece类实现Piece接口，GoPiece实现Piece接口，ChessPlayer类实现Player接口，GoPlayer类实现Player接口，ChessType枚举，MyChessAndGoGame类\n\n最终各个方法的在main函数中调用，main函数循环执行menu函数，menu函数根据用户的选择调用对应的方法执行对应操作，menu函数的设计如下：\n\n   \n\n#####  主程序MyChessAndGoGame设计/实现方案\n\n辅之以执行过程的截图，介绍主程序的设计和实现方案，特别是如何将用户在命令行输入的指令映射到各ADT的具体方法的执行。\n\n定义的全局变量如下：\n\n   \n\nMyChessAndGoGame类中设计了统计两个玩家棋子的方法和菜单。\n\nmain函数中，先让玩家确定游戏类型，根据所选择的类型初始化棋盘等，然后创建两个玩家对象，游戏开始，循环执行menu函数。\n\nMenu函数（菜单）主要是两次循环，以便让两个玩家交替进行游戏。然后根据他们所选择的游戏类型判断游戏过程中前两项是吃子还是提子等操作，后四项选择一样，分别是查询某位置的占用情况，计算棋子总数、跳过和end，根据玩家的选项执行对应的方法。\n\nChessGame实例类中有movePiece（移动棋子）方法和eatPiece（吃子）方法及棋盘的初始化方法。movePiece方法和eatPiece方法中需要先判断输入的两个位置是否越界，是否有对应玩家的棋子等情况。GoGame实例类中实现pickPiece（提子）方法和placePiece（放置棋子）方法，实现过程中也需要输入的位置是否越界，是否有对应玩家的棋子等情况。\n\n#####  ADT和主程序的测试方案\n\n介绍针对各ADT的各方法的测试方案和testing strategy。\n\n介绍你如何对该应用进行测试用例的设计，以及具体的测试过程。\n\n分别对两种游戏进行测试。\n\n对象棋的测试方法中，首先创建ChessGame实例化对象，并创建棋盘和两个玩家，分别调用eatPiece方法和movePiece方法测试吃子和移动棋子的方法。\n\n对围棋的测试方法中，首先创建GoGame实例化对象，并创建棋盘和两个玩家，分别调用placePiece方法和pickPiece方法测试放置棋子和提子的方法。\n\n######  Multi-Startup Set (MIT)\n\n目录结构如下：\n\n   \n\n#### 实验进度记录\n\n请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。\n\n| 日期       | 时间段       | 计划任务           | 实际完成情况     |\n| ---------- | ------------ | ------------------ | ---------------- |\n| 2019-03-12 | 09:02        | 完成P1的Problem1   | 按时完成         |\n| 2019-03-13 | 18:15-19:25  | 完成P1的Problem2   | 延迟一天完成     |\n| 2019-03-13 | 19:27-23:45  | 完善Problem2的测试 | 延迟两个小时完成 |\n| 2019-03-14 | 13:55-14:10  | 完成P1的Problem3   | 按时完成         |\n| 2019-03-14 | 14:35-16:32  | 完成P1的Problem4   | 按时完成         |\n| 2019-03-14 | 18:40-19:34  | 完成P2             | 按时完成         |\n| 2019-03-22 | 10:35-16：06 | 基本完成P3         | 顺延一周完成     |\n| 2019-03-22 | 16:06-16:41  | 完善P3             | 按时完成         |\n| 2019-03-22 | 16:41-17:15  | 完善P3测试         | 按时完成         |\n\n##### 实验过程中遇到的困难与解决途径\n\n| 遇到的难点                             | 解决途径                                                     |\n| -------------------------------------- | ------------------------------------------------------------ |\n| 第一遍测试代码覆盖率较低               | 通过跟踪查询，发现大部分是因为实例类中的get/set方法未被调用，就适当的删除了一些不必要的get/set方法 |\n| 棋盘各个类的接口和对应实现类的设计困难 | 画出各个对象直之间的联系，找出不同棋类之间的联系与区别，根据关系设计接口和对应方法及实现类 |\n\n#### 实验过程中收获的经验、教训、感想\n\n#####  实验过程中收获的经验和教训\n\n要进一步深入理解ADT，注意编程规范，测试的时候尽量考虑所有情况，尽可能的提高代码覆盖率。\n\n#####  针对以下方面的感受\n\n(1)  面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？\n\n​       面向ADT编程是每一个实例对象看做一个完整的实体，更符合人的感知，同时，代码效率也大大提高了。\n\n(2)  使用泛型和不使用泛型的编程，对你来说有何差异？\n\n​       泛型的使用使得函数具有通用性。\n\n(3)  在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？\n\n​       面向ADT编程的过程中适应性挺快，因为符合人类的思维习惯，基本能够适应这种测试方式。\n\n(4)  P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？\n\n​       切换不同场景的时候，代码的迁移能力强，相似的场景代码可复用。\n\n(5)  P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？\n\n​       基本能够适应，决定P3要求很高，没有框架的约束，对接口和类的设计就要有很好的全局把握，自顶向下的设计模式很重要。\n\n(6)  为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？\n\n​       检查不变量。为了提高代码的正确性，愿意坚持。\n\n(7)  关于本实验的工作量、难度、deadline。\n\n​       该实验工作量适中，P3的自主设计提高了实验的难度，但实验时间还是非常充足的。\n\n(8)  《软件构造》课程进展到目前，你对该课程有何体会和建议？\n\n能够提高编程规范、设计以及健壮性等，觉得受益匪浅。","slug":"软件构造实验二","published":1,"updated":"2019-05-17T08:37:37.627Z","_id":"cjvrtri59000ttku3f0s35heu","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"实验目标概述\"><a href=\"#实验目标概述\" class=\"headerlink\" title=\"实验目标概述\"></a>实验目标概述</h4><p>本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象 编程（OOP）技术实现 ADT。具体来说： </p>\n<p>1、针对给定的应用问题，从问题描述中识别所需的 ADT； </p>\n<p>2、设计 ADT 规约（pre-condition、post-condition）并评估规约的质量； </p>\n<p>3、根据 ADT 的规约设计测试用例； </p>\n<p>4、ADT 的泛型化；</p>\n<p>5、根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示 （representation）、表示不变性（rep invariant）、抽象过程（abstraction function）       6、使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表 示泄露（rep exposure）； </p>\n<p>7、 测试 ADT 的实现并评估测试的覆盖度； </p>\n<p>8、使用 ADT 及其实现，为应用问题开发程序； </p>\n<p>9、在测试代码中，能够写出 testing strategy 并据此设计测试用例。</p>\n<h4 id=\"实验环境配置\"><a href=\"#实验环境配置\" class=\"headerlink\" title=\"实验环境配置\"></a>实验环境配置</h4><p>简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。</p>\n<p>特别是要记录配置过程中遇到的问题和困难，以及如何解决的。</p>\n<p>处理Eclipse IDE和git的使用外，在Eclipse中安装配置了EclEmma，用于统计Junit测试用例的代码覆盖度的plugin。配置过程根据网上教程，直接在eclipse中的help的MarketPlace中搜索自动安装即可。</p>\n<p>该实验还增加了对不变量的测试，主要是书写checkRep函数，然后分别在每个函数执行前调用检查不变量。</p>\n<p>在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。</p>\n<p><a href=\"https://github.com/ComputerScienceHIT/Lab2-1170300503\" target=\"_blank\" rel=\"noopener\">https://github.com/ComputerScienceHIT/Lab2-1170300503</a></p>\n<h4 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h4><p>请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。</p>\n<h5 id=\"Poetic-Walks\"><a href=\"#Poetic-Walks\" class=\"headerlink\" title=\"Poetic Walks\"></a>Poetic Walks</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>根据Graph接口完成ConcreteEdgesGraph实例类和ConcreteVerticsGraph实例类，然后用这两个实例化类及其方法完成拼写诗句的操作。</p>\n<p>Poet创作的抽象过程中，首先要把每个单词当做一个节点，相邻两个单词之间用有向边连接。根据给定单词拼写诗句的方法中，如果给定的相邻两个单词之间有单词，则选择出现频率最高的单词插入，否则输出语句直接拼接上该给定单词。</p>\n<h6 id=\"Get-the-code-and-prepare-Git-repository\"><a href=\"#Get-the-code-and-prepare-Git-repository\" class=\"headerlink\" title=\"Get the code and prepare Git repository\"></a>Get the code and prepare Git repository</h6><p>根据实验指导手册（PPT），点击给定的GitHub Classroom 中的 URL地址，创建GitHub Lab2仓库，然后点击下载，将仓库下载到本地即可。</p>\n<p>由于无法连接 MIT 的 Athena 服务器，P1的代码框架是从PPT上给定的地址点击下载的，点击地址链接，找到对应的git代码库，然后通过git clone 到本地并放到Eclipse中。</p>\n<h6 id=\"Problem-1-Test-Graph\"><a href=\"#Problem-1-Test-Graph\" class=\"headerlink\" title=\"Problem 1: Test Graph \\\"></a>Problem 1: Test Graph \\<string></string></h6><p>Problem相对简单，由于Graph是个接口，所以需要完成的只有静态方法empty（），该方法可返回一个新的ConcreteEdgesGraph实例化类或ConcreteVerticsGraph实例化类。</p>\n<h6 id=\"Problem-2-Implement-Graph\"><a href=\"#Problem-2-Implement-Graph\" class=\"headerlink\" title=\"Problem 2: Implement Graph  \\\"></a>Problem 2: Implement Graph  \\<string></string></h6><p>以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。</p>\n<p><strong>Implement ConcreteEdgesGraph</strong></p>\n<p>​       首先，该ConcreteEdgesGraph实例化类继承Graph接口并实现接口的对应方法。</p>\n<p>​       add方法中首先判断该vertex对象是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。</p>\n<p>​       Set方法相对复杂，首先需要判断要更新的边的两个顶点是否相同，如果相同，直接返回0；否则，接着判断该条边是否已经存在，如果已经存在，若weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。</p>\n<p>​       remove方法中需要先判断该条边是否存在，如果存在，删除该条边及其顶点集中边的两个顶点中的对应关系，返回true，否则返回false，结束。</p>\n<p>​       Sources和targets方法中需要对所有边进行遍历，如果存在一条边以该顶点为target（source），则将另一个顶点加入对应的sources（targets）map集合，最终将结果集返回。</p>\n<p><strong> Implement ConcreteVerticesGraph</strong></p>\n<p>​       该ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类类似，实现方法也大致类似，首先继承Graph接口并实现接口的对应方法。</p>\n<p>​       add方法中首先判断该vertex对象是否为空，如果为空，返回false，结束；否则，判断该顶点是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。</p>\n<p>​       set方法也相对复杂，但实现方法略有不同，首先将两个顶点加入顶点集。之后，判断该条边是否已经存在，若存在且weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。</p>\n<p>​       remove方法中需要先判断该顶点是否存在，如果存在，删除该顶点及该顶点涉及的各个边，返回true，否则返回false，结束。</p>\n<p>​       Sources和targets方法中需要对该顶点的sources（targets）map集合进行遍历，如果存一条边以该顶点为target（source），则将另一个顶点加入对应的最终将结果集返回。</p>\n<p>####### Problem 3: Implement generic Graph\\<l></l></p>\n<h6 id=\"Make-the-implementations-generic\"><a href=\"#Make-the-implementations-generic\" class=\"headerlink\" title=\"Make the implementations generic\"></a>Make the implementations generic</h6><p>在这里将所有String类型改为泛型L，例：</p>\n<p>​       该泛型过程中，个别类型需要强转，其他并无太大问题。</p>\n<h6 id=\"Implement-Graph-empty\"><a href=\"#Implement-Graph-empty\" class=\"headerlink\" title=\"Implement Graph.empty()\"></a>Implement Graph.empty()</h6><p>这里只需将对应接口改为泛型L即可：</p>\n<p>####### Problem 4: Poetic walks</p>\n<h6 id=\"Test-GraphPoet\"><a href=\"#Test-GraphPoet\" class=\"headerlink\" title=\"Test GraphPoet\"></a>Test GraphPoet</h6><p>完成GraphPoet的测试类，根据接口定义的函数对每个方法进行测试。</p>\n<h6 id=\"Implement-GraphPoet\"><a href=\"#Implement-GraphPoet\" class=\"headerlink\" title=\"Implement GraphPoet\"></a>Implement GraphPoet</h6><p>​       按行读取文件，将每行的字母先全部转化为小写便于匹配，按空格分割。将每个单词调用add方法加入顶点集，将与之相连的前一个和后一个单词用有向边连接，构成有向图。</p>\n<p>​       给定单词生成诗句的过程中，遍历，依次查找相邻两个单词之间是否有其他单词，使之组成两个顺次的有向边，如果有这样的单词，选择出现频率最大的加入到句子中，否则直接输出前一个单词。最后输出句子的时候，需要将对应单词的大小写还原。</p>\n<h6 id=\"Graph-poetry-slam\"><a href=\"#Graph-poetry-slam\" class=\"headerlink\" title=\"Graph poetry slam\"></a>Graph poetry slam</h6><p>首先按照要求修改main函数，然后使用不同的单词输入对各个方法进行测试。</p>\n<h5 id=\"Before-you’re-done\"><a href=\"#Before-you’re-done\" class=\"headerlink\" title=\"Before you’re done\"></a>Before you’re done</h5><p>请按照<a href=\"http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done\" target=\"_blank\" rel=\"noopener\">http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done</a>的说明，检查你的程序。</p>\n<p>如何通过Git提交当前版本到GitHub上你的Lab2仓库。</p>\n<p>找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：</p>\n<p>git add .</p>\n<p>git commit -m “ ”</p>\n<p>git push origin master</p>\n<p>在这里给出你的项目的目录结构树状示意图。</p>\n<h5 id=\"Re-implement-the-Social-Network-in-Lab1\"><a href=\"#Re-implement-the-Social-Network-in-Lab1\" class=\"headerlink\" title=\"Re-implement the Social Network in Lab1\"></a>Re-implement the Social Network in Lab1</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>该实验是基于P1中的Graph及其两种实现类ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类，重新实现Lab1中的的 FriendshipGraph 类。ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类中的add方法、set方法等可在构建社交图的时候直接调用，使得网络图的构建变得十分简单。</p>\n<h6 id=\"FriendshipGraph类\"><a href=\"#FriendshipGraph类\" class=\"headerlink\" title=\"FriendshipGraph类\"></a>FriendshipGraph类</h6><p>AddVertex直接调用add方法，addEdge调用set方法，变得非常简单易操作。getDistance方法利用队列，采用广搜来完成。首先将该person加入队列，并标记为已访问过，当队列不为空的时候循环：</p>\n<p>队首元素出队，搜索和当前person相关的人，如果匹配到了另一个人，返回距离值，结束；否则将搜索到的相关person依次加入队列，标记为已访问过。如果遍历的层数增加，则两个人的距离加1。</p>\n<p>最终返回距离值，结束。如果循环结束未匹配到另一个，则返回-1。</p>\n<h6 id=\"Person类\"><a href=\"#Person类\" class=\"headerlink\" title=\"Person类\"></a>Person类</h6><p>属性和唯一表示均是name，带有set/get方法，默认构造方法中传入参数name。</p>\n<h6 id=\"客户端main\"><a href=\"#客户端main\" class=\"headerlink\" title=\"客户端main()\"></a>客户端main()</h6><p>构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离并输出。</p>\n<h6 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h6><p>构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离进行Junit测试。</p>\n<h6 id=\"提交至Git仓库\"><a href=\"#提交至Git仓库\" class=\"headerlink\" title=\"提交至Git仓库\"></a>提交至Git仓库</h6><p>如何通过Git提交当前版本到GitHub上你的Lab3仓库。</p>\n<p>找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：</p>\n<p>git add .</p>\n<p>git commit -m “ ”</p>\n<p>git push origin master</p>\n<p>在这里给出你的项目的目录结构树状示意图。</p>\n<h4 id=\"Playing-Chess\"><a href=\"#Playing-Chess\" class=\"headerlink\" title=\"Playing Chess\"></a>Playing Chess</h4><h5 id=\"ADT设计-实现方案\"><a href=\"#ADT设计-实现方案\" class=\"headerlink\" title=\"ADT设计/实现方案\"></a>ADT设计/实现方案</h5><p>设计了哪些ADT（接口、类），各自的rep和实现，各自的mutability/ immutability说明、AF、RI、safety from rep exposure。</p>\n<p>必要时请使用UML class diagram（请自学）描述你设计的各ADT间的关系。</p>\n<p>接口：Piece、Player、Position、Game、ChessAction、GoAction</p>\n<p>类：Board、ChessGame实现Game接口和ChessAction接口、GoGame类实现Game接口和GoAaction接口，ChessPiece类实现Piece接口，GoPiece实现Piece接口，ChessPlayer类实现Player接口，GoPlayer类实现Player接口，ChessType枚举，MyChessAndGoGame类</p>\n<p>最终各个方法的在main函数中调用，main函数循环执行menu函数，menu函数根据用户的选择调用对应的方法执行对应操作，menu函数的设计如下：</p>\n<h5 id=\"主程序MyChessAndGoGame设计-实现方案\"><a href=\"#主程序MyChessAndGoGame设计-实现方案\" class=\"headerlink\" title=\"主程序MyChessAndGoGame设计/实现方案\"></a>主程序MyChessAndGoGame设计/实现方案</h5><p>辅之以执行过程的截图，介绍主程序的设计和实现方案，特别是如何将用户在命令行输入的指令映射到各ADT的具体方法的执行。</p>\n<p>定义的全局变量如下：</p>\n<p>MyChessAndGoGame类中设计了统计两个玩家棋子的方法和菜单。</p>\n<p>main函数中，先让玩家确定游戏类型，根据所选择的类型初始化棋盘等，然后创建两个玩家对象，游戏开始，循环执行menu函数。</p>\n<p>Menu函数（菜单）主要是两次循环，以便让两个玩家交替进行游戏。然后根据他们所选择的游戏类型判断游戏过程中前两项是吃子还是提子等操作，后四项选择一样，分别是查询某位置的占用情况，计算棋子总数、跳过和end，根据玩家的选项执行对应的方法。</p>\n<p>ChessGame实例类中有movePiece（移动棋子）方法和eatPiece（吃子）方法及棋盘的初始化方法。movePiece方法和eatPiece方法中需要先判断输入的两个位置是否越界，是否有对应玩家的棋子等情况。GoGame实例类中实现pickPiece（提子）方法和placePiece（放置棋子）方法，实现过程中也需要输入的位置是否越界，是否有对应玩家的棋子等情况。</p>\n<h5 id=\"ADT和主程序的测试方案\"><a href=\"#ADT和主程序的测试方案\" class=\"headerlink\" title=\"ADT和主程序的测试方案\"></a>ADT和主程序的测试方案</h5><p>介绍针对各ADT的各方法的测试方案和testing strategy。</p>\n<p>介绍你如何对该应用进行测试用例的设计，以及具体的测试过程。</p>\n<p>分别对两种游戏进行测试。</p>\n<p>对象棋的测试方法中，首先创建ChessGame实例化对象，并创建棋盘和两个玩家，分别调用eatPiece方法和movePiece方法测试吃子和移动棋子的方法。</p>\n<p>对围棋的测试方法中，首先创建GoGame实例化对象，并创建棋盘和两个玩家，分别调用placePiece方法和pickPiece方法测试放置棋子和提子的方法。</p>\n<h6 id=\"Multi-Startup-Set-MIT\"><a href=\"#Multi-Startup-Set-MIT\" class=\"headerlink\" title=\"Multi-Startup Set (MIT)\"></a>Multi-Startup Set (MIT)</h6><p>目录结构如下：</p>\n<h4 id=\"实验进度记录\"><a href=\"#实验进度记录\" class=\"headerlink\" title=\"实验进度记录\"></a>实验进度记录</h4><p>请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。</p>\n<table>\n<thead>\n<tr>\n<th>日期</th>\n<th>时间段</th>\n<th>计划任务</th>\n<th>实际完成情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2019-03-12</td>\n<td>09:02</td>\n<td>完成P1的Problem1</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-13</td>\n<td>18:15-19:25</td>\n<td>完成P1的Problem2</td>\n<td>延迟一天完成</td>\n</tr>\n<tr>\n<td>2019-03-13</td>\n<td>19:27-23:45</td>\n<td>完善Problem2的测试</td>\n<td>延迟两个小时完成</td>\n</tr>\n<tr>\n<td>2019-03-14</td>\n<td>13:55-14:10</td>\n<td>完成P1的Problem3</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-14</td>\n<td>14:35-16:32</td>\n<td>完成P1的Problem4</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-14</td>\n<td>18:40-19:34</td>\n<td>完成P2</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-22</td>\n<td>10:35-16：06</td>\n<td>基本完成P3</td>\n<td>顺延一周完成</td>\n</tr>\n<tr>\n<td>2019-03-22</td>\n<td>16:06-16:41</td>\n<td>完善P3</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-22</td>\n<td>16:41-17:15</td>\n<td>完善P3测试</td>\n<td>按时完成</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"实验过程中遇到的困难与解决途径\"><a href=\"#实验过程中遇到的困难与解决途径\" class=\"headerlink\" title=\"实验过程中遇到的困难与解决途径\"></a>实验过程中遇到的困难与解决途径</h5><table>\n<thead>\n<tr>\n<th>遇到的难点</th>\n<th>解决途径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一遍测试代码覆盖率较低</td>\n<td>通过跟踪查询，发现大部分是因为实例类中的get/set方法未被调用，就适当的删除了一些不必要的get/set方法</td>\n</tr>\n<tr>\n<td>棋盘各个类的接口和对应实现类的设计困难</td>\n<td>画出各个对象直之间的联系，找出不同棋类之间的联系与区别，根据关系设计接口和对应方法及实现类</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验过程中收获的经验、教训、感想\"><a href=\"#实验过程中收获的经验、教训、感想\" class=\"headerlink\" title=\"实验过程中收获的经验、教训、感想\"></a>实验过程中收获的经验、教训、感想</h4><h5 id=\"实验过程中收获的经验和教训\"><a href=\"#实验过程中收获的经验和教训\" class=\"headerlink\" title=\"实验过程中收获的经验和教训\"></a>实验过程中收获的经验和教训</h5><p>要进一步深入理解ADT，注意编程规范，测试的时候尽量考虑所有情况，尽可能的提高代码覆盖率。</p>\n<h5 id=\"针对以下方面的感受\"><a href=\"#针对以下方面的感受\" class=\"headerlink\" title=\"针对以下方面的感受\"></a>针对以下方面的感受</h5><p>(1)  面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？</p>\n<p>​       面向ADT编程是每一个实例对象看做一个完整的实体，更符合人的感知，同时，代码效率也大大提高了。</p>\n<p>(2)  使用泛型和不使用泛型的编程，对你来说有何差异？</p>\n<p>​       泛型的使用使得函数具有通用性。</p>\n<p>(3)  在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？</p>\n<p>​       面向ADT编程的过程中适应性挺快，因为符合人类的思维习惯，基本能够适应这种测试方式。</p>\n<p>(4)  P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？</p>\n<p>​       切换不同场景的时候，代码的迁移能力强，相似的场景代码可复用。</p>\n<p>(5)  P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？</p>\n<p>​       基本能够适应，决定P3要求很高，没有框架的约束，对接口和类的设计就要有很好的全局把握，自顶向下的设计模式很重要。</p>\n<p>(6)  为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？</p>\n<p>​       检查不变量。为了提高代码的正确性，愿意坚持。</p>\n<p>(7)  关于本实验的工作量、难度、deadline。</p>\n<p>​       该实验工作量适中，P3的自主设计提高了实验的难度，但实验时间还是非常充足的。</p>\n<p>(8)  《软件构造》课程进展到目前，你对该课程有何体会和建议？</p>\n<p>能够提高编程规范、设计以及健壮性等，觉得受益匪浅。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"实验目标概述\"><a href=\"#实验目标概述\" class=\"headerlink\" title=\"实验目标概述\"></a>实验目标概述</h4><p>本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象 编程（OOP）技术实现 ADT。具体来说： </p>\n<p>1、针对给定的应用问题，从问题描述中识别所需的 ADT； </p>\n<p>2、设计 ADT 规约（pre-condition、post-condition）并评估规约的质量； </p>\n<p>3、根据 ADT 的规约设计测试用例； </p>\n<p>4、ADT 的泛型化；</p>\n<p>5、根据规约设计 ADT 的多种不同的实现；针对每种实现，设计其表示 （representation）、表示不变性（rep invariant）、抽象过程（abstraction function）       6、使用 OOP 实现 ADT，并判定表示不变性是否违反、各实现是否存在表 示泄露（rep exposure）； </p>\n<p>7、 测试 ADT 的实现并评估测试的覆盖度； </p>\n<p>8、使用 ADT 及其实现，为应用问题开发程序； </p>\n<p>9、在测试代码中，能够写出 testing strategy 并据此设计测试用例。</p>\n<h4 id=\"实验环境配置\"><a href=\"#实验环境配置\" class=\"headerlink\" title=\"实验环境配置\"></a>实验环境配置</h4><p>简要陈述你配置本次实验所需环境的过程，必要时可以给出屏幕截图。</p>\n<p>特别是要记录配置过程中遇到的问题和困难，以及如何解决的。</p>\n<p>处理Eclipse IDE和git的使用外，在Eclipse中安装配置了EclEmma，用于统计Junit测试用例的代码覆盖度的plugin。配置过程根据网上教程，直接在eclipse中的help的MarketPlace中搜索自动安装即可。</p>\n<p>该实验还增加了对不变量的测试，主要是书写checkRep函数，然后分别在每个函数执行前调用检查不变量。</p>\n<p>在这里给出你的GitHub Lab2仓库的URL地址（Lab2-学号）。</p>\n<p><a href=\"https://github.com/ComputerScienceHIT/Lab2-1170300503\" target=\"_blank\" rel=\"noopener\">https://github.com/ComputerScienceHIT/Lab2-1170300503</a></p>\n<h4 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h4><p>请仔细对照实验手册，针对三个问题中的每一项任务，在下面各节中记录你的实验过程、阐述你的设计思路和问题求解思路，可辅之以示意图或关键源代码加以说明（但千万不要把你的源代码全部粘贴过来！）。</p>\n<h5 id=\"Poetic-Walks\"><a href=\"#Poetic-Walks\" class=\"headerlink\" title=\"Poetic Walks\"></a>Poetic Walks</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>根据Graph接口完成ConcreteEdgesGraph实例类和ConcreteVerticsGraph实例类，然后用这两个实例化类及其方法完成拼写诗句的操作。</p>\n<p>Poet创作的抽象过程中，首先要把每个单词当做一个节点，相邻两个单词之间用有向边连接。根据给定单词拼写诗句的方法中，如果给定的相邻两个单词之间有单词，则选择出现频率最高的单词插入，否则输出语句直接拼接上该给定单词。</p>\n<h6 id=\"Get-the-code-and-prepare-Git-repository\"><a href=\"#Get-the-code-and-prepare-Git-repository\" class=\"headerlink\" title=\"Get the code and prepare Git repository\"></a>Get the code and prepare Git repository</h6><p>根据实验指导手册（PPT），点击给定的GitHub Classroom 中的 URL地址，创建GitHub Lab2仓库，然后点击下载，将仓库下载到本地即可。</p>\n<p>由于无法连接 MIT 的 Athena 服务器，P1的代码框架是从PPT上给定的地址点击下载的，点击地址链接，找到对应的git代码库，然后通过git clone 到本地并放到Eclipse中。</p>\n<h6 id=\"Problem-1-Test-Graph\"><a href=\"#Problem-1-Test-Graph\" class=\"headerlink\" title=\"Problem 1: Test Graph \\\"></a>Problem 1: Test Graph \\<string></string></h6><p>Problem相对简单，由于Graph是个接口，所以需要完成的只有静态方法empty（），该方法可返回一个新的ConcreteEdgesGraph实例化类或ConcreteVerticsGraph实例化类。</p>\n<h6 id=\"Problem-2-Implement-Graph\"><a href=\"#Problem-2-Implement-Graph\" class=\"headerlink\" title=\"Problem 2: Implement Graph  \\\"></a>Problem 2: Implement Graph  \\<string></string></h6><p>以下各部分，请按照MIT页面上相应部分的要求，逐项列出你的设计和实现思路/过程/结果。</p>\n<p><strong>Implement ConcreteEdgesGraph</strong></p>\n<p>​       首先，该ConcreteEdgesGraph实例化类继承Graph接口并实现接口的对应方法。</p>\n<p>​       add方法中首先判断该vertex对象是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。</p>\n<p>​       Set方法相对复杂，首先需要判断要更新的边的两个顶点是否相同，如果相同，直接返回0；否则，接着判断该条边是否已经存在，如果已经存在，若weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。</p>\n<p>​       remove方法中需要先判断该条边是否存在，如果存在，删除该条边及其顶点集中边的两个顶点中的对应关系，返回true，否则返回false，结束。</p>\n<p>​       Sources和targets方法中需要对所有边进行遍历，如果存在一条边以该顶点为target（source），则将另一个顶点加入对应的sources（targets）map集合，最终将结果集返回。</p>\n<p><strong> Implement ConcreteVerticesGraph</strong></p>\n<p>​       该ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类类似，实现方法也大致类似，首先继承Graph接口并实现接口的对应方法。</p>\n<p>​       add方法中首先判断该vertex对象是否为空，如果为空，返回false，结束；否则，判断该顶点是否已经被添加，如果未被添加，则add到顶点集中，返回true，否则直接返回false。</p>\n<p>​       set方法也相对复杂，但实现方法略有不同，首先将两个顶点加入顶点集。之后，判断该条边是否已经存在，若存在且weight不等于0，则将边的权重更新，否则将该条边删除，返回该边之前的weight，结束。若该条边不存在，若weight=0,则直接返回0，结束，否则，加上该条边，返回0，结束。</p>\n<p>​       remove方法中需要先判断该顶点是否存在，如果存在，删除该顶点及该顶点涉及的各个边，返回true，否则返回false，结束。</p>\n<p>​       Sources和targets方法中需要对该顶点的sources（targets）map集合进行遍历，如果存一条边以该顶点为target（source），则将另一个顶点加入对应的最终将结果集返回。</p>\n<p>####### Problem 3: Implement generic Graph\\<l></l></p>\n<h6 id=\"Make-the-implementations-generic\"><a href=\"#Make-the-implementations-generic\" class=\"headerlink\" title=\"Make the implementations generic\"></a>Make the implementations generic</h6><p>在这里将所有String类型改为泛型L，例：</p>\n<p>​       该泛型过程中，个别类型需要强转，其他并无太大问题。</p>\n<h6 id=\"Implement-Graph-empty\"><a href=\"#Implement-Graph-empty\" class=\"headerlink\" title=\"Implement Graph.empty()\"></a>Implement Graph.empty()</h6><p>这里只需将对应接口改为泛型L即可：</p>\n<p>####### Problem 4: Poetic walks</p>\n<h6 id=\"Test-GraphPoet\"><a href=\"#Test-GraphPoet\" class=\"headerlink\" title=\"Test GraphPoet\"></a>Test GraphPoet</h6><p>完成GraphPoet的测试类，根据接口定义的函数对每个方法进行测试。</p>\n<h6 id=\"Implement-GraphPoet\"><a href=\"#Implement-GraphPoet\" class=\"headerlink\" title=\"Implement GraphPoet\"></a>Implement GraphPoet</h6><p>​       按行读取文件，将每行的字母先全部转化为小写便于匹配，按空格分割。将每个单词调用add方法加入顶点集，将与之相连的前一个和后一个单词用有向边连接，构成有向图。</p>\n<p>​       给定单词生成诗句的过程中，遍历，依次查找相邻两个单词之间是否有其他单词，使之组成两个顺次的有向边，如果有这样的单词，选择出现频率最大的加入到句子中，否则直接输出前一个单词。最后输出句子的时候，需要将对应单词的大小写还原。</p>\n<h6 id=\"Graph-poetry-slam\"><a href=\"#Graph-poetry-slam\" class=\"headerlink\" title=\"Graph poetry slam\"></a>Graph poetry slam</h6><p>首先按照要求修改main函数，然后使用不同的单词输入对各个方法进行测试。</p>\n<h5 id=\"Before-you’re-done\"><a href=\"#Before-you’re-done\" class=\"headerlink\" title=\"Before you’re done\"></a>Before you’re done</h5><p>请按照<a href=\"http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done\" target=\"_blank\" rel=\"noopener\">http://web.mit.edu/6.031/www/sp17/psets/ps2/#before_youre_done</a>的说明，检查你的程序。</p>\n<p>如何通过Git提交当前版本到GitHub上你的Lab2仓库。</p>\n<p>找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：</p>\n<p>git add .</p>\n<p>git commit -m “ ”</p>\n<p>git push origin master</p>\n<p>在这里给出你的项目的目录结构树状示意图。</p>\n<h5 id=\"Re-implement-the-Social-Network-in-Lab1\"><a href=\"#Re-implement-the-Social-Network-in-Lab1\" class=\"headerlink\" title=\"Re-implement the Social Network in Lab1\"></a>Re-implement the Social Network in Lab1</h5><p>在这里简要概述你对该任务的理解。</p>\n<p>该实验是基于P1中的Graph及其两种实现类ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类，重新实现Lab1中的的 FriendshipGraph 类。ConcreteVerticessGraph实例化类和ConcreteEdgesGraph实例化类中的add方法、set方法等可在构建社交图的时候直接调用，使得网络图的构建变得十分简单。</p>\n<h6 id=\"FriendshipGraph类\"><a href=\"#FriendshipGraph类\" class=\"headerlink\" title=\"FriendshipGraph类\"></a>FriendshipGraph类</h6><p>AddVertex直接调用add方法，addEdge调用set方法，变得非常简单易操作。getDistance方法利用队列，采用广搜来完成。首先将该person加入队列，并标记为已访问过，当队列不为空的时候循环：</p>\n<p>队首元素出队，搜索和当前person相关的人，如果匹配到了另一个人，返回距离值，结束；否则将搜索到的相关person依次加入队列，标记为已访问过。如果遍历的层数增加，则两个人的距离加1。</p>\n<p>最终返回距离值，结束。如果循环结束未匹配到另一个，则返回-1。</p>\n<h6 id=\"Person类\"><a href=\"#Person类\" class=\"headerlink\" title=\"Person类\"></a>Person类</h6><p>属性和唯一表示均是name，带有set/get方法，默认构造方法中传入参数name。</p>\n<h6 id=\"客户端main\"><a href=\"#客户端main\" class=\"headerlink\" title=\"客户端main()\"></a>客户端main()</h6><p>构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离并输出。</p>\n<h6 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h6><p>构造实例化对象FriendshipGraph和四个不同姓名的person对象，调用add方法将四个person加入到有向图中，然后设计person之间的关系，并调用set方法完成对应有向图的构造，最后，调用getDistance方法计算其中两个人的距离进行Junit测试。</p>\n<h6 id=\"提交至Git仓库\"><a href=\"#提交至Git仓库\" class=\"headerlink\" title=\"提交至Git仓库\"></a>提交至Git仓库</h6><p>如何通过Git提交当前版本到GitHub上你的Lab3仓库。</p>\n<p>找到本地仓库所在目录，将Eclise中的项目复制更新到仓库，然后，右键，点击git bash here，在git命令框中使用如下命令提交：</p>\n<p>git add .</p>\n<p>git commit -m “ ”</p>\n<p>git push origin master</p>\n<p>在这里给出你的项目的目录结构树状示意图。</p>\n<h4 id=\"Playing-Chess\"><a href=\"#Playing-Chess\" class=\"headerlink\" title=\"Playing Chess\"></a>Playing Chess</h4><h5 id=\"ADT设计-实现方案\"><a href=\"#ADT设计-实现方案\" class=\"headerlink\" title=\"ADT设计/实现方案\"></a>ADT设计/实现方案</h5><p>设计了哪些ADT（接口、类），各自的rep和实现，各自的mutability/ immutability说明、AF、RI、safety from rep exposure。</p>\n<p>必要时请使用UML class diagram（请自学）描述你设计的各ADT间的关系。</p>\n<p>接口：Piece、Player、Position、Game、ChessAction、GoAction</p>\n<p>类：Board、ChessGame实现Game接口和ChessAction接口、GoGame类实现Game接口和GoAaction接口，ChessPiece类实现Piece接口，GoPiece实现Piece接口，ChessPlayer类实现Player接口，GoPlayer类实现Player接口，ChessType枚举，MyChessAndGoGame类</p>\n<p>最终各个方法的在main函数中调用，main函数循环执行menu函数，menu函数根据用户的选择调用对应的方法执行对应操作，menu函数的设计如下：</p>\n<h5 id=\"主程序MyChessAndGoGame设计-实现方案\"><a href=\"#主程序MyChessAndGoGame设计-实现方案\" class=\"headerlink\" title=\"主程序MyChessAndGoGame设计/实现方案\"></a>主程序MyChessAndGoGame设计/实现方案</h5><p>辅之以执行过程的截图，介绍主程序的设计和实现方案，特别是如何将用户在命令行输入的指令映射到各ADT的具体方法的执行。</p>\n<p>定义的全局变量如下：</p>\n<p>MyChessAndGoGame类中设计了统计两个玩家棋子的方法和菜单。</p>\n<p>main函数中，先让玩家确定游戏类型，根据所选择的类型初始化棋盘等，然后创建两个玩家对象，游戏开始，循环执行menu函数。</p>\n<p>Menu函数（菜单）主要是两次循环，以便让两个玩家交替进行游戏。然后根据他们所选择的游戏类型判断游戏过程中前两项是吃子还是提子等操作，后四项选择一样，分别是查询某位置的占用情况，计算棋子总数、跳过和end，根据玩家的选项执行对应的方法。</p>\n<p>ChessGame实例类中有movePiece（移动棋子）方法和eatPiece（吃子）方法及棋盘的初始化方法。movePiece方法和eatPiece方法中需要先判断输入的两个位置是否越界，是否有对应玩家的棋子等情况。GoGame实例类中实现pickPiece（提子）方法和placePiece（放置棋子）方法，实现过程中也需要输入的位置是否越界，是否有对应玩家的棋子等情况。</p>\n<h5 id=\"ADT和主程序的测试方案\"><a href=\"#ADT和主程序的测试方案\" class=\"headerlink\" title=\"ADT和主程序的测试方案\"></a>ADT和主程序的测试方案</h5><p>介绍针对各ADT的各方法的测试方案和testing strategy。</p>\n<p>介绍你如何对该应用进行测试用例的设计，以及具体的测试过程。</p>\n<p>分别对两种游戏进行测试。</p>\n<p>对象棋的测试方法中，首先创建ChessGame实例化对象，并创建棋盘和两个玩家，分别调用eatPiece方法和movePiece方法测试吃子和移动棋子的方法。</p>\n<p>对围棋的测试方法中，首先创建GoGame实例化对象，并创建棋盘和两个玩家，分别调用placePiece方法和pickPiece方法测试放置棋子和提子的方法。</p>\n<h6 id=\"Multi-Startup-Set-MIT\"><a href=\"#Multi-Startup-Set-MIT\" class=\"headerlink\" title=\"Multi-Startup Set (MIT)\"></a>Multi-Startup Set (MIT)</h6><p>目录结构如下：</p>\n<h4 id=\"实验进度记录\"><a href=\"#实验进度记录\" class=\"headerlink\" title=\"实验进度记录\"></a>实验进度记录</h4><p>请使用表格方式记录你的进度情况，以超过半小时的连续编程时间为一行。</p>\n<table>\n<thead>\n<tr>\n<th>日期</th>\n<th>时间段</th>\n<th>计划任务</th>\n<th>实际完成情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2019-03-12</td>\n<td>09:02</td>\n<td>完成P1的Problem1</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-13</td>\n<td>18:15-19:25</td>\n<td>完成P1的Problem2</td>\n<td>延迟一天完成</td>\n</tr>\n<tr>\n<td>2019-03-13</td>\n<td>19:27-23:45</td>\n<td>完善Problem2的测试</td>\n<td>延迟两个小时完成</td>\n</tr>\n<tr>\n<td>2019-03-14</td>\n<td>13:55-14:10</td>\n<td>完成P1的Problem3</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-14</td>\n<td>14:35-16:32</td>\n<td>完成P1的Problem4</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-14</td>\n<td>18:40-19:34</td>\n<td>完成P2</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-22</td>\n<td>10:35-16：06</td>\n<td>基本完成P3</td>\n<td>顺延一周完成</td>\n</tr>\n<tr>\n<td>2019-03-22</td>\n<td>16:06-16:41</td>\n<td>完善P3</td>\n<td>按时完成</td>\n</tr>\n<tr>\n<td>2019-03-22</td>\n<td>16:41-17:15</td>\n<td>完善P3测试</td>\n<td>按时完成</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"实验过程中遇到的困难与解决途径\"><a href=\"#实验过程中遇到的困难与解决途径\" class=\"headerlink\" title=\"实验过程中遇到的困难与解决途径\"></a>实验过程中遇到的困难与解决途径</h5><table>\n<thead>\n<tr>\n<th>遇到的难点</th>\n<th>解决途径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一遍测试代码覆盖率较低</td>\n<td>通过跟踪查询，发现大部分是因为实例类中的get/set方法未被调用，就适当的删除了一些不必要的get/set方法</td>\n</tr>\n<tr>\n<td>棋盘各个类的接口和对应实现类的设计困难</td>\n<td>画出各个对象直之间的联系，找出不同棋类之间的联系与区别，根据关系设计接口和对应方法及实现类</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验过程中收获的经验、教训、感想\"><a href=\"#实验过程中收获的经验、教训、感想\" class=\"headerlink\" title=\"实验过程中收获的经验、教训、感想\"></a>实验过程中收获的经验、教训、感想</h4><h5 id=\"实验过程中收获的经验和教训\"><a href=\"#实验过程中收获的经验和教训\" class=\"headerlink\" title=\"实验过程中收获的经验和教训\"></a>实验过程中收获的经验和教训</h5><p>要进一步深入理解ADT，注意编程规范，测试的时候尽量考虑所有情况，尽可能的提高代码覆盖率。</p>\n<h5 id=\"针对以下方面的感受\"><a href=\"#针对以下方面的感受\" class=\"headerlink\" title=\"针对以下方面的感受\"></a>针对以下方面的感受</h5><p>(1)  面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？</p>\n<p>​       面向ADT编程是每一个实例对象看做一个完整的实体，更符合人的感知，同时，代码效率也大大提高了。</p>\n<p>(2)  使用泛型和不使用泛型的编程，对你来说有何差异？</p>\n<p>​       泛型的使用使得函数具有通用性。</p>\n<p>(3)  在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？</p>\n<p>​       面向ADT编程的过程中适应性挺快，因为符合人类的思维习惯，基本能够适应这种测试方式。</p>\n<p>(4)  P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？</p>\n<p>​       切换不同场景的时候，代码的迁移能力强，相似的场景代码可复用。</p>\n<p>(5)  P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？</p>\n<p>​       基本能够适应，决定P3要求很高，没有框架的约束，对接口和类的设计就要有很好的全局把握，自顶向下的设计模式很重要。</p>\n<p>(6)  为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？</p>\n<p>​       检查不变量。为了提高代码的正确性，愿意坚持。</p>\n<p>(7)  关于本实验的工作量、难度、deadline。</p>\n<p>​       该实验工作量适中，P3的自主设计提高了实验的难度，但实验时间还是非常充足的。</p>\n<p>(8)  《软件构造》课程进展到目前，你对该课程有何体会和建议？</p>\n<p>能够提高编程规范、设计以及健壮性等，觉得受益匪浅。</p>\n"},{"title":"哈尔滨工业大学数据结构2018年秋期末复习","urlname":"hit_data_structure_review","mathjax":true,"description":"这里尽可能详细的记录了数据结构的知识点，如果能完全掌握这些知识点，期末考试基本哦了\\(^o^)/~","abbrlink":22353,"date":"2019-03-05T06:00:00.000Z","_content":"\n#### 绪论\n\n##### 抽象数据类型\n\n- 抽象数据类型:(Abstract Date Type)\n\n\t-定义：一个数学模型和该模型上定义的操作集合的总称\n\t\n\t*ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象\n\t\n\t*同一数学模型上定义的不同操作集，则他们代表不同的ADT\n\t\n\t-表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作\n\n- 逻辑结构：\n\n  集合——没关系\n\n  线性表——1:1前后\n\n  树——1：m层次\n\n  图——网状\n\n- 存储结构：\n\n  ​\t顺序——连续空间 \t\t $\\Rightarrow$索引\n\n  ​\t链式——不连续空间      \t+散列\n\n##### 算法及算法分析\n\n- 算法的相关概念\n\n\t-算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列\n\t\n\t-五大特性：输入   输出   有穷性   确定性\n\n- 时间复杂度（time  xomplexity)\n\n\t算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度\n\n- 常见时间复杂度的比较\n\n0(1)< <0(logn) <<0(n)< < 0(nlogn) << 0(n2) << 0(n3) <<0(2n) << 0(n!)\n\n- 常见设计方法：\n\n穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)\n\n$\\alpha -\\beta$裁剪和分支界限法、并行算法\n\n- 时空资源的折中原理\n\n同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质\n\n##### 逐步求精的程序设计方法\n\n​\t模型化-确定算法-逐步求精\t\n\n#### 线性表\n\n##### 线性表的抽象数据类型\n\n​\t 顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素\n\n##### 线性表的实现\n\n存储结构的三种方式：\n\n ① 连续的存储空间（数组） →  静态存储\n\n ② 非连续存储空间——指针（链表） →  动态存储\n\n ③ 游标（连续存储空间+动态管理思想）→  静态链表\n\n###### 线性表的数组实现：\n\n随机存储结构，查找快   o(1)\n\n插入和删除慢  o(n)\n\n空间固定\n\n###### 链表\n\n非随机存储结构\n\neg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2\n\n​\t求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走\n\n- 插入元素\n\n  a、保存后继指针\n\n  b、申请一个内存空间\n\n  c、插入：先链接后部分，再衔接前部分\n\n###### 游标\n\n元素是结构体数组，多个线性表公用一个存储池\n\n单链表逆置：\n\n```c\n//方法一：\n//设表头为L,算法如下: \np=L->next->next; q=p->next; L->next->next=NULL; while(p!=null) {\n    p->next=L->next;\n    L->next=p;\n    p=q;\n    q=q->next; \n}\n//方法二：\n//线性表由q来表示 \np=null; w=q; while(w!=null) { \n    w=w->next; \n    q->next=p;\n    p=q; q=w; \n}\n```\n\n###### 双向链表\n\n双向单链表插入与删除：\n\n<img src=\"/img/ds/双向单链表.PNG\" width=\"60%\">\n\n###### 环形链表\n\n- 数组求模可以成环\n\n- 判断链表是否成环：两个指针，速度分别为1和2,\n\n- 确定环入口：\n\n- 两个链表是否相交:判断两个列表最后一个元素是否相同//散列\n\n- 单项循环链表插入与删除：\n\n<img src=\"/img/ds/双循环1.PNG\" width=\"60%\">\n\n<img src=\"/img/ds/双循环2.PNG\" width=\"60%\">\n\n##### 栈\n\n- 多项式的代数运算\n\n<img src=\"/img/ds/中缀转后缀表达式.PNG\" width=\"60%\">\n\n- 后缀表达式求值：\n\n  对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。\n\n##### 队列\n\n优先队列：\n\n问题：如何解决循环队列中队空与队满状态相同？\n方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；\n\n 方法二：另设一个标志位用以区别队空与队满两种状态；\n结论：两种方法的代价是相同的。\n\n##### 串（String）\n\nKMP算法：\n\n一、如何求next函数:\n\n- 当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 \n\n-  当j>1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。\n-   当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较\n\n下面给出求next函数的伪码：\n\n```c\nvoid get_next(SString T, int &next[]) {\n\n //求模式串T的next函数并存入next数组\n\n int i = 1; next[1] = 0; int j = 0;\n\n while (i < T[0]) //T[0]中存放数组长度 {\n\n if( j==0||T[i]==T[j]) { ++i; ++j;  next[i]=j; } \n\nelse j= next[j]; }\n\n }//get_next\n```\n\n二、KMP算法实现步骤：\n\n   1.在串S和串T中分别设比较的起始下标i和j；\n2. 循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕 \n   2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则 \n   2.2将j向右滑动到next[j]位置，即j=next[j]； \n   2.3 如果j=0，则将i和j分别加1，准备下一趟比较；\n3. 如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；\n\n##### 广义表\n\n例如：\n\n A = （a，（b，a，b），（），c，（（（2））））； \n\nB = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；\n\n长度：广义表LS中的直接元素的个数；\n深度：广义表LS中括号的最大嵌套层数。\n表头：广义表LS非空时，称第一个元素为LS的表头；\n表尾：广义表LS中除表头外其余元素组成的广义表。\n\n#### 树与二叉树\n\n##### 二叉树\n\n###### 性质：\n\n在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关\n\n###### 建立\n\n建立：\n\n<img src=\"/img/ds/建立1.PNG\" width=\"60%\">\n\n先序建立：\n\n<img src=\"/img/ds/先序建立.PNG\" width=\"60%\">\n\n非递归建立：\n\n<img src=\"/img/ds/建立非.PNG\" width=\"60%\">\n\n###### 遍历\n\n- 先序递归：\n\n<img src=\"/img/ds/先序.PNG\" width=\"60%\">\n\n- 先序非递归：\n\n1.栈s初始化； \n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 输出root->data;\n \t\t2.1.2 将指针root的值保存到栈中；\n​\t\t2.1.3 继续遍历root的左子树 \n​\t2.2 如果栈s不空，则\n​\t\t2.2.1 将栈顶元素弹出至root；\n​\t\t2.2.2 准备遍历root的右子树；\n\n- 中序非递归：\n\n1.栈s初始化； \n\n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 将指针root的值保存到栈中；\n \t\t2.1.2 继续遍历root的左子树 \n \t2.2 如果栈s不空，则\n \t\t2.2.1 将栈顶元素弹出至root；\n \t\t2.2.2 输出root->data; \n​\t\t2.2.3 准备遍历root的右子树\n\n- 后序非递归：\n\n1. 栈s初始化； \n2. 循环直到root为空且栈s为空 \n\t2.1 当root非空时循环\n\t​\t2.1.1 将root连同标志flag=1 入栈； \n\t​\t2.1.2 继续遍历root的左子树；\n\t2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点; \n\t2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；\n\n<img src=\"/img/ds/二叉树先序遍历.PNG\" width=\"60%\">\n\n- 层序遍历：\n\n1. 队列Q初始化；\n2. 如果二叉树非空，将根指针入队；\n3. 循环直到队列Q为空\n   3.1 q=队列Q的队头元素出队；\n   3.2 访问结点q的数据域； \n   3.3 若结点q存在左孩子，则将左孩子指针入队； \n   3.4 若结点q存在右孩子，则将右孩子指针入队；\n\n###### 应用\n\n- 1、已知先序中序确定二叉树：\n\n遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，\n​\t如果栈为空，将下标 j 入栈；\n​\t否则，栈不为空：\n​\t\t如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈\n\n<img src=\"/img/ds/已知先序中序构二叉树.PNG\" width=\"60%\">\n\n- 2、求二叉树任意两节点公共祖先：\n\n```c\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root) \n        return NULL;//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个\n    if (root == p || root == q) \n        return root;//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个\n    TreeNode *L = lowestCommonAncestor(root->left, p, q);//左子树中是否能最先找到p,q中的一个节点\n    TreeNode *R = lowestCommonAncestor(root->right, p, q);\n    if (L && R) \n        return root;  //如果当前节点左右节点都各找到一个，那么返回当前节点\n    return L ? L : R; //只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面\n    }\n```\n\n\n\n- 3、求二叉树宽度：\n\n```c\nint  front=-1,rear=-1,count=0,max=0,right\nif (T!=NULL) \n\tq[++rear]=T;max=1;right=rear; \nwhile(front!=rear) {\n\tT=q[++front];\n\tif(T->lc!=NULL)q[++rear]=T->lc; count++;\n\tif(T->rc!=NULL q[++rear]=T->rc; count++; \n\tif(front==right) { \n\t\tif(max<count)max=count; count=0;right=rear;}\n }\n```\n\n- 4、线索树：\n\n1）在中序线索二叉树中求一个结点p的中序后继p：\n\n​\t当p->rtag==False时，p->rchild 即为所求(线索)。\n\n \t当p->rtag==True时，p为p 的右子树的最左结点\n\n2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树\n\n```\nvoid ThInOrder(ThTree HEAD) {  \nThTree   tmp ; tmp = HEAD ; \n  do { \n  \ttmp = InNext ( tmp ) ; \n if ( tmp != HEAD ) visit ( tmp -> data ) ;\n} while ( tmp != HEAD ) ; }\n```\n\n  3）求中序线索二叉树中结点p 的先序顺序后继结点p* \n\n(1) p 的左子树不空时，p 的左儿子p->lchild 即为 p*；\n(2) p 的左子树空但右子树不空时，p 的p->rchild 为p*；\n(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.\n\n```\nTHTREE PreNext( ThTree p) {   \n\tThTree Q ;\n\tif (p->ltag = = True ) Q=p->lchild ; \n\telse{\n\t\tQ = p;\n\t\twhile(Q->rtag = = False) Q = Q->rchild ; \n\t\tQ = Q->rchild ;\n\t}  return ( Q ) ; \n```\n\n- 相似二叉树:具有相同结构的二叉树为相似二叉树。 \n\n- 相似且对应结点包含相同信息的二叉树称为等价二叉树。 \n\n##### 堆\n\n最大堆：\n\n如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆\n\n- 大根堆插入：\n\nvoid Insert ( Heap &heap，Elementtype x)//大根堆插入一个元素 { \n​\tint i; \n​\tif ( ! HeapFull ( heap ) ) { \n​\t\ti=heap.n+1; \n​\t\twhile ( (i!=1)&&(x >heap.ele [i/2] ) ) {  \n​\t\t\theap.ele [i]=heap.ele [i/2]; i=i/2;\n \t} heap.ele [i] = x;\n\n- 大根堆删除：\n\n```c\nvoid DeleteMax (Heap & heap )//大根堆删除 {  \n\tint parent=1, child=2;  Elementtype  ele,  tmp;\n\tif (! HeapEmpty(heap)) { \n\t\tele=heap.ele [1]; tmp=heap.ele [heap.n--];\n \t\twhile (child<= heap.n){\n\t\t\tif(child<heap.n)&&(heap.ele [child]<heap.ele [child+1]))\n                \tchild++;\n\t\t\tif (tmp>=heap.ele [child])  break;\n\t\t\theap.ele [parent]=heap.ele [child]; \n\t\t\tparent=child; child*=2;\n\t\t}//while\n \t\theap.ele [parent]=tmp; return ele; \n\t}//if\n}\n```\n\n\n\n##### 选择树\n\n​\t胜者树、败者树\n\n##### 树\n\n存储结构：\n\n双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））\n\n|          | 树         | 二叉树       |\n| -------- | ---------- | ------------ |\n| 节点关系 | 兄弟关系   | 双亲和右孩子 |\n|          | 双亲和长子 | 双亲和左孩子 |\n\n##### 森林与二叉树的相互转换\n\n- 森林转化成二叉树：\n\n1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）\n\n 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 \n\n3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）\n\n- 二叉树转化成森林（树）\n\n连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；\n\n 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; \n\n旋转： 按逆时针旋转45度角（即把结点按层次排列）\n\n- 将一株树转换为二叉树，二叉树一定没有右子树\n-  一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；\n-  任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；\n\n- 森林(树)转换成二叉树的递归算法：\n\n F ={T1,T2, …,Tn}   \n二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则 \n B(F)的根就是root（T1）；\n B(F)的左子树是F的第一棵树T1的子树森林；\n B(F)的右子树F的其余子树森林。 \n\n- 二叉树转换成森林(树) 的递归算法 ：\n\n若B 为空，则F 为空；若B 不空，则\n F中的第一株树T1 的根对应二叉树B 的根； \n T1中根结点的子树森林F1是由B的左子树转换来的；\n F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。\n\n##### 树的应用\n\n- 堆的复杂度：O(n)\n\n- 败者树的复杂度：O(2n-1)\n\n###### 用树结构表示集合：\n\n等价分类算法： \n1. 令S中的每一个元素自身构成一个等价类，S1,S2,…S7 \n\n2. 重复读入等价对（i,  j） \n   2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性） \n   2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。\n\n```c\nvoid Equivalence (MFSET S)   //等价分类算法 { \n   int i ,j , k ,m; \n   for(i=1; i<=n+1;i++) Initial(i,S);  //使集合S只包含元素i\n   cin>>i>>j;        // 读入等价对\n   while(!(i==0&&j==0){ // 等价对未读完\n       k=Find(i,S);           //求i的根 \n       m=Find(j,S);        // 求j的根\n       if(k!=m)          //if k==m,i,j已在一个树中，不需合并 \n           Union(i,j,S);     //合并 \n       cin<<i<<j;          \n   }  }\n```\n\n###### 判定树\n\n判定树的特点：\n\n 一个判定树是一个算法的描述； \n每个内部结点对应一个部分解； 每个叶子对应一个解； \n每个内部结点连接与一个获得新信息的测试；\n 从每个结点出发的分支标记着不同的测试结果；\n 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合\n\n判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$\n\n###### 哈夫曼树：\n\n- 内外路径：\n\n<img src=\"/img/ds/内外路径.PNG\" width=\"60%\">\n\n- 哈夫曼树性质：\n\n没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。\n\n<img src=\"/img/ds/哈夫曼树性质1.PNG\" width=\"60%\">\n\n- 码长计算：\n\n<img src=\"/img/ds/码长计算.PNG\" width=\"60%\">\n\n- 哈夫曼编码一定具有前缀性；\n  哈夫曼编码是最小冗余码; \n  哈夫曼编码方法，使出现概率大的字符对应的码长较短；\n  哈夫曼编码不唯一，可以用于加密；\n  哈夫曼编码译码简单唯一，没有二义性.\n\n###### 表达式求值\n\n把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值\n\n 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。\n\n#### 图\n\n简单路径：若路径上各顶点 v1,v2,...,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。\n\n 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。\n\n##### 图的存储结构\n\n|          | 空间性能 | 时间性能 | 唯一性 |适用范围|\n| -------- | -------- | -------- | ------ |-----|\n| 邻接矩阵 | O(n^2)   | O(n^2)   |           唯一   |稠密图|\n| 邻接表   | O(n+e)   | O(n+e)   |          不唯一 |稀疏图|\n\n十字链表、邻接多重表\n\n##### 图的搜索\n\n- 深度优先搜索\n\n从一个顶点出发的一次深度优先遍历算法：\n实现步骤： \n1. 访问顶点v; visited[v]=1; \n2. w=顶点v的第一个邻接点； \n3.  while (w存在) \n    3.1 if (w未被访问) 从顶点w出发递归执行该算法; \n    3.2 w=顶点v的下一个邻接点;\n\n邻接矩阵：空间：O(n^2)       时间： O(n^2)\n\n邻接表：O(n)  O(V+E)\n\n\n\n- 广度优先搜索\n\n1 . 初始化队列Q;\n2. 访问顶点v; visited [v]=1; 顶点v入队Q;\n3. while (队列Q非空) \n    3.1 v=队列Q的队头元素出队;\n    3.2 w=顶点v的第一个邻接点;\n    3.3 while (w存在) \n       3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n       3.3.2 w=顶点v的下一个邻接点；\n\n##### 图与树、最小生成树\n\n###### 先深和先广生成森林\n\n- 先深搜索对边的分类 \n  两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;  \n  结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然\n- 先广搜索对边的分类 \n  两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.\n  结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然\n\n###### 无向图与开放树\n\n连通而无环路的无向图称作开放树（Free  Tree）\n\n（1）具有n≥1个顶点的开放树包含n-1条边； \n\n（2）如果在开放树中任意加上一条边，便得到一条回路\n\n###### 最小生成树算法\n\n- 普里姆Prim算法：\n\n基本思想 \n① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ } \n② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U \n③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树\n\n如何找到连接U和V-U的最短边 ：\n利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。\n\n1. 初始化两个辅助数组LOWCOST和CLOSEST；\n\n2. 输出顶点v0，将顶点v0加入集合U中；\n\n3. 重复执行下列操作n-1次\n   3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；\n   3.2 输出顶点k和对应的权值； \n   3.3 将顶点k加入集合U中； \n   3.4 调整数组LOWCOST和CLOSEST；\n\n   LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]} \n   CLOSEST[j]=k\n\n时间复杂度：O(n^2)\n\n- 克鲁斯卡尔（Kruskal）算法\n\n注：边值各不相同时生成树唯一\n\n基本思想：\n设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }， \n然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。 \n若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，\n如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。\n\n1. 初始化：U=V； TE={ }； \n2. 循环直到T中的连通分量个数为1  \n    2.1 在E中选择最短边(u，v); \n    2.2 如果顶点u、v位于T的两个不同连通分量，则 \n    ​\t2.2.1 将边(u，v)并入TE； \n    ​\t2.2.2 将这两个连通分量合为一个；\n    2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取\n\n时间复杂度：O(eloge)\n\n##### 无向图的双连通性\n\n若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。\n\n1、没有关节点的连通图称为双连通图。\n2、双连通的无向图是连通的，但连通的无向图未必双连通。\n3、一个连通的无向图是双连通的，当且仅当它没有关节点。  \n4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。 \n5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。\n\n- 由先深生成树可得出两类关节点的特性：\n\n 1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 \n\n2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来\n\n算法要点：\n 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。\n 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：\n (1)  dfn[v]；\n (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；\n (3)  low[y]，对v的任何儿子y。\n 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。\n\n```c\n//求双连通分量的算法 \nvoid main() { \n\tcount = 1; for (all v ∈ V)  mark v “new”; searchB( v0 );\n}\n\n//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)\nvoid searchB(v) { \n\tmark v “old”;\n\tdfn[v] = count;count++; \n\tlow[v]=dfn[v]; \n \tfor (each w ∈ L[v])\n     \tif (w is marked “new”) { \n         \tfather [w]=v；searchB (w); \n         \tlow [v]= min { low [v], low [w] }; \n        \tif (low[w]>=dfn[v]) //表明W及子孙均无指向V的祖先的回退边，v是关节点\n           \t cout<<“a biconnected component”; } \n    \telse if (w != father [v]) //(v ,w)是回退边   \n          low [v]= min { low [v],  dfn [w] };\n```\n\n\n\n##### 拓扑排序\n\n是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） \n\n实质：广度优先搜索算法\n\nAOV网（有向图）\n\n- 利用队列算法：\n  1.建立入度为零的顶点排队 \n  2.扫描顶点表，将入度为0的顶点入队；\n  3.while（排队不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入队 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n- 利用栈算法：\n  1.建立入度为零的顶点栈 \n  2.扫描顶点表，将入度为0的顶点栈；\n  3.while（栈不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入栈 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。\n\n- 说明：\n  - 与先广搜索的差别：\n    ​      搜索起点是入度为0的顶点；\n    ​      需判断是否有环路；\n    ​      需对访问并输出的顶点计数（引入计数器nodes）。\n    ​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。\n  - 也可以采用栈数据结构进行广度优先拓扑排序。 \n  - 亦可采用无后继顶点优先的拓扑排序算法\n  - 也可以利用DFS遍历进行拓扑排序\n- 基于DFS的拓扑排序\n\n```c\nvoid topodfs ( v ) {   \n    Push( v ,S ) ; \n    mark[v]=True; \n    for ( L[v] 中的每一个顶点w) \n        if ( mark[w] = False ) topodfs ( w ) ; \n    printf ( Top( S ) ) ; \n    Pop ( S ) ; \n}\n\nvoid  dfs-topo ( GRAPH  L ) {  \n    MakeNull( S ); \n    for( u=1;u<=n; u++) \n        mark[u]=False; \n    for( u=1;u<=n;u++) \n        if ( !mark[u] ) \n            topodfs( u ) ; \n```\n\n思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。\n\n##### 关键路径\n\nAOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）\n\n最大长度的路径称为关键路径。 \n一个AOE中，关键路径可能不只一条。\n关键活动：关键路径上的活动称为关键活动。\n\n关键路径算法步骤：\n\n（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}\n其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）\n\n（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }\n其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S\n\n（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 \n\n（４）若某条边满足E( i ) = L( i )，则它是关键活动。\n\n注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。\n\n##### 最短路径\n\n- 边上权值非负情形的单源最短路径问题 — Dijkstra算法 \n\nDijkstra算法实现步骤：\n1. 将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。\n2. 从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。\n3. 调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 \n4. 重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。\n\n```c\ncosttype MinCost (D, S) { \n\ttemp = INFINITY ; w = 2 ;\n\tfor ( i=2 ; i<=n ; i++ )\n\t\tif (!S[i]&&D[i]<temp)  {\n  \t\t\ttemp = D[i] ; w = i ; } \n\treturn  w ;\n}\n\nvoid  Dijkstra(GRAPH  C, costtype D[n+1] ，int P[n+1]，bool S[n+1]) { \n\tfor ( i=2 ; i<=n; i++ ) {  \n\tD[i]=C[1][i] ; S[i]=False ;P[i]=1;}\n\tS [1]= True ; \n\tfor( i=1; i<=n-1; i++) {  \n\t\tw=MinCost ( D, S ) ; S[w]=True ; \n\tfor ( v=2 ; v<= n ; n++ ) \n\t\tif ( S[v]!=True ) {  \n        \t        sum=D[w] + C[w][v] ;\n \t\t\tif (sum < D[v】 ){D[v] = sum ; P[v]=w;}\n\t\t}\n    }\n }//   时间复杂度：O（n^2）\n```\n\n\n\n- 所有顶点之间的最短路径问题 — Floyd算法 \n\n基本思想：动态规划\n\n求解过程：\n\n设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i ---> j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞\n\n 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] \n\n2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。\n\n```c\nvoid Floyd( costtype A[][], costtype C[][], int P[][], int n) {   \n\tfor ( i = 0; i < n; i++ )\n\t\tfor ( j = 0; j< n; j++ ) {\n\t\t\tA[i][j] = C[i][j];  P[i][j] = -1； }\n\tfor ( k = 0; k < n; k++ ) \n\t\tfor ( i = 0; i < n; i++ ) \n\t\t\tfor ( j = 0; j < n; j++ )\n\t\t\t\tif ( A[i][k] + A[k][j] < A[i][j] ){ \n                \tA[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;\n            } \n} /* 时间复杂度：O(n3) */\nWarshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]);\n可以判定有向图任意两点间是否存在有向 路。\n```\n\n#### 查找\n\n\n\n##### 线性查找\n\n插入和删除：从后往前\n\n第0个元素做为伪记录或哨兵 \n\n##### 折半查找\n\n折半查找只适合于静态查找\n\n- 数组：时间复杂度O(logn)\n\n- 判定树:\n\n高度： (n+1)/nlog2(n+1)-1\n\n当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近\n\n##### 分块查找\n\n基本思想：均匀分块，块间有序，块内无序\n\n索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.\n\n块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j \n\n所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。\n\n##### BST-二叉查找树\n\n- 插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. \n\n- 删除：\n\n1. 若结点p是叶子，则直接删除结点p； \n2. 若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； \n3. 若结点p的左右子树均不空，则 \n    3.1 查找结点p的右子树上的最左下结点s及其双亲结点par； \n    3.2 将结点s数据域替换到被删结点p的数据域； \n    3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上； \n    3.4 删除结点s；\n\n- 性能：\n\n二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。\n\n 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。\n\n 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) \n\n就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。\n\n##### AVL树\n\nAVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。 \n令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。\n因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）\nFh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1 \n所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2 \n因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)\n\n##### B-树和B+树\n\n- B-树\n\n  - 树中可容纳结点数量最大值，关键字个数最多：m^h-1\n\n  - 树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；\n\n  -  除根结点和失败结点外，所有结点至少有 m/2 棵子树； \n\n  - 所有的终端结点和叶子结点（失败结点）都位于同一层。\n\n  - h 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)\n\n  - 关键字个数N：N +1 = 位于第 h+1 层的结点数 >= 2 *(m / 2)^ (h -1)\n\n  - N+1>= 2 *(m / 2)^ (h -1)  ;    h-1 <= log(m / 2)(( N + 1 ) / 2 ) \n\n- B+树\n\n  - (1) 有k个子结点的结点必然有k个关键字；\n\n  - (2) 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。\n    3阶B+树\n  - (3) 所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。\n    通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。\n\n  - (4) 可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。\n\n##### 散列\n\n不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词\n\n散列函数的构造的原则： 计算简单、分布均匀\n\n- 构造方法：\n  直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、\n\n- 冲突处理：\n\n1、开放定址法：\n--线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               --线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…） \n--二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2） \n--随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） \n\n2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高\n\n3、拉链法\\链地址法：\n\n#### 内部排序\n\n##### 气泡排序\n\n最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； \n\n最坏情况（反序）： 比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2         时间复杂度： O(n^2)\n\n平均情况：时间复杂度为O(n^2)  \n\n空间复杂度： O(1)\n\n##### 快速排序\n\n对气泡排序的改进\n\n最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)\n\n最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)\n\n平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)\n\n##### 直接选择排序\n\n移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次\n\n比较次数：n(n-1)/2\n\n时间复杂度为O(n^2)\n\n 空间复杂度为O(1)\n\n##### 堆排序\n\n对直接选择排序的改进\n\n首先将待排序的记录序列用完全二叉树表示；\n然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；\n最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。\n\n堆排序：令i = n, n-1 ,…, 2 \n\n1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])； \n2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)； \n3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(1)\n\n##### （直接）插入排序\n\n最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)\n\n最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)\n\n最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)\n\n##### 希尔排序\n\n对直接插入排序的改进\n\n时间性能：在O(n^2)和O(nlog2n)之间。\n\n当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) \n\n##### (二路)归并排序\n\n基本思想：自底向上的非递归算法\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(n)\n\n##### 基数排序--多关键字排序\n\n次序：从最低位排序，使用了队列\n\n改进：桶----链式排队\n\n时间复杂度：O(d(n+r))    （n---记录数，d----关键字(分量)个数，r----基数）\n\n空间复杂度：O((n+r)) \n\n##### 计数排序\n\n数组记录对应关键字出现的最后一个位置\n\n##### 总结：\n\n| 排序方法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性举例 |\n| --------- | -------- | -------- | -------- | -------- | ---------- |\n| 冒泡     | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 快排     | O(nlog2n) | O(nlog2n) | O(n^2) | O(log2n)~O(n) | 否/2,2,1 |\n| 直接选择 | O(n^2) | O(n^2) | O(n^2) | O(1) | 否/2,2,1 |\n| 堆排序   | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(1) | 否/1,2,2(最小堆) |\n| 直接插入 | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 希尔排序 | O(nlog2n) | O(n^1.3) | O(n^2) | O(1) | 否/3,2,2(d=2/1) |\n| 二路归并 | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(n) | 是 |\n| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(n+r) | 是 |\n\n最坏：\n\n 气泡排序：比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2  \n\n选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   \n\n插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)\n\n#### 外排序\n\n#####  磁盘文件的归并排序\n\n方法：多路归并 、 I/O并行处理  、生成初始归并段\n\n- 磁盘文件的归并排序\n\n第一阶段：初始归并段形成 \n\n第二阶段：多路归并 \n\n- 多路归并-减少归并遍数\n\n一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。\n\n在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）*(K-1)*[logkm]=（n-1）*(K-1) *[log2(m/log2K)]\n\n- K 路平衡归并与选择树\n\n  - 第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) \n\n  - 而后每次重新建造选择树所需时间为： O( log2k ) \n\n  - n 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间:\n\n  ​\t  O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 \n\n  - 归并遍数为 logkm，总时间为:O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )\n\n- 并行操作的缓冲区处理\n\n  ​\t\t\t\t\t-------使输入、输出和CPU处理尽可能重叠\n\n对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作\n\n- 生成初始归并段（使用选择树法）：多路平衡归并\n\n假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：\n(1) 从FI输入P个记录到缓冲区W;\n(2)从W中选择出关键字最小的记录MIN；\n(3)将MIN记录输出到FO中去；\n(4)若FI不空，则从FI输入下一个记录到W; \n(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN; \n(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中\n(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段\n\n生成的初始归并段的平均长度是缓冲区长度的两倍\n\n最佳归并树：使外存读写次数最少，是一棵正则树\n\n对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1\n\n\n\n加入细节点：\n\n- 已知前序和后序不能确定唯一二叉树\n- //判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号\n- 树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树\n\n- 解决冲突的方法：线性再散列、内散列表、外散列表\n\n- 左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针\n\n- 折半查找树高度： (n+1)/nlog2(n+1)-1","source":"_posts/数据结构与算法.md","raw":"---\ntitle: 哈尔滨工业大学数据结构2018年秋期末复习\nurlname: hit_data_structure_review\nmathjax: true\ntags:\n  - 数据结构\n  - 期末复习\ncategories: 数据结构\ndescription: 这里尽可能详细的记录了数据结构的知识点，如果能完全掌握这些知识点，期末考试基本哦了\\(^o^)/~\nabbrlink: 22353\ndate: 2019-03-05 14:00:00\n---\n\n#### 绪论\n\n##### 抽象数据类型\n\n- 抽象数据类型:(Abstract Date Type)\n\n\t-定义：一个数学模型和该模型上定义的操作集合的总称\n\t\n\t*ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象\n\t\n\t*同一数学模型上定义的不同操作集，则他们代表不同的ADT\n\t\n\t-表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作\n\n- 逻辑结构：\n\n  集合——没关系\n\n  线性表——1:1前后\n\n  树——1：m层次\n\n  图——网状\n\n- 存储结构：\n\n  ​\t顺序——连续空间 \t\t $\\Rightarrow$索引\n\n  ​\t链式——不连续空间      \t+散列\n\n##### 算法及算法分析\n\n- 算法的相关概念\n\n\t-算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列\n\t\n\t-五大特性：输入   输出   有穷性   确定性\n\n- 时间复杂度（time  xomplexity)\n\n\t算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度\n\n- 常见时间复杂度的比较\n\n0(1)< <0(logn) <<0(n)< < 0(nlogn) << 0(n2) << 0(n3) <<0(2n) << 0(n!)\n\n- 常见设计方法：\n\n穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)\n\n$\\alpha -\\beta$裁剪和分支界限法、并行算法\n\n- 时空资源的折中原理\n\n同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质\n\n##### 逐步求精的程序设计方法\n\n​\t模型化-确定算法-逐步求精\t\n\n#### 线性表\n\n##### 线性表的抽象数据类型\n\n​\t 顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素\n\n##### 线性表的实现\n\n存储结构的三种方式：\n\n ① 连续的存储空间（数组） →  静态存储\n\n ② 非连续存储空间——指针（链表） →  动态存储\n\n ③ 游标（连续存储空间+动态管理思想）→  静态链表\n\n###### 线性表的数组实现：\n\n随机存储结构，查找快   o(1)\n\n插入和删除慢  o(n)\n\n空间固定\n\n###### 链表\n\n非随机存储结构\n\neg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2\n\n​\t求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走\n\n- 插入元素\n\n  a、保存后继指针\n\n  b、申请一个内存空间\n\n  c、插入：先链接后部分，再衔接前部分\n\n###### 游标\n\n元素是结构体数组，多个线性表公用一个存储池\n\n单链表逆置：\n\n```c\n//方法一：\n//设表头为L,算法如下: \np=L->next->next; q=p->next; L->next->next=NULL; while(p!=null) {\n    p->next=L->next;\n    L->next=p;\n    p=q;\n    q=q->next; \n}\n//方法二：\n//线性表由q来表示 \np=null; w=q; while(w!=null) { \n    w=w->next; \n    q->next=p;\n    p=q; q=w; \n}\n```\n\n###### 双向链表\n\n双向单链表插入与删除：\n\n<img src=\"/img/ds/双向单链表.PNG\" width=\"60%\">\n\n###### 环形链表\n\n- 数组求模可以成环\n\n- 判断链表是否成环：两个指针，速度分别为1和2,\n\n- 确定环入口：\n\n- 两个链表是否相交:判断两个列表最后一个元素是否相同//散列\n\n- 单项循环链表插入与删除：\n\n<img src=\"/img/ds/双循环1.PNG\" width=\"60%\">\n\n<img src=\"/img/ds/双循环2.PNG\" width=\"60%\">\n\n##### 栈\n\n- 多项式的代数运算\n\n<img src=\"/img/ds/中缀转后缀表达式.PNG\" width=\"60%\">\n\n- 后缀表达式求值：\n\n  对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。\n\n##### 队列\n\n优先队列：\n\n问题：如何解决循环队列中队空与队满状态相同？\n方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；\n\n 方法二：另设一个标志位用以区别队空与队满两种状态；\n结论：两种方法的代价是相同的。\n\n##### 串（String）\n\nKMP算法：\n\n一、如何求next函数:\n\n- 当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 \n\n-  当j>1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。\n-   当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较\n\n下面给出求next函数的伪码：\n\n```c\nvoid get_next(SString T, int &next[]) {\n\n //求模式串T的next函数并存入next数组\n\n int i = 1; next[1] = 0; int j = 0;\n\n while (i < T[0]) //T[0]中存放数组长度 {\n\n if( j==0||T[i]==T[j]) { ++i; ++j;  next[i]=j; } \n\nelse j= next[j]; }\n\n }//get_next\n```\n\n二、KMP算法实现步骤：\n\n   1.在串S和串T中分别设比较的起始下标i和j；\n2. 循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕 \n   2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则 \n   2.2将j向右滑动到next[j]位置，即j=next[j]； \n   2.3 如果j=0，则将i和j分别加1，准备下一趟比较；\n3. 如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；\n\n##### 广义表\n\n例如：\n\n A = （a，（b，a，b），（），c，（（（2））））； \n\nB = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；\n\n长度：广义表LS中的直接元素的个数；\n深度：广义表LS中括号的最大嵌套层数。\n表头：广义表LS非空时，称第一个元素为LS的表头；\n表尾：广义表LS中除表头外其余元素组成的广义表。\n\n#### 树与二叉树\n\n##### 二叉树\n\n###### 性质：\n\n在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关\n\n###### 建立\n\n建立：\n\n<img src=\"/img/ds/建立1.PNG\" width=\"60%\">\n\n先序建立：\n\n<img src=\"/img/ds/先序建立.PNG\" width=\"60%\">\n\n非递归建立：\n\n<img src=\"/img/ds/建立非.PNG\" width=\"60%\">\n\n###### 遍历\n\n- 先序递归：\n\n<img src=\"/img/ds/先序.PNG\" width=\"60%\">\n\n- 先序非递归：\n\n1.栈s初始化； \n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 输出root->data;\n \t\t2.1.2 将指针root的值保存到栈中；\n​\t\t2.1.3 继续遍历root的左子树 \n​\t2.2 如果栈s不空，则\n​\t\t2.2.1 将栈顶元素弹出至root；\n​\t\t2.2.2 准备遍历root的右子树；\n\n- 中序非递归：\n\n1.栈s初始化； \n\n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 将指针root的值保存到栈中；\n \t\t2.1.2 继续遍历root的左子树 \n \t2.2 如果栈s不空，则\n \t\t2.2.1 将栈顶元素弹出至root；\n \t\t2.2.2 输出root->data; \n​\t\t2.2.3 准备遍历root的右子树\n\n- 后序非递归：\n\n1. 栈s初始化； \n2. 循环直到root为空且栈s为空 \n\t2.1 当root非空时循环\n\t​\t2.1.1 将root连同标志flag=1 入栈； \n\t​\t2.1.2 继续遍历root的左子树；\n\t2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点; \n\t2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；\n\n<img src=\"/img/ds/二叉树先序遍历.PNG\" width=\"60%\">\n\n- 层序遍历：\n\n1. 队列Q初始化；\n2. 如果二叉树非空，将根指针入队；\n3. 循环直到队列Q为空\n   3.1 q=队列Q的队头元素出队；\n   3.2 访问结点q的数据域； \n   3.3 若结点q存在左孩子，则将左孩子指针入队； \n   3.4 若结点q存在右孩子，则将右孩子指针入队；\n\n###### 应用\n\n- 1、已知先序中序确定二叉树：\n\n遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，\n​\t如果栈为空，将下标 j 入栈；\n​\t否则，栈不为空：\n​\t\t如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈\n\n<img src=\"/img/ds/已知先序中序构二叉树.PNG\" width=\"60%\">\n\n- 2、求二叉树任意两节点公共祖先：\n\n```c\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root) \n        return NULL;//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个\n    if (root == p || root == q) \n        return root;//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个\n    TreeNode *L = lowestCommonAncestor(root->left, p, q);//左子树中是否能最先找到p,q中的一个节点\n    TreeNode *R = lowestCommonAncestor(root->right, p, q);\n    if (L && R) \n        return root;  //如果当前节点左右节点都各找到一个，那么返回当前节点\n    return L ? L : R; //只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面\n    }\n```\n\n\n\n- 3、求二叉树宽度：\n\n```c\nint  front=-1,rear=-1,count=0,max=0,right\nif (T!=NULL) \n\tq[++rear]=T;max=1;right=rear; \nwhile(front!=rear) {\n\tT=q[++front];\n\tif(T->lc!=NULL)q[++rear]=T->lc; count++;\n\tif(T->rc!=NULL q[++rear]=T->rc; count++; \n\tif(front==right) { \n\t\tif(max<count)max=count; count=0;right=rear;}\n }\n```\n\n- 4、线索树：\n\n1）在中序线索二叉树中求一个结点p的中序后继p：\n\n​\t当p->rtag==False时，p->rchild 即为所求(线索)。\n\n \t当p->rtag==True时，p为p 的右子树的最左结点\n\n2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树\n\n```\nvoid ThInOrder(ThTree HEAD) {  \nThTree   tmp ; tmp = HEAD ; \n  do { \n  \ttmp = InNext ( tmp ) ; \n if ( tmp != HEAD ) visit ( tmp -> data ) ;\n} while ( tmp != HEAD ) ; }\n```\n\n  3）求中序线索二叉树中结点p 的先序顺序后继结点p* \n\n(1) p 的左子树不空时，p 的左儿子p->lchild 即为 p*；\n(2) p 的左子树空但右子树不空时，p 的p->rchild 为p*；\n(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.\n\n```\nTHTREE PreNext( ThTree p) {   \n\tThTree Q ;\n\tif (p->ltag = = True ) Q=p->lchild ; \n\telse{\n\t\tQ = p;\n\t\twhile(Q->rtag = = False) Q = Q->rchild ; \n\t\tQ = Q->rchild ;\n\t}  return ( Q ) ; \n```\n\n- 相似二叉树:具有相同结构的二叉树为相似二叉树。 \n\n- 相似且对应结点包含相同信息的二叉树称为等价二叉树。 \n\n##### 堆\n\n最大堆：\n\n如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆\n\n- 大根堆插入：\n\nvoid Insert ( Heap &heap，Elementtype x)//大根堆插入一个元素 { \n​\tint i; \n​\tif ( ! HeapFull ( heap ) ) { \n​\t\ti=heap.n+1; \n​\t\twhile ( (i!=1)&&(x >heap.ele [i/2] ) ) {  \n​\t\t\theap.ele [i]=heap.ele [i/2]; i=i/2;\n \t} heap.ele [i] = x;\n\n- 大根堆删除：\n\n```c\nvoid DeleteMax (Heap & heap )//大根堆删除 {  \n\tint parent=1, child=2;  Elementtype  ele,  tmp;\n\tif (! HeapEmpty(heap)) { \n\t\tele=heap.ele [1]; tmp=heap.ele [heap.n--];\n \t\twhile (child<= heap.n){\n\t\t\tif(child<heap.n)&&(heap.ele [child]<heap.ele [child+1]))\n                \tchild++;\n\t\t\tif (tmp>=heap.ele [child])  break;\n\t\t\theap.ele [parent]=heap.ele [child]; \n\t\t\tparent=child; child*=2;\n\t\t}//while\n \t\theap.ele [parent]=tmp; return ele; \n\t}//if\n}\n```\n\n\n\n##### 选择树\n\n​\t胜者树、败者树\n\n##### 树\n\n存储结构：\n\n双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））\n\n|          | 树         | 二叉树       |\n| -------- | ---------- | ------------ |\n| 节点关系 | 兄弟关系   | 双亲和右孩子 |\n|          | 双亲和长子 | 双亲和左孩子 |\n\n##### 森林与二叉树的相互转换\n\n- 森林转化成二叉树：\n\n1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）\n\n 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 \n\n3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）\n\n- 二叉树转化成森林（树）\n\n连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；\n\n 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; \n\n旋转： 按逆时针旋转45度角（即把结点按层次排列）\n\n- 将一株树转换为二叉树，二叉树一定没有右子树\n-  一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；\n-  任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；\n\n- 森林(树)转换成二叉树的递归算法：\n\n F ={T1,T2, …,Tn}   \n二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则 \n B(F)的根就是root（T1）；\n B(F)的左子树是F的第一棵树T1的子树森林；\n B(F)的右子树F的其余子树森林。 \n\n- 二叉树转换成森林(树) 的递归算法 ：\n\n若B 为空，则F 为空；若B 不空，则\n F中的第一株树T1 的根对应二叉树B 的根； \n T1中根结点的子树森林F1是由B的左子树转换来的；\n F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。\n\n##### 树的应用\n\n- 堆的复杂度：O(n)\n\n- 败者树的复杂度：O(2n-1)\n\n###### 用树结构表示集合：\n\n等价分类算法： \n1. 令S中的每一个元素自身构成一个等价类，S1,S2,…S7 \n\n2. 重复读入等价对（i,  j） \n   2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性） \n   2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。\n\n```c\nvoid Equivalence (MFSET S)   //等价分类算法 { \n   int i ,j , k ,m; \n   for(i=1; i<=n+1;i++) Initial(i,S);  //使集合S只包含元素i\n   cin>>i>>j;        // 读入等价对\n   while(!(i==0&&j==0){ // 等价对未读完\n       k=Find(i,S);           //求i的根 \n       m=Find(j,S);        // 求j的根\n       if(k!=m)          //if k==m,i,j已在一个树中，不需合并 \n           Union(i,j,S);     //合并 \n       cin<<i<<j;          \n   }  }\n```\n\n###### 判定树\n\n判定树的特点：\n\n 一个判定树是一个算法的描述； \n每个内部结点对应一个部分解； 每个叶子对应一个解； \n每个内部结点连接与一个获得新信息的测试；\n 从每个结点出发的分支标记着不同的测试结果；\n 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合\n\n判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$\n\n###### 哈夫曼树：\n\n- 内外路径：\n\n<img src=\"/img/ds/内外路径.PNG\" width=\"60%\">\n\n- 哈夫曼树性质：\n\n没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。\n\n<img src=\"/img/ds/哈夫曼树性质1.PNG\" width=\"60%\">\n\n- 码长计算：\n\n<img src=\"/img/ds/码长计算.PNG\" width=\"60%\">\n\n- 哈夫曼编码一定具有前缀性；\n  哈夫曼编码是最小冗余码; \n  哈夫曼编码方法，使出现概率大的字符对应的码长较短；\n  哈夫曼编码不唯一，可以用于加密；\n  哈夫曼编码译码简单唯一，没有二义性.\n\n###### 表达式求值\n\n把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值\n\n 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。\n\n#### 图\n\n简单路径：若路径上各顶点 v1,v2,...,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。\n\n 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。\n\n##### 图的存储结构\n\n|          | 空间性能 | 时间性能 | 唯一性 |适用范围|\n| -------- | -------- | -------- | ------ |-----|\n| 邻接矩阵 | O(n^2)   | O(n^2)   |           唯一   |稠密图|\n| 邻接表   | O(n+e)   | O(n+e)   |          不唯一 |稀疏图|\n\n十字链表、邻接多重表\n\n##### 图的搜索\n\n- 深度优先搜索\n\n从一个顶点出发的一次深度优先遍历算法：\n实现步骤： \n1. 访问顶点v; visited[v]=1; \n2. w=顶点v的第一个邻接点； \n3.  while (w存在) \n    3.1 if (w未被访问) 从顶点w出发递归执行该算法; \n    3.2 w=顶点v的下一个邻接点;\n\n邻接矩阵：空间：O(n^2)       时间： O(n^2)\n\n邻接表：O(n)  O(V+E)\n\n\n\n- 广度优先搜索\n\n1 . 初始化队列Q;\n2. 访问顶点v; visited [v]=1; 顶点v入队Q;\n3. while (队列Q非空) \n    3.1 v=队列Q的队头元素出队;\n    3.2 w=顶点v的第一个邻接点;\n    3.3 while (w存在) \n       3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n       3.3.2 w=顶点v的下一个邻接点；\n\n##### 图与树、最小生成树\n\n###### 先深和先广生成森林\n\n- 先深搜索对边的分类 \n  两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;  \n  结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然\n- 先广搜索对边的分类 \n  两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.\n  结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然\n\n###### 无向图与开放树\n\n连通而无环路的无向图称作开放树（Free  Tree）\n\n（1）具有n≥1个顶点的开放树包含n-1条边； \n\n（2）如果在开放树中任意加上一条边，便得到一条回路\n\n###### 最小生成树算法\n\n- 普里姆Prim算法：\n\n基本思想 \n① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ } \n② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U \n③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树\n\n如何找到连接U和V-U的最短边 ：\n利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。\n\n1. 初始化两个辅助数组LOWCOST和CLOSEST；\n\n2. 输出顶点v0，将顶点v0加入集合U中；\n\n3. 重复执行下列操作n-1次\n   3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；\n   3.2 输出顶点k和对应的权值； \n   3.3 将顶点k加入集合U中； \n   3.4 调整数组LOWCOST和CLOSEST；\n\n   LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]} \n   CLOSEST[j]=k\n\n时间复杂度：O(n^2)\n\n- 克鲁斯卡尔（Kruskal）算法\n\n注：边值各不相同时生成树唯一\n\n基本思想：\n设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }， \n然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。 \n若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，\n如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。\n\n1. 初始化：U=V； TE={ }； \n2. 循环直到T中的连通分量个数为1  \n    2.1 在E中选择最短边(u，v); \n    2.2 如果顶点u、v位于T的两个不同连通分量，则 \n    ​\t2.2.1 将边(u，v)并入TE； \n    ​\t2.2.2 将这两个连通分量合为一个；\n    2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取\n\n时间复杂度：O(eloge)\n\n##### 无向图的双连通性\n\n若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。\n\n1、没有关节点的连通图称为双连通图。\n2、双连通的无向图是连通的，但连通的无向图未必双连通。\n3、一个连通的无向图是双连通的，当且仅当它没有关节点。  \n4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。 \n5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。\n\n- 由先深生成树可得出两类关节点的特性：\n\n 1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 \n\n2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来\n\n算法要点：\n 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。\n 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：\n (1)  dfn[v]；\n (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；\n (3)  low[y]，对v的任何儿子y。\n 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。\n\n```c\n//求双连通分量的算法 \nvoid main() { \n\tcount = 1; for (all v ∈ V)  mark v “new”; searchB( v0 );\n}\n\n//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)\nvoid searchB(v) { \n\tmark v “old”;\n\tdfn[v] = count;count++; \n\tlow[v]=dfn[v]; \n \tfor (each w ∈ L[v])\n     \tif (w is marked “new”) { \n         \tfather [w]=v；searchB (w); \n         \tlow [v]= min { low [v], low [w] }; \n        \tif (low[w]>=dfn[v]) //表明W及子孙均无指向V的祖先的回退边，v是关节点\n           \t cout<<“a biconnected component”; } \n    \telse if (w != father [v]) //(v ,w)是回退边   \n          low [v]= min { low [v],  dfn [w] };\n```\n\n\n\n##### 拓扑排序\n\n是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） \n\n实质：广度优先搜索算法\n\nAOV网（有向图）\n\n- 利用队列算法：\n  1.建立入度为零的顶点排队 \n  2.扫描顶点表，将入度为0的顶点入队；\n  3.while（排队不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入队 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n- 利用栈算法：\n  1.建立入度为零的顶点栈 \n  2.扫描顶点表，将入度为0的顶点栈；\n  3.while（栈不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入栈 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。\n\n- 说明：\n  - 与先广搜索的差别：\n    ​      搜索起点是入度为0的顶点；\n    ​      需判断是否有环路；\n    ​      需对访问并输出的顶点计数（引入计数器nodes）。\n    ​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。\n  - 也可以采用栈数据结构进行广度优先拓扑排序。 \n  - 亦可采用无后继顶点优先的拓扑排序算法\n  - 也可以利用DFS遍历进行拓扑排序\n- 基于DFS的拓扑排序\n\n```c\nvoid topodfs ( v ) {   \n    Push( v ,S ) ; \n    mark[v]=True; \n    for ( L[v] 中的每一个顶点w) \n        if ( mark[w] = False ) topodfs ( w ) ; \n    printf ( Top( S ) ) ; \n    Pop ( S ) ; \n}\n\nvoid  dfs-topo ( GRAPH  L ) {  \n    MakeNull( S ); \n    for( u=1;u<=n; u++) \n        mark[u]=False; \n    for( u=1;u<=n;u++) \n        if ( !mark[u] ) \n            topodfs( u ) ; \n```\n\n思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。\n\n##### 关键路径\n\nAOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）\n\n最大长度的路径称为关键路径。 \n一个AOE中，关键路径可能不只一条。\n关键活动：关键路径上的活动称为关键活动。\n\n关键路径算法步骤：\n\n（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}\n其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）\n\n（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }\n其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S\n\n（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 \n\n（４）若某条边满足E( i ) = L( i )，则它是关键活动。\n\n注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。\n\n##### 最短路径\n\n- 边上权值非负情形的单源最短路径问题 — Dijkstra算法 \n\nDijkstra算法实现步骤：\n1. 将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。\n2. 从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。\n3. 调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 \n4. 重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。\n\n```c\ncosttype MinCost (D, S) { \n\ttemp = INFINITY ; w = 2 ;\n\tfor ( i=2 ; i<=n ; i++ )\n\t\tif (!S[i]&&D[i]<temp)  {\n  \t\t\ttemp = D[i] ; w = i ; } \n\treturn  w ;\n}\n\nvoid  Dijkstra(GRAPH  C, costtype D[n+1] ，int P[n+1]，bool S[n+1]) { \n\tfor ( i=2 ; i<=n; i++ ) {  \n\tD[i]=C[1][i] ; S[i]=False ;P[i]=1;}\n\tS [1]= True ; \n\tfor( i=1; i<=n-1; i++) {  \n\t\tw=MinCost ( D, S ) ; S[w]=True ; \n\tfor ( v=2 ; v<= n ; n++ ) \n\t\tif ( S[v]!=True ) {  \n        \t        sum=D[w] + C[w][v] ;\n \t\t\tif (sum < D[v】 ){D[v] = sum ; P[v]=w;}\n\t\t}\n    }\n }//   时间复杂度：O（n^2）\n```\n\n\n\n- 所有顶点之间的最短路径问题 — Floyd算法 \n\n基本思想：动态规划\n\n求解过程：\n\n设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i ---> j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞\n\n 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] \n\n2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。\n\n```c\nvoid Floyd( costtype A[][], costtype C[][], int P[][], int n) {   \n\tfor ( i = 0; i < n; i++ )\n\t\tfor ( j = 0; j< n; j++ ) {\n\t\t\tA[i][j] = C[i][j];  P[i][j] = -1； }\n\tfor ( k = 0; k < n; k++ ) \n\t\tfor ( i = 0; i < n; i++ ) \n\t\t\tfor ( j = 0; j < n; j++ )\n\t\t\t\tif ( A[i][k] + A[k][j] < A[i][j] ){ \n                \tA[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;\n            } \n} /* 时间复杂度：O(n3) */\nWarshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]);\n可以判定有向图任意两点间是否存在有向 路。\n```\n\n#### 查找\n\n\n\n##### 线性查找\n\n插入和删除：从后往前\n\n第0个元素做为伪记录或哨兵 \n\n##### 折半查找\n\n折半查找只适合于静态查找\n\n- 数组：时间复杂度O(logn)\n\n- 判定树:\n\n高度： (n+1)/nlog2(n+1)-1\n\n当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近\n\n##### 分块查找\n\n基本思想：均匀分块，块间有序，块内无序\n\n索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.\n\n块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j \n\n所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。\n\n##### BST-二叉查找树\n\n- 插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. \n\n- 删除：\n\n1. 若结点p是叶子，则直接删除结点p； \n2. 若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； \n3. 若结点p的左右子树均不空，则 \n    3.1 查找结点p的右子树上的最左下结点s及其双亲结点par； \n    3.2 将结点s数据域替换到被删结点p的数据域； \n    3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上； \n    3.4 删除结点s；\n\n- 性能：\n\n二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。\n\n 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。\n\n 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) \n\n就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。\n\n##### AVL树\n\nAVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。 \n令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。\n因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）\nFh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1 \n所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2 \n因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)\n\n##### B-树和B+树\n\n- B-树\n\n  - 树中可容纳结点数量最大值，关键字个数最多：m^h-1\n\n  - 树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；\n\n  -  除根结点和失败结点外，所有结点至少有 m/2 棵子树； \n\n  - 所有的终端结点和叶子结点（失败结点）都位于同一层。\n\n  - h 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)\n\n  - 关键字个数N：N +1 = 位于第 h+1 层的结点数 >= 2 *(m / 2)^ (h -1)\n\n  - N+1>= 2 *(m / 2)^ (h -1)  ;    h-1 <= log(m / 2)(( N + 1 ) / 2 ) \n\n- B+树\n\n  - (1) 有k个子结点的结点必然有k个关键字；\n\n  - (2) 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。\n    3阶B+树\n  - (3) 所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。\n    通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。\n\n  - (4) 可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。\n\n##### 散列\n\n不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词\n\n散列函数的构造的原则： 计算简单、分布均匀\n\n- 构造方法：\n  直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、\n\n- 冲突处理：\n\n1、开放定址法：\n--线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               --线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…） \n--二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2） \n--随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） \n\n2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高\n\n3、拉链法\\链地址法：\n\n#### 内部排序\n\n##### 气泡排序\n\n最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； \n\n最坏情况（反序）： 比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2         时间复杂度： O(n^2)\n\n平均情况：时间复杂度为O(n^2)  \n\n空间复杂度： O(1)\n\n##### 快速排序\n\n对气泡排序的改进\n\n最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)\n\n最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)\n\n平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)\n\n##### 直接选择排序\n\n移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次\n\n比较次数：n(n-1)/2\n\n时间复杂度为O(n^2)\n\n 空间复杂度为O(1)\n\n##### 堆排序\n\n对直接选择排序的改进\n\n首先将待排序的记录序列用完全二叉树表示；\n然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；\n最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。\n\n堆排序：令i = n, n-1 ,…, 2 \n\n1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])； \n2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)； \n3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(1)\n\n##### （直接）插入排序\n\n最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)\n\n最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)\n\n最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)\n\n##### 希尔排序\n\n对直接插入排序的改进\n\n时间性能：在O(n^2)和O(nlog2n)之间。\n\n当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) \n\n##### (二路)归并排序\n\n基本思想：自底向上的非递归算法\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(n)\n\n##### 基数排序--多关键字排序\n\n次序：从最低位排序，使用了队列\n\n改进：桶----链式排队\n\n时间复杂度：O(d(n+r))    （n---记录数，d----关键字(分量)个数，r----基数）\n\n空间复杂度：O((n+r)) \n\n##### 计数排序\n\n数组记录对应关键字出现的最后一个位置\n\n##### 总结：\n\n| 排序方法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性举例 |\n| --------- | -------- | -------- | -------- | -------- | ---------- |\n| 冒泡     | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 快排     | O(nlog2n) | O(nlog2n) | O(n^2) | O(log2n)~O(n) | 否/2,2,1 |\n| 直接选择 | O(n^2) | O(n^2) | O(n^2) | O(1) | 否/2,2,1 |\n| 堆排序   | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(1) | 否/1,2,2(最小堆) |\n| 直接插入 | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 希尔排序 | O(nlog2n) | O(n^1.3) | O(n^2) | O(1) | 否/3,2,2(d=2/1) |\n| 二路归并 | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(n) | 是 |\n| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(n+r) | 是 |\n\n最坏：\n\n 气泡排序：比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2  \n\n选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   \n\n插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)\n\n#### 外排序\n\n#####  磁盘文件的归并排序\n\n方法：多路归并 、 I/O并行处理  、生成初始归并段\n\n- 磁盘文件的归并排序\n\n第一阶段：初始归并段形成 \n\n第二阶段：多路归并 \n\n- 多路归并-减少归并遍数\n\n一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。\n\n在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）*(K-1)*[logkm]=（n-1）*(K-1) *[log2(m/log2K)]\n\n- K 路平衡归并与选择树\n\n  - 第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) \n\n  - 而后每次重新建造选择树所需时间为： O( log2k ) \n\n  - n 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间:\n\n  ​\t  O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 \n\n  - 归并遍数为 logkm，总时间为:O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )\n\n- 并行操作的缓冲区处理\n\n  ​\t\t\t\t\t-------使输入、输出和CPU处理尽可能重叠\n\n对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作\n\n- 生成初始归并段（使用选择树法）：多路平衡归并\n\n假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：\n(1) 从FI输入P个记录到缓冲区W;\n(2)从W中选择出关键字最小的记录MIN；\n(3)将MIN记录输出到FO中去；\n(4)若FI不空，则从FI输入下一个记录到W; \n(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN; \n(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中\n(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段\n\n生成的初始归并段的平均长度是缓冲区长度的两倍\n\n最佳归并树：使外存读写次数最少，是一棵正则树\n\n对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1\n\n\n\n加入细节点：\n\n- 已知前序和后序不能确定唯一二叉树\n- //判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号\n- 树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树\n\n- 解决冲突的方法：线性再散列、内散列表、外散列表\n\n- 左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针\n\n- 折半查找树高度： (n+1)/nlog2(n+1)-1","slug":"数据结构与算法","published":1,"updated":"2019-03-20T10:58:53.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvrtri8o001itku3fe6o3a51","content":"<h4 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h4><h5 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h5><ul>\n<li><p>抽象数据类型:(Abstract Date Type)</p>\n<p>  -定义：一个数学模型和该模型上定义的操作集合的总称</p>\n<p>  *ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象</p>\n<p>  *同一数学模型上定义的不同操作集，则他们代表不同的ADT</p>\n<p>  -表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作</p>\n</li>\n<li><p>逻辑结构：</p>\n<p>集合——没关系</p>\n<p>线性表——1:1前后</p>\n<p>树——1：m层次</p>\n<p>图——网状</p>\n</li>\n<li><p>存储结构：</p>\n<p>​    顺序——连续空间          $\\Rightarrow$索引</p>\n<p>​    链式——不连续空间          +散列</p>\n</li>\n</ul>\n<h5 id=\"算法及算法分析\"><a href=\"#算法及算法分析\" class=\"headerlink\" title=\"算法及算法分析\"></a>算法及算法分析</h5><ul>\n<li><p>算法的相关概念</p>\n<p>  -算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列</p>\n<p>  -五大特性：输入   输出   有穷性   确定性</p>\n</li>\n<li><p>时间复杂度（time  xomplexity)</p>\n<p>  算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度</p>\n</li>\n<li><p>常见时间复杂度的比较</p>\n</li>\n</ul>\n<p>0(1)&lt; &lt;0(logn) &lt;&lt;0(n)&lt; &lt; 0(nlogn) &lt;&lt; 0(n2) &lt;&lt; 0(n3) &lt;&lt;0(2n) &lt;&lt; 0(n!)</p>\n<ul>\n<li>常见设计方法：</li>\n</ul>\n<p>穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)</p>\n<p>$\\alpha -\\beta$裁剪和分支界限法、并行算法</p>\n<ul>\n<li>时空资源的折中原理</li>\n</ul>\n<p>同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质</p>\n<h5 id=\"逐步求精的程序设计方法\"><a href=\"#逐步求精的程序设计方法\" class=\"headerlink\" title=\"逐步求精的程序设计方法\"></a>逐步求精的程序设计方法</h5><p>​    模型化-确定算法-逐步求精    </p>\n<h4 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h4><h5 id=\"线性表的抽象数据类型\"><a href=\"#线性表的抽象数据类型\" class=\"headerlink\" title=\"线性表的抽象数据类型\"></a>线性表的抽象数据类型</h5><p>​     顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素</p>\n<h5 id=\"线性表的实现\"><a href=\"#线性表的实现\" class=\"headerlink\" title=\"线性表的实现\"></a>线性表的实现</h5><p>存储结构的三种方式：</p>\n<p> ① 连续的存储空间（数组） →  静态存储</p>\n<p> ② 非连续存储空间——指针（链表） →  动态存储</p>\n<p> ③ 游标（连续存储空间+动态管理思想）→  静态链表</p>\n<h6 id=\"线性表的数组实现：\"><a href=\"#线性表的数组实现：\" class=\"headerlink\" title=\"线性表的数组实现：\"></a>线性表的数组实现：</h6><p>随机存储结构，查找快   o(1)</p>\n<p>插入和删除慢  o(n)</p>\n<p>空间固定</p>\n<h6 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h6><p>非随机存储结构</p>\n<p>eg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2</p>\n<p>​    求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走</p>\n<ul>\n<li><p>插入元素</p>\n<p>a、保存后继指针</p>\n<p>b、申请一个内存空间</p>\n<p>c、插入：先链接后部分，再衔接前部分</p>\n</li>\n</ul>\n<h6 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h6><p>元素是结构体数组，多个线性表公用一个存储池</p>\n<p>单链表逆置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一：</span></span><br><span class=\"line\"><span class=\"comment\">//设表头为L,算法如下: </span></span><br><span class=\"line\">p=L-&gt;next-&gt;next; q=p-&gt;next; L-&gt;next-&gt;next=<span class=\"literal\">NULL</span>; <span class=\"keyword\">while</span>(p!=null) &#123;</span><br><span class=\"line\">    p-&gt;next=L-&gt;next;</span><br><span class=\"line\">    L-&gt;next=p;</span><br><span class=\"line\">    p=q;</span><br><span class=\"line\">    q=q-&gt;next; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法二：</span></span><br><span class=\"line\"><span class=\"comment\">//线性表由q来表示 </span></span><br><span class=\"line\">p=null; w=q; <span class=\"keyword\">while</span>(w!=null) &#123; </span><br><span class=\"line\">    w=w-&gt;next; </span><br><span class=\"line\">    q-&gt;next=p;</span><br><span class=\"line\">    p=q; q=w; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>双向单链表插入与删除：</p>\n<p><img src=\"/img/ds/双向单链表.PNG\" width=\"60%\"></p>\n<h6 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h6><ul>\n<li><p>数组求模可以成环</p>\n</li>\n<li><p>判断链表是否成环：两个指针，速度分别为1和2,</p>\n</li>\n<li><p>确定环入口：</p>\n</li>\n<li><p>两个链表是否相交:判断两个列表最后一个元素是否相同//散列</p>\n</li>\n<li><p>单项循环链表插入与删除：</p>\n</li>\n</ul>\n<p><img src=\"/img/ds/双循环1.PNG\" width=\"60%\"></p>\n<p><img src=\"/img/ds/双循环2.PNG\" width=\"60%\"></p>\n<h5 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h5><ul>\n<li>多项式的代数运算</li>\n</ul>\n<p><img src=\"/img/ds/中缀转后缀表达式.PNG\" width=\"60%\"></p>\n<ul>\n<li><p>后缀表达式求值：</p>\n<p>对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。</p>\n</li>\n</ul>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>优先队列：</p>\n<p>问题：如何解决循环队列中队空与队满状态相同？<br>方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；</p>\n<p> 方法二：另设一个标志位用以区别队空与队满两种状态；<br>结论：两种方法的代价是相同的。</p>\n<h5 id=\"串（String）\"><a href=\"#串（String）\" class=\"headerlink\" title=\"串（String）\"></a>串（String）</h5><p>KMP算法：</p>\n<p>一、如何求next函数:</p>\n<ul>\n<li><p>当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 </p>\n</li>\n<li><p>当j&gt;1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。</p>\n</li>\n<li>当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较</li>\n</ul>\n<p>下面给出求next函数的伪码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"keyword\">int</span> &amp;next[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//求模式串T的next函数并存入next数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">while</span> (i &lt; T[<span class=\"number\">0</span>]) <span class=\"comment\">//T[0]中存放数组长度 &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>( j==<span class=\"number\">0</span>||T[i]==T[j]) &#123; ++i; ++j;  next[i]=j; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span> j= next[j]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;<span class=\"comment\">//get_next</span></span><br></pre></td></tr></table></figure>\n<p>二、KMP算法实现步骤：</p>\n<p>   1.在串S和串T中分别设比较的起始下标i和j；</p>\n<ol start=\"2\">\n<li>循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕<br>2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则<br>2.2将j向右滑动到next[j]位置，即j=next[j]；<br>2.3 如果j=0，则将i和j分别加1，准备下一趟比较；</li>\n<li>如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；</li>\n</ol>\n<h5 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h5><p>例如：</p>\n<p> A = （a，（b，a，b），（），c，（（（2））））； </p>\n<p>B = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；</p>\n<p>长度：广义表LS中的直接元素的个数；<br>深度：广义表LS中括号的最大嵌套层数。<br>表头：广义表LS非空时，称第一个元素为LS的表头；<br>表尾：广义表LS中除表头外其余元素组成的广义表。</p>\n<h4 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h4><h5 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h5><h6 id=\"性质：\"><a href=\"#性质：\" class=\"headerlink\" title=\"性质：\"></a>性质：</h6><p>在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关</p>\n<h6 id=\"建立\"><a href=\"#建立\" class=\"headerlink\" title=\"建立\"></a>建立</h6><p>建立：</p>\n<p><img src=\"/img/ds/建立1.PNG\" width=\"60%\"></p>\n<p>先序建立：</p>\n<p><img src=\"/img/ds/先序建立.PNG\" width=\"60%\"></p>\n<p>非递归建立：</p>\n<p><img src=\"/img/ds/建立非.PNG\" width=\"60%\"></p>\n<h6 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h6><ul>\n<li>先序递归：</li>\n</ul>\n<p><img src=\"/img/ds/先序.PNG\" width=\"60%\"></p>\n<ul>\n<li>先序非递归：</li>\n</ul>\n<p>1.栈s初始化；<br>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 输出root-&gt;data;<br>         2.1.2 将指针root的值保存到栈中；<br>​        2.1.3 继续遍历root的左子树<br>​    2.2 如果栈s不空，则<br>​        2.2.1 将栈顶元素弹出至root；<br>​        2.2.2 准备遍历root的右子树；</p>\n<ul>\n<li>中序非递归：</li>\n</ul>\n<p>1.栈s初始化； </p>\n<p>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 将指针root的值保存到栈中；<br>         2.1.2 继续遍历root的左子树<br>     2.2 如果栈s不空，则<br>         2.2.1 将栈顶元素弹出至root；<br>         2.2.2 输出root-&gt;data;<br>​        2.2.3 准备遍历root的右子树</p>\n<ul>\n<li>后序非递归：</li>\n</ul>\n<ol>\n<li>栈s初始化； </li>\n<li>循环直到root为空且栈s为空<br> 2.1 当root非空时循环<br> ​    2.1.1 将root连同标志flag=1 入栈；<br> ​    2.1.2 继续遍历root的左子树；<br> 2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点;<br> 2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；</li>\n</ol>\n<p><img src=\"/img/ds/二叉树先序遍历.PNG\" width=\"60%\"></p>\n<ul>\n<li>层序遍历：</li>\n</ul>\n<ol>\n<li>队列Q初始化；</li>\n<li>如果二叉树非空，将根指针入队；</li>\n<li>循环直到队列Q为空<br>3.1 q=队列Q的队头元素出队；<br>3.2 访问结点q的数据域；<br>3.3 若结点q存在左孩子，则将左孩子指针入队；<br>3.4 若结点q存在右孩子，则将右孩子指针入队；</li>\n</ol>\n<h6 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h6><ul>\n<li>1、已知先序中序确定二叉树：</li>\n</ul>\n<p>遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，<br>​    如果栈为空，将下标 j 入栈；<br>​    否则，栈不为空：<br>​        如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈</p>\n<p><img src=\"/img/ds/已知先序中序构二叉树.PNG\" width=\"60%\"></p>\n<ul>\n<li>2、求二叉树任意两节点公共祖先：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == p || root == q) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;<span class=\"comment\">//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个</span></span><br><span class=\"line\">    TreeNode *L = lowestCommonAncestor(root-&gt;left, p, q);<span class=\"comment\">//左子树中是否能最先找到p,q中的一个节点</span></span><br><span class=\"line\">    TreeNode *R = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L &amp;&amp; R) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;  <span class=\"comment\">//如果当前节点左右节点都各找到一个，那么返回当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> L ? L : R; <span class=\"comment\">//只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3、求二叉树宽度：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>  front=<span class=\"number\">-1</span>,rear=<span class=\"number\">-1</span>,count=<span class=\"number\">0</span>,max=<span class=\"number\">0</span>,right</span><br><span class=\"line\"><span class=\"keyword\">if</span> (T!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">\tq[++rear]=T;max=<span class=\"number\">1</span>;right=rear; </span><br><span class=\"line\"><span class=\"keyword\">while</span>(front!=rear) &#123;</span><br><span class=\"line\">\tT=q[++front];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;lc!=<span class=\"literal\">NULL</span>)q[++rear]=T-&gt;lc; count++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;rc!=<span class=\"literal\">NULL</span> q[++rear]=T-&gt;rc; count++; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(front==right) &#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(max&lt;count)max=count; count=<span class=\"number\">0</span>;right=rear;&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>4、线索树：</li>\n</ul>\n<p>1）在中序线索二叉树中求一个结点p的中序后继p：</p>\n<p>​    当p-&gt;rtag==False时，p-&gt;rchild 即为所求(线索)。</p>\n<pre><code>当p-&gt;rtag==True时，p为p 的右子树的最左结点\n</code></pre><p>2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void ThInOrder(ThTree HEAD) &#123;  </span><br><span class=\"line\">ThTree   tmp ; tmp = HEAD ; </span><br><span class=\"line\">  do &#123; </span><br><span class=\"line\">  \ttmp = InNext ( tmp ) ; </span><br><span class=\"line\"> if ( tmp != HEAD ) visit ( tmp -&gt; data ) ;</span><br><span class=\"line\">&#125; while ( tmp != HEAD ) ; &#125;</span><br></pre></td></tr></table></figure>\n<p>  3）求中序线索二叉树中结点p 的先序顺序后继结点p* </p>\n<p>(1) p 的左子树不空时，p 的左儿子p-&gt;lchild 即为 p<em>；<br>(2) p 的左子树空但右子树不空时，p 的p-&gt;rchild 为p</em>；<br>(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THTREE PreNext( ThTree p) &#123;   </span><br><span class=\"line\">\tThTree Q ;</span><br><span class=\"line\">\tif (p-&gt;ltag = = True ) Q=p-&gt;lchild ; </span><br><span class=\"line\">\telse&#123;</span><br><span class=\"line\">\t\tQ = p;</span><br><span class=\"line\">\t\twhile(Q-&gt;rtag = = False) Q = Q-&gt;rchild ; </span><br><span class=\"line\">\t\tQ = Q-&gt;rchild ;</span><br><span class=\"line\">\t&#125;  return ( Q ) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>相似二叉树:具有相同结构的二叉树为相似二叉树。 </p>\n</li>\n<li><p>相似且对应结点包含相同信息的二叉树称为等价二叉树。 </p>\n</li>\n</ul>\n<h5 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h5><p>最大堆：</p>\n<p>如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆</p>\n<ul>\n<li>大根堆插入：</li>\n</ul>\n<p>void Insert ( Heap &amp;heap，Elementtype x)//大根堆插入一个元素 {<br>​    int i;<br>​    if ( ! HeapFull ( heap ) ) {<br>​        i=heap.n+1;<br>​        while ( (i!=1)&amp;&amp;(x &gt;heap.ele [i/2] ) ) {<br>​            heap.ele [i]=heap.ele [i/2]; i=i/2;<br>     } heap.ele [i] = x;</p>\n<ul>\n<li>大根堆删除：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMax</span> <span class=\"params\">(Heap &amp; heap )</span><span class=\"comment\">//大根堆删除 &#123;  </span></span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"keyword\">int</span> parent</span>=<span class=\"number\">1</span>, child=<span class=\"number\">2</span>;  Elementtype  ele,  tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (! HeapEmpty(heap)) &#123; </span><br><span class=\"line\">\t\tele=heap.ele [<span class=\"number\">1</span>]; tmp=heap.ele [heap.n--];</span><br><span class=\"line\"> \t\t<span class=\"keyword\">while</span> (child&lt;= heap.n)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(child&lt;heap.n)&amp;&amp;(heap.ele [child]&lt;heap.ele [child+<span class=\"number\">1</span>]))</span><br><span class=\"line\">                \tchild++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&gt;=heap.ele [child])  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\theap.ele [parent]=heap.ele [child]; </span><br><span class=\"line\">\t\t\tparent=child; child*=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"comment\">//while</span></span><br><span class=\"line\"> \t\theap.ele [parent]=tmp; <span class=\"keyword\">return</span> ele; </span><br><span class=\"line\">\t&#125;<span class=\"comment\">//if</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"选择树\"><a href=\"#选择树\" class=\"headerlink\" title=\"选择树\"></a>选择树</h5><p>​    胜者树、败者树</p>\n<h5 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h5><p>存储结构：</p>\n<p>双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>树</th>\n<th>二叉树</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>节点关系</td>\n<td>兄弟关系</td>\n<td>双亲和右孩子</td>\n</tr>\n<tr>\n<td></td>\n<td>双亲和长子</td>\n<td>双亲和左孩子</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"森林与二叉树的相互转换\"><a href=\"#森林与二叉树的相互转换\" class=\"headerlink\" title=\"森林与二叉树的相互转换\"></a>森林与二叉树的相互转换</h5><ul>\n<li>森林转化成二叉树：</li>\n</ul>\n<p>1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）</p>\n<p> 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 </p>\n<p>3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）</p>\n<ul>\n<li>二叉树转化成森林（树）</li>\n</ul>\n<p>连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；</p>\n<p> 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; </p>\n<p>旋转： 按逆时针旋转45度角（即把结点按层次排列）</p>\n<ul>\n<li>将一株树转换为二叉树，二叉树一定没有右子树</li>\n<li>一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；</li>\n<li><p>任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；</p>\n</li>\n<li><p>森林(树)转换成二叉树的递归算法：</p>\n<p>F ={T1,T2, …,Tn}<br>二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则<br>B(F)的根就是root（T1）；<br>B(F)的左子树是F的第一棵树T1的子树森林；<br>B(F)的右子树F的其余子树森林。 </p>\n</li>\n<li><p>二叉树转换成森林(树) 的递归算法 ：</p>\n</li>\n</ul>\n<p>若B 为空，则F 为空；若B 不空，则<br> F中的第一株树T1 的根对应二叉树B 的根；<br> T1中根结点的子树森林F1是由B的左子树转换来的；<br> F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。</p>\n<h5 id=\"树的应用\"><a href=\"#树的应用\" class=\"headerlink\" title=\"树的应用\"></a>树的应用</h5><ul>\n<li><p>堆的复杂度：O(n)</p>\n</li>\n<li><p>败者树的复杂度：O(2n-1)</p>\n</li>\n</ul>\n<h6 id=\"用树结构表示集合：\"><a href=\"#用树结构表示集合：\" class=\"headerlink\" title=\"用树结构表示集合：\"></a>用树结构表示集合：</h6><p>等价分类算法： </p>\n<ol>\n<li><p>令S中的每一个元素自身构成一个等价类，S1,S2,…S7 </p>\n</li>\n<li><p>重复读入等价对（i,  j）<br>2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性）<br>2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Equivalence</span> <span class=\"params\">(MFSET S)</span>   <span class=\"comment\">//等价分类算法 &#123; </span></span></span><br><span class=\"line\">   int i ,j , k ,m; </span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n+<span class=\"number\">1</span>;i++) Initial(i,S);  <span class=\"comment\">//使集合S只包含元素i</span></span><br><span class=\"line\">   <span class=\"built_in\">cin</span>&gt;&gt;i&gt;&gt;j;        <span class=\"comment\">// 读入等价对</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(!(i==<span class=\"number\">0</span>&amp;&amp;j==<span class=\"number\">0</span>)&#123; <span class=\"comment\">// 等价对未读完</span></span><br><span class=\"line\">       k=Find(i,S);           <span class=\"comment\">//求i的根 </span></span><br><span class=\"line\">       m=Find(j,S);        <span class=\"comment\">// 求j的根</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(k!=m)          <span class=\"comment\">//if k==m,i,j已在一个树中，不需合并 </span></span><br><span class=\"line\">           Union(i,j,S);     <span class=\"comment\">//合并 </span></span><br><span class=\"line\">       <span class=\"built_in\">cin</span>&lt;&lt;i&lt;&lt;j;          </span><br><span class=\"line\">   &#125;  &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"判定树\"><a href=\"#判定树\" class=\"headerlink\" title=\"判定树\"></a>判定树</h6><p>判定树的特点：</p>\n<p> 一个判定树是一个算法的描述；<br>每个内部结点对应一个部分解； 每个叶子对应一个解；<br>每个内部结点连接与一个获得新信息的测试；<br> 从每个结点出发的分支标记着不同的测试结果；<br> 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合</p>\n<p>判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$</p>\n<h6 id=\"哈夫曼树：\"><a href=\"#哈夫曼树：\" class=\"headerlink\" title=\"哈夫曼树：\"></a>哈夫曼树：</h6><ul>\n<li>内外路径：</li>\n</ul>\n<p><img src=\"/img/ds/内外路径.PNG\" width=\"60%\"></p>\n<ul>\n<li>哈夫曼树性质：</li>\n</ul>\n<p>没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。</p>\n<p><img src=\"/img/ds/哈夫曼树性质1.PNG\" width=\"60%\"></p>\n<ul>\n<li>码长计算：</li>\n</ul>\n<p><img src=\"/img/ds/码长计算.PNG\" width=\"60%\"></p>\n<ul>\n<li>哈夫曼编码一定具有前缀性；<br>哈夫曼编码是最小冗余码;<br>哈夫曼编码方法，使出现概率大的字符对应的码长较短；<br>哈夫曼编码不唯一，可以用于加密；<br>哈夫曼编码译码简单唯一，没有二义性.</li>\n</ul>\n<h6 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h6><p>把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值</p>\n<p> 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。</p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><p>简单路径：若路径上各顶点 v1,v2,…,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。</p>\n<p> 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。</p>\n<h5 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>空间性能</th>\n<th>时间性能</th>\n<th>唯一性</th>\n<th>适用范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>邻接矩阵</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>唯一</td>\n<td>稠密图</td>\n</tr>\n<tr>\n<td>邻接表</td>\n<td>O(n+e)</td>\n<td>O(n+e)</td>\n<td>不唯一</td>\n<td>稀疏图</td>\n</tr>\n</tbody>\n</table>\n<p>十字链表、邻接多重表</p>\n<h5 id=\"图的搜索\"><a href=\"#图的搜索\" class=\"headerlink\" title=\"图的搜索\"></a>图的搜索</h5><ul>\n<li>深度优先搜索</li>\n</ul>\n<p>从一个顶点出发的一次深度优先遍历算法：<br>实现步骤： </p>\n<ol>\n<li>访问顶点v; visited[v]=1; </li>\n<li>w=顶点v的第一个邻接点； </li>\n<li>while (w存在)<br>3.1 if (w未被访问) 从顶点w出发递归执行该算法;<br>3.2 w=顶点v的下一个邻接点;</li>\n</ol>\n<p>邻接矩阵：空间：O(n^2)       时间： O(n^2)</p>\n<p>邻接表：O(n)  O(V+E)</p>\n<ul>\n<li>广度优先搜索</li>\n</ul>\n<p>1 . 初始化队列Q;</p>\n<ol start=\"2\">\n<li>访问顶点v; visited [v]=1; 顶点v入队Q;</li>\n<li>while (队列Q非空)<br> 3.1 v=队列Q的队头元素出队;<br> 3.2 w=顶点v的第一个邻接点;<br> 3.3 while (w存在) <pre><code>3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n3.3.2 w=顶点v的下一个邻接点；\n</code></pre></li>\n</ol>\n<h5 id=\"图与树、最小生成树\"><a href=\"#图与树、最小生成树\" class=\"headerlink\" title=\"图与树、最小生成树\"></a>图与树、最小生成树</h5><h6 id=\"先深和先广生成森林\"><a href=\"#先深和先广生成森林\" class=\"headerlink\" title=\"先深和先广生成森林\"></a>先深和先广生成森林</h6><ul>\n<li>先深搜索对边的分类<br>两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;<br>结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然</li>\n<li>先广搜索对边的分类<br>两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.<br>结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然</li>\n</ul>\n<h6 id=\"无向图与开放树\"><a href=\"#无向图与开放树\" class=\"headerlink\" title=\"无向图与开放树\"></a>无向图与开放树</h6><p>连通而无环路的无向图称作开放树（Free  Tree）</p>\n<p>（1）具有n≥1个顶点的开放树包含n-1条边； </p>\n<p>（2）如果在开放树中任意加上一条边，便得到一条回路</p>\n<h6 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h6><ul>\n<li>普里姆Prim算法：</li>\n</ul>\n<p>基本思想<br>① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ }<br>② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U<br>③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树</p>\n<p>如何找到连接U和V-U的最短边 ：<br>利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。</p>\n<ol>\n<li><p>初始化两个辅助数组LOWCOST和CLOSEST；</p>\n</li>\n<li><p>输出顶点v0，将顶点v0加入集合U中；</p>\n</li>\n<li><p>重复执行下列操作n-1次<br>3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；<br>3.2 输出顶点k和对应的权值；<br>3.3 将顶点k加入集合U中；<br>3.4 调整数组LOWCOST和CLOSEST；</p>\n<p>LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]}<br>CLOSEST[j]=k</p>\n</li>\n</ol>\n<p>时间复杂度：O(n^2)</p>\n<ul>\n<li>克鲁斯卡尔（Kruskal）算法</li>\n</ul>\n<p>注：边值各不相同时生成树唯一</p>\n<p>基本思想：<br>设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }，<br>然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。<br>若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，<br>如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。</p>\n<ol>\n<li>初始化：U=V； TE={ }； </li>\n<li>循环直到T中的连通分量个数为1<br> 2.1 在E中选择最短边(u，v);<br> 2.2 如果顶点u、v位于T的两个不同连通分量，则<br> ​    2.2.1 将边(u，v)并入TE；<br> ​    2.2.2 将这两个连通分量合为一个；<br> 2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取</li>\n</ol>\n<p>时间复杂度：O(eloge)</p>\n<h5 id=\"无向图的双连通性\"><a href=\"#无向图的双连通性\" class=\"headerlink\" title=\"无向图的双连通性\"></a>无向图的双连通性</h5><p>若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。</p>\n<p>1、没有关节点的连通图称为双连通图。<br>2、双连通的无向图是连通的，但连通的无向图未必双连通。<br>3、一个连通的无向图是双连通的，当且仅当它没有关节点。<br>4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。<br>5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。</p>\n<ul>\n<li><p>由先深生成树可得出两类关节点的特性：</p>\n<p>1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 </p>\n</li>\n</ul>\n<p>2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来</p>\n<p>算法要点：<br> 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。<br> 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：<br> (1)  dfn[v]；<br> (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；<br> (3)  low[y]，对v的任何儿子y。<br> 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求双连通分量的算法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tcount = <span class=\"number\">1</span>; <span class=\"keyword\">for</span> (all v ∈ V)  mark v “<span class=\"keyword\">new</span>”; searchB( v0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">searchB</span><span class=\"params\">(v)</span> </span>&#123; </span><br><span class=\"line\">\tmark v “old”;</span><br><span class=\"line\">\tdfn[v] = count;count++; </span><br><span class=\"line\">\tlow[v]=dfn[v]; </span><br><span class=\"line\"> \t<span class=\"keyword\">for</span> (each w ∈ L[v])</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span> (w is marked “<span class=\"keyword\">new</span>”) &#123; </span><br><span class=\"line\">         \tfather [w]=v；searchB (w); </span><br><span class=\"line\">         \tlow [v]= min &#123; low [v], low [w] &#125;; </span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (low[w]&gt;=dfn[v]) <span class=\"comment\">//表明W及子孙均无指向V的祖先的回退边，v是关节点</span></span><br><span class=\"line\">           \t <span class=\"built_in\">cout</span>&lt;&lt;“a biconnected component”; &#125; </span><br><span class=\"line\">    \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (w != father [v]) <span class=\"comment\">//(v ,w)是回退边   </span></span><br><span class=\"line\">          low [v]= min &#123; low [v],  dfn [w] &#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h5><p>是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） </p>\n<p>实质：广度优先搜索算法</p>\n<p>AOV网（有向图）</p>\n<ul>\n<li><p>利用队列算法：<br>1.建立入度为零的顶点排队<br>2.扫描顶点表，将入度为0的顶点入队；<br>3.while（排队不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入队 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n<li><p>利用栈算法：<br>1.建立入度为零的顶点栈<br>2.扫描顶点表，将入度为0的顶点栈；<br>3.while（栈不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入栈 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n</ul>\n<p>注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。</p>\n<ul>\n<li>说明：<ul>\n<li>与先广搜索的差别：<br>​      搜索起点是入度为0的顶点；<br>​      需判断是否有环路；<br>​      需对访问并输出的顶点计数（引入计数器nodes）。<br>​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。</li>\n<li>也可以采用栈数据结构进行广度优先拓扑排序。 </li>\n<li>亦可采用无后继顶点优先的拓扑排序算法</li>\n<li>也可以利用DFS遍历进行拓扑排序</li>\n</ul>\n</li>\n<li>基于DFS的拓扑排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topodfs</span> <span class=\"params\">( v )</span> </span>&#123;   </span><br><span class=\"line\">    Push( v ,S ) ; </span><br><span class=\"line\">    mark[v]=True; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( L[v] 中的每一个顶点w) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( mark[w] = False ) topodfs ( w ) ; </span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( Top( S ) ) ; </span><br><span class=\"line\">    Pop ( S ) ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span>  dfs-topo ( GRAPH  L ) &#123;  </span><br><span class=\"line\">    MakeNull( S ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n; u++) </span><br><span class=\"line\">        mark[u]=False; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n;u++) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !mark[u] ) </span><br><span class=\"line\">            topodfs( u ) ;</span><br></pre></td></tr></table></figure>\n<p>思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。</p>\n<h5 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h5><p>AOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）</p>\n<p>最大长度的路径称为关键路径。<br>一个AOE中，关键路径可能不只一条。<br>关键活动：关键路径上的活动称为关键活动。</p>\n<p>关键路径算法步骤：</p>\n<p>（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}<br>其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）</p>\n<p>（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }<br>其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S</p>\n<p>（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 </p>\n<p>（４）若某条边满足E( i ) = L( i )，则它是关键活动。</p>\n<p>注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。</p>\n<h5 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h5><ul>\n<li>边上权值非负情形的单源最短路径问题 — Dijkstra算法 </li>\n</ul>\n<p>Dijkstra算法实现步骤：</p>\n<ol>\n<li>将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。</li>\n<li>从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。</li>\n<li>调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 </li>\n<li>重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">costtype <span class=\"title\">MinCost</span> <span class=\"params\">(D, S)</span> </span>&#123; </span><br><span class=\"line\">\ttemp = INFINITY ; w = <span class=\"number\">2</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n ; i++ )</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!S[i]&amp;&amp;D[i]&lt;temp)  &#123;</span><br><span class=\"line\">  \t\t\ttemp = D[i] ; w = i ; &#125; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span>  w ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">Dijkstra</span><span class=\"params\">(GRAPH  C, costtype D[n+<span class=\"number\">1</span>] ，<span class=\"keyword\">int</span> P[n+<span class=\"number\">1</span>]，<span class=\"keyword\">bool</span> S[n+<span class=\"number\">1</span>])</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n; i++ ) &#123;  </span><br><span class=\"line\">\tD[i]=C[<span class=\"number\">1</span>][i] ; S[i]=False ;P[i]=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">\tS [<span class=\"number\">1</span>]= True ; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( i=<span class=\"number\">1</span>; i&lt;=n<span class=\"number\">-1</span>; i++) &#123;  </span><br><span class=\"line\">\t\tw=MinCost ( D, S ) ; S[w]=True ; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( v=<span class=\"number\">2</span> ; v&lt;= n ; n++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( S[v]!=True ) &#123;  </span><br><span class=\"line\">        \t        sum=D[w] + C[w][v] ;</span><br><span class=\"line\"> \t\t\t<span class=\"keyword\">if</span> (sum &lt; D[v】 )&#123;D[v] = sum ; P[v]=w;&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;<span class=\"comment\">//   时间复杂度：O（n^2）</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有顶点之间的最短路径问题 — Floyd算法 </li>\n</ul>\n<p>基本思想：动态规划</p>\n<p>求解过程：</p>\n<p>设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i —&gt; j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞</p>\n<p> 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] </p>\n<p>2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Floyd</span><span class=\"params\">( costtype A[][], costtype C[][], <span class=\"keyword\">int</span> P[][], <span class=\"keyword\">int</span> n)</span> </span>&#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ )</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j&lt; n; j++ ) &#123;</span><br><span class=\"line\">\t\t\tA[i][j] = C[i][j];  P[i][j] = <span class=\"number\">-1</span>； &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( k = <span class=\"number\">0</span>; k &lt; n; k++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ ) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; n; j++ )</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ( A[i][k] + A[k][j] &lt; A[i][j] )&#123; </span><br><span class=\"line\">                \tA[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">&#125; <span class=\"comment\">/* 时间复杂度：O(n3) */</span></span><br><span class=\"line\">Warshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]);</span><br><span class=\"line\">可以判定有向图任意两点间是否存在有向 路。</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><h5 id=\"线性查找\"><a href=\"#线性查找\" class=\"headerlink\" title=\"线性查找\"></a>线性查找</h5><p>插入和删除：从后往前</p>\n<p>第0个元素做为伪记录或哨兵 </p>\n<h5 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h5><p>折半查找只适合于静态查找</p>\n<ul>\n<li><p>数组：时间复杂度O(logn)</p>\n</li>\n<li><p>判定树:</p>\n</li>\n</ul>\n<p>高度： (n+1)/nlog2(n+1)-1</p>\n<p>当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近</p>\n<h5 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h5><p>基本思想：均匀分块，块间有序，块内无序</p>\n<p>索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.</p>\n<p>块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j </p>\n<p>所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。</p>\n<h5 id=\"BST-二叉查找树\"><a href=\"#BST-二叉查找树\" class=\"headerlink\" title=\"BST-二叉查找树\"></a>BST-二叉查找树</h5><ul>\n<li><p>插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. </p>\n</li>\n<li><p>删除：</p>\n</li>\n</ul>\n<ol>\n<li>若结点p是叶子，则直接删除结点p； </li>\n<li>若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； </li>\n<li>若结点p的左右子树均不空，则<br> 3.1 查找结点p的右子树上的最左下结点s及其双亲结点par；<br> 3.2 将结点s数据域替换到被删结点p的数据域；<br> 3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上；<br> 3.4 删除结点s；</li>\n</ol>\n<ul>\n<li>性能：</li>\n</ul>\n<p>二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。</p>\n<p> 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。</p>\n<p> 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) </p>\n<p>就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。</p>\n<h5 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h5><p>AVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。<br>令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。<br>因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）<br>Fh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1<br>所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2<br>因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)</p>\n<h5 id=\"B-树和B-树\"><a href=\"#B-树和B-树\" class=\"headerlink\" title=\"B-树和B+树\"></a>B-树和B+树</h5><ul>\n<li><p>B-树</p>\n<ul>\n<li><p>树中可容纳结点数量最大值，关键字个数最多：m^h-1</p>\n</li>\n<li><p>树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；</p>\n</li>\n<li><p>除根结点和失败结点外，所有结点至少有 m/2 棵子树； </p>\n</li>\n<li><p>所有的终端结点和叶子结点（失败结点）都位于同一层。</p>\n</li>\n<li><p>h 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)</p>\n</li>\n<li><p>关键字个数N：N +1 = 位于第 h+1 层的结点数 &gt;= 2 *(m / 2)^ (h -1)</p>\n</li>\n<li><p>N+1&gt;= 2 *(m / 2)^ (h -1)  ;    h-1 &lt;= log(m / 2)(( N + 1 ) / 2 ) </p>\n</li>\n</ul>\n</li>\n<li><p>B+树</p>\n<ul>\n<li><p>(1) 有k个子结点的结点必然有k个关键字；</p>\n</li>\n<li><p>(2) 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。<br>3阶B+树</p>\n</li>\n<li><p>(3) 所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。<br>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>\n</li>\n<li><p>(4) 可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h5><p>不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词</p>\n<p>散列函数的构造的原则： 计算简单、分布均匀</p>\n<ul>\n<li><p>构造方法：<br>直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、</p>\n</li>\n<li><p>冲突处理：</p>\n</li>\n</ul>\n<p>1、开放定址法：<br>–线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               –线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…）<br>–二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2）<br>–随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） </p>\n<p>2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高</p>\n<p>3、拉链法\\链地址法：</p>\n<h4 id=\"内部排序\"><a href=\"#内部排序\" class=\"headerlink\" title=\"内部排序\"></a>内部排序</h4><h5 id=\"气泡排序\"><a href=\"#气泡排序\" class=\"headerlink\" title=\"气泡排序\"></a>气泡排序</h5><p>最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； </p>\n<p>最坏情况（反序）： 比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2         时间复杂度： O(n^2)</p>\n<p>平均情况：时间复杂度为O(n^2)  </p>\n<p>空间复杂度： O(1)</p>\n<h5 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h5><p>对气泡排序的改进</p>\n<p>最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)</p>\n<p>最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)</p>\n<p>平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)</p>\n<h5 id=\"直接选择排序\"><a href=\"#直接选择排序\" class=\"headerlink\" title=\"直接选择排序\"></a>直接选择排序</h5><p>移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次</p>\n<p>比较次数：n(n-1)/2</p>\n<p>时间复杂度为O(n^2)</p>\n<p> 空间复杂度为O(1)</p>\n<h5 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h5><p>对直接选择排序的改进</p>\n<p>首先将待排序的记录序列用完全二叉树表示；<br>然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；<br>最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。</p>\n<p>堆排序：令i = n, n-1 ,…, 2 </p>\n<p>1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])；<br>2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)；<br>3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(1)</p>\n<h5 id=\"（直接）插入排序\"><a href=\"#（直接）插入排序\" class=\"headerlink\" title=\"（直接）插入排序\"></a>（直接）插入排序</h5><p>最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)</p>\n<p>最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)</p>\n<p>最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)</p>\n<h5 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h5><p>对直接插入排序的改进</p>\n<p>时间性能：在O(n^2)和O(nlog2n)之间。</p>\n<p>当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) </p>\n<h5 id=\"二路-归并排序\"><a href=\"#二路-归并排序\" class=\"headerlink\" title=\"(二路)归并排序\"></a>(二路)归并排序</h5><p>基本思想：自底向上的非递归算法</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(n)</p>\n<h5 id=\"基数排序–多关键字排序\"><a href=\"#基数排序–多关键字排序\" class=\"headerlink\" title=\"基数排序–多关键字排序\"></a>基数排序–多关键字排序</h5><p>次序：从最低位排序，使用了队列</p>\n<p>改进：桶—-链式排队</p>\n<p>时间复杂度：O(d(n+r))    （n—记录数，d—-关键字(分量)个数，r—-基数）</p>\n<p>空间复杂度：O((n+r)) </p>\n<h5 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h5><p>数组记录对应关键字出现的最后一个位置</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>快排</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n^2)</td>\n<td>O(log2n)~O(n)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>直接选择</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(1)</td>\n<td>否/1,2,2(最小堆)</td>\n</tr>\n<tr>\n<td>直接插入</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(nlog2n)</td>\n<td>O(n^1.3)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/3,2,2(d=2/1)</td>\n</tr>\n<tr>\n<td>二路归并</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(n+r)</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p>最坏：</p>\n<p> 气泡排序：比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2  </p>\n<p>选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   </p>\n<p>插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)</p>\n<h4 id=\"外排序\"><a href=\"#外排序\" class=\"headerlink\" title=\"外排序\"></a>外排序</h4><h5 id=\"磁盘文件的归并排序\"><a href=\"#磁盘文件的归并排序\" class=\"headerlink\" title=\"磁盘文件的归并排序\"></a>磁盘文件的归并排序</h5><p>方法：多路归并 、 I/O并行处理  、生成初始归并段</p>\n<ul>\n<li>磁盘文件的归并排序</li>\n</ul>\n<p>第一阶段：初始归并段形成 </p>\n<p>第二阶段：多路归并 </p>\n<ul>\n<li>多路归并-减少归并遍数</li>\n</ul>\n<p>一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。</p>\n<p>在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）<em>(K-1)</em>[logkm]=（n-1）<em>(K-1) </em>[log2(m/log2K)]</p>\n<ul>\n<li><p>K 路平衡归并与选择树</p>\n<ul>\n<li><p>第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) </p>\n</li>\n<li><p>而后每次重新建造选择树所需时间为： O( log2k ) </p>\n</li>\n<li><p>n 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间:</p>\n</li>\n</ul>\n<p>​      O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 </p>\n<ul>\n<li>归并遍数为 logkm，总时间为:O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )</li>\n</ul>\n</li>\n<li><p>并行操作的缓冲区处理</p>\n<p>​                    ——-使输入、输出和CPU处理尽可能重叠</p>\n</li>\n</ul>\n<p>对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作</p>\n<ul>\n<li>生成初始归并段（使用选择树法）：多路平衡归并</li>\n</ul>\n<p>假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：<br>(1) 从FI输入P个记录到缓冲区W;<br>(2)从W中选择出关键字最小的记录MIN；<br>(3)将MIN记录输出到FO中去；<br>(4)若FI不空，则从FI输入下一个记录到W;<br>(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN;<br>(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中<br>(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段</p>\n<p>生成的初始归并段的平均长度是缓冲区长度的两倍</p>\n<p>最佳归并树：使外存读写次数最少，是一棵正则树</p>\n<p>对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1</p>\n<p>加入细节点：</p>\n<ul>\n<li>已知前序和后序不能确定唯一二叉树</li>\n<li>//判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号</li>\n<li><p>树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树</p>\n</li>\n<li><p>解决冲突的方法：线性再散列、内散列表、外散列表</p>\n</li>\n<li><p>左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针</p>\n</li>\n<li><p>折半查找树高度： (n+1)/nlog2(n+1)-1</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h4><h5 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h5><ul>\n<li><p>抽象数据类型:(Abstract Date Type)</p>\n<p>  -定义：一个数学模型和该模型上定义的操作集合的总称</p>\n<p>  *ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象</p>\n<p>  *同一数学模型上定义的不同操作集，则他们代表不同的ADT</p>\n<p>  -表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作</p>\n</li>\n<li><p>逻辑结构：</p>\n<p>集合——没关系</p>\n<p>线性表——1:1前后</p>\n<p>树——1：m层次</p>\n<p>图——网状</p>\n</li>\n<li><p>存储结构：</p>\n<p>​    顺序——连续空间          $\\Rightarrow$索引</p>\n<p>​    链式——不连续空间          +散列</p>\n</li>\n</ul>\n<h5 id=\"算法及算法分析\"><a href=\"#算法及算法分析\" class=\"headerlink\" title=\"算法及算法分析\"></a>算法及算法分析</h5><ul>\n<li><p>算法的相关概念</p>\n<p>  -算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列</p>\n<p>  -五大特性：输入   输出   有穷性   确定性</p>\n</li>\n<li><p>时间复杂度（time  xomplexity)</p>\n<p>  算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度</p>\n</li>\n<li><p>常见时间复杂度的比较</p>\n</li>\n</ul>\n<p>0(1)&lt; &lt;0(logn) &lt;&lt;0(n)&lt; &lt; 0(nlogn) &lt;&lt; 0(n2) &lt;&lt; 0(n3) &lt;&lt;0(2n) &lt;&lt; 0(n!)</p>\n<ul>\n<li>常见设计方法：</li>\n</ul>\n<p>穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)</p>\n<p>$\\alpha -\\beta$裁剪和分支界限法、并行算法</p>\n<ul>\n<li>时空资源的折中原理</li>\n</ul>\n<p>同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质</p>\n<h5 id=\"逐步求精的程序设计方法\"><a href=\"#逐步求精的程序设计方法\" class=\"headerlink\" title=\"逐步求精的程序设计方法\"></a>逐步求精的程序设计方法</h5><p>​    模型化-确定算法-逐步求精    </p>\n<h4 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h4><h5 id=\"线性表的抽象数据类型\"><a href=\"#线性表的抽象数据类型\" class=\"headerlink\" title=\"线性表的抽象数据类型\"></a>线性表的抽象数据类型</h5><p>​     顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素</p>\n<h5 id=\"线性表的实现\"><a href=\"#线性表的实现\" class=\"headerlink\" title=\"线性表的实现\"></a>线性表的实现</h5><p>存储结构的三种方式：</p>\n<p> ① 连续的存储空间（数组） →  静态存储</p>\n<p> ② 非连续存储空间——指针（链表） →  动态存储</p>\n<p> ③ 游标（连续存储空间+动态管理思想）→  静态链表</p>\n<h6 id=\"线性表的数组实现：\"><a href=\"#线性表的数组实现：\" class=\"headerlink\" title=\"线性表的数组实现：\"></a>线性表的数组实现：</h6><p>随机存储结构，查找快   o(1)</p>\n<p>插入和删除慢  o(n)</p>\n<p>空间固定</p>\n<h6 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h6><p>非随机存储结构</p>\n<p>eg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2</p>\n<p>​    求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走</p>\n<ul>\n<li><p>插入元素</p>\n<p>a、保存后继指针</p>\n<p>b、申请一个内存空间</p>\n<p>c、插入：先链接后部分，再衔接前部分</p>\n</li>\n</ul>\n<h6 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h6><p>元素是结构体数组，多个线性表公用一个存储池</p>\n<p>单链表逆置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一：</span></span><br><span class=\"line\"><span class=\"comment\">//设表头为L,算法如下: </span></span><br><span class=\"line\">p=L-&gt;next-&gt;next; q=p-&gt;next; L-&gt;next-&gt;next=<span class=\"literal\">NULL</span>; <span class=\"keyword\">while</span>(p!=null) &#123;</span><br><span class=\"line\">    p-&gt;next=L-&gt;next;</span><br><span class=\"line\">    L-&gt;next=p;</span><br><span class=\"line\">    p=q;</span><br><span class=\"line\">    q=q-&gt;next; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法二：</span></span><br><span class=\"line\"><span class=\"comment\">//线性表由q来表示 </span></span><br><span class=\"line\">p=null; w=q; <span class=\"keyword\">while</span>(w!=null) &#123; </span><br><span class=\"line\">    w=w-&gt;next; </span><br><span class=\"line\">    q-&gt;next=p;</span><br><span class=\"line\">    p=q; q=w; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>双向单链表插入与删除：</p>\n<p><img src=\"/img/ds/双向单链表.PNG\" width=\"60%\"></p>\n<h6 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h6><ul>\n<li><p>数组求模可以成环</p>\n</li>\n<li><p>判断链表是否成环：两个指针，速度分别为1和2,</p>\n</li>\n<li><p>确定环入口：</p>\n</li>\n<li><p>两个链表是否相交:判断两个列表最后一个元素是否相同//散列</p>\n</li>\n<li><p>单项循环链表插入与删除：</p>\n</li>\n</ul>\n<p><img src=\"/img/ds/双循环1.PNG\" width=\"60%\"></p>\n<p><img src=\"/img/ds/双循环2.PNG\" width=\"60%\"></p>\n<h5 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h5><ul>\n<li>多项式的代数运算</li>\n</ul>\n<p><img src=\"/img/ds/中缀转后缀表达式.PNG\" width=\"60%\"></p>\n<ul>\n<li><p>后缀表达式求值：</p>\n<p>对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。</p>\n</li>\n</ul>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>优先队列：</p>\n<p>问题：如何解决循环队列中队空与队满状态相同？<br>方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；</p>\n<p> 方法二：另设一个标志位用以区别队空与队满两种状态；<br>结论：两种方法的代价是相同的。</p>\n<h5 id=\"串（String）\"><a href=\"#串（String）\" class=\"headerlink\" title=\"串（String）\"></a>串（String）</h5><p>KMP算法：</p>\n<p>一、如何求next函数:</p>\n<ul>\n<li><p>当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 </p>\n</li>\n<li><p>当j&gt;1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。</p>\n</li>\n<li>当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较</li>\n</ul>\n<p>下面给出求next函数的伪码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"keyword\">int</span> &amp;next[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//求模式串T的next函数并存入next数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">while</span> (i &lt; T[<span class=\"number\">0</span>]) <span class=\"comment\">//T[0]中存放数组长度 &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>( j==<span class=\"number\">0</span>||T[i]==T[j]) &#123; ++i; ++j;  next[i]=j; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span> j= next[j]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;<span class=\"comment\">//get_next</span></span><br></pre></td></tr></table></figure>\n<p>二、KMP算法实现步骤：</p>\n<p>   1.在串S和串T中分别设比较的起始下标i和j；</p>\n<ol start=\"2\">\n<li>循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕<br>2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则<br>2.2将j向右滑动到next[j]位置，即j=next[j]；<br>2.3 如果j=0，则将i和j分别加1，准备下一趟比较；</li>\n<li>如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；</li>\n</ol>\n<h5 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h5><p>例如：</p>\n<p> A = （a，（b，a，b），（），c，（（（2））））； </p>\n<p>B = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；</p>\n<p>长度：广义表LS中的直接元素的个数；<br>深度：广义表LS中括号的最大嵌套层数。<br>表头：广义表LS非空时，称第一个元素为LS的表头；<br>表尾：广义表LS中除表头外其余元素组成的广义表。</p>\n<h4 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h4><h5 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h5><h6 id=\"性质：\"><a href=\"#性质：\" class=\"headerlink\" title=\"性质：\"></a>性质：</h6><p>在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关</p>\n<h6 id=\"建立\"><a href=\"#建立\" class=\"headerlink\" title=\"建立\"></a>建立</h6><p>建立：</p>\n<p><img src=\"/img/ds/建立1.PNG\" width=\"60%\"></p>\n<p>先序建立：</p>\n<p><img src=\"/img/ds/先序建立.PNG\" width=\"60%\"></p>\n<p>非递归建立：</p>\n<p><img src=\"/img/ds/建立非.PNG\" width=\"60%\"></p>\n<h6 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h6><ul>\n<li>先序递归：</li>\n</ul>\n<p><img src=\"/img/ds/先序.PNG\" width=\"60%\"></p>\n<ul>\n<li>先序非递归：</li>\n</ul>\n<p>1.栈s初始化；<br>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 输出root-&gt;data;<br>         2.1.2 将指针root的值保存到栈中；<br>​        2.1.3 继续遍历root的左子树<br>​    2.2 如果栈s不空，则<br>​        2.2.1 将栈顶元素弹出至root；<br>​        2.2.2 准备遍历root的右子树；</p>\n<ul>\n<li>中序非递归：</li>\n</ul>\n<p>1.栈s初始化； </p>\n<p>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 将指针root的值保存到栈中；<br>         2.1.2 继续遍历root的左子树<br>     2.2 如果栈s不空，则<br>         2.2.1 将栈顶元素弹出至root；<br>         2.2.2 输出root-&gt;data;<br>​        2.2.3 准备遍历root的右子树</p>\n<ul>\n<li>后序非递归：</li>\n</ul>\n<ol>\n<li>栈s初始化； </li>\n<li>循环直到root为空且栈s为空<br> 2.1 当root非空时循环<br> ​    2.1.1 将root连同标志flag=1 入栈；<br> ​    2.1.2 继续遍历root的左子树；<br> 2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点;<br> 2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；</li>\n</ol>\n<p><img src=\"/img/ds/二叉树先序遍历.PNG\" width=\"60%\"></p>\n<ul>\n<li>层序遍历：</li>\n</ul>\n<ol>\n<li>队列Q初始化；</li>\n<li>如果二叉树非空，将根指针入队；</li>\n<li>循环直到队列Q为空<br>3.1 q=队列Q的队头元素出队；<br>3.2 访问结点q的数据域；<br>3.3 若结点q存在左孩子，则将左孩子指针入队；<br>3.4 若结点q存在右孩子，则将右孩子指针入队；</li>\n</ol>\n<h6 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h6><ul>\n<li>1、已知先序中序确定二叉树：</li>\n</ul>\n<p>遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，<br>​    如果栈为空，将下标 j 入栈；<br>​    否则，栈不为空：<br>​        如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈</p>\n<p><img src=\"/img/ds/已知先序中序构二叉树.PNG\" width=\"60%\"></p>\n<ul>\n<li>2、求二叉树任意两节点公共祖先：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == p || root == q) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;<span class=\"comment\">//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个</span></span><br><span class=\"line\">    TreeNode *L = lowestCommonAncestor(root-&gt;left, p, q);<span class=\"comment\">//左子树中是否能最先找到p,q中的一个节点</span></span><br><span class=\"line\">    TreeNode *R = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L &amp;&amp; R) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;  <span class=\"comment\">//如果当前节点左右节点都各找到一个，那么返回当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> L ? L : R; <span class=\"comment\">//只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3、求二叉树宽度：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>  front=<span class=\"number\">-1</span>,rear=<span class=\"number\">-1</span>,count=<span class=\"number\">0</span>,max=<span class=\"number\">0</span>,right</span><br><span class=\"line\"><span class=\"keyword\">if</span> (T!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">\tq[++rear]=T;max=<span class=\"number\">1</span>;right=rear; </span><br><span class=\"line\"><span class=\"keyword\">while</span>(front!=rear) &#123;</span><br><span class=\"line\">\tT=q[++front];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;lc!=<span class=\"literal\">NULL</span>)q[++rear]=T-&gt;lc; count++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;rc!=<span class=\"literal\">NULL</span> q[++rear]=T-&gt;rc; count++; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(front==right) &#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(max&lt;count)max=count; count=<span class=\"number\">0</span>;right=rear;&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>4、线索树：</li>\n</ul>\n<p>1）在中序线索二叉树中求一个结点p的中序后继p：</p>\n<p>​    当p-&gt;rtag==False时，p-&gt;rchild 即为所求(线索)。</p>\n<pre><code>当p-&gt;rtag==True时，p为p 的右子树的最左结点\n</code></pre><p>2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void ThInOrder(ThTree HEAD) &#123;  </span><br><span class=\"line\">ThTree   tmp ; tmp = HEAD ; </span><br><span class=\"line\">  do &#123; </span><br><span class=\"line\">  \ttmp = InNext ( tmp ) ; </span><br><span class=\"line\"> if ( tmp != HEAD ) visit ( tmp -&gt; data ) ;</span><br><span class=\"line\">&#125; while ( tmp != HEAD ) ; &#125;</span><br></pre></td></tr></table></figure>\n<p>  3）求中序线索二叉树中结点p 的先序顺序后继结点p* </p>\n<p>(1) p 的左子树不空时，p 的左儿子p-&gt;lchild 即为 p<em>；<br>(2) p 的左子树空但右子树不空时，p 的p-&gt;rchild 为p</em>；<br>(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THTREE PreNext( ThTree p) &#123;   </span><br><span class=\"line\">\tThTree Q ;</span><br><span class=\"line\">\tif (p-&gt;ltag = = True ) Q=p-&gt;lchild ; </span><br><span class=\"line\">\telse&#123;</span><br><span class=\"line\">\t\tQ = p;</span><br><span class=\"line\">\t\twhile(Q-&gt;rtag = = False) Q = Q-&gt;rchild ; </span><br><span class=\"line\">\t\tQ = Q-&gt;rchild ;</span><br><span class=\"line\">\t&#125;  return ( Q ) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>相似二叉树:具有相同结构的二叉树为相似二叉树。 </p>\n</li>\n<li><p>相似且对应结点包含相同信息的二叉树称为等价二叉树。 </p>\n</li>\n</ul>\n<h5 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h5><p>最大堆：</p>\n<p>如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆</p>\n<ul>\n<li>大根堆插入：</li>\n</ul>\n<p>void Insert ( Heap &amp;heap，Elementtype x)//大根堆插入一个元素 {<br>​    int i;<br>​    if ( ! HeapFull ( heap ) ) {<br>​        i=heap.n+1;<br>​        while ( (i!=1)&amp;&amp;(x &gt;heap.ele [i/2] ) ) {<br>​            heap.ele [i]=heap.ele [i/2]; i=i/2;<br>     } heap.ele [i] = x;</p>\n<ul>\n<li>大根堆删除：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMax</span> <span class=\"params\">(Heap &amp; heap )</span><span class=\"comment\">//大根堆删除 &#123;  </span></span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"keyword\">int</span> parent</span>=<span class=\"number\">1</span>, child=<span class=\"number\">2</span>;  Elementtype  ele,  tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (! HeapEmpty(heap)) &#123; </span><br><span class=\"line\">\t\tele=heap.ele [<span class=\"number\">1</span>]; tmp=heap.ele [heap.n--];</span><br><span class=\"line\"> \t\t<span class=\"keyword\">while</span> (child&lt;= heap.n)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(child&lt;heap.n)&amp;&amp;(heap.ele [child]&lt;heap.ele [child+<span class=\"number\">1</span>]))</span><br><span class=\"line\">                \tchild++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&gt;=heap.ele [child])  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\theap.ele [parent]=heap.ele [child]; </span><br><span class=\"line\">\t\t\tparent=child; child*=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"comment\">//while</span></span><br><span class=\"line\"> \t\theap.ele [parent]=tmp; <span class=\"keyword\">return</span> ele; </span><br><span class=\"line\">\t&#125;<span class=\"comment\">//if</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"选择树\"><a href=\"#选择树\" class=\"headerlink\" title=\"选择树\"></a>选择树</h5><p>​    胜者树、败者树</p>\n<h5 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h5><p>存储结构：</p>\n<p>双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>树</th>\n<th>二叉树</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>节点关系</td>\n<td>兄弟关系</td>\n<td>双亲和右孩子</td>\n</tr>\n<tr>\n<td></td>\n<td>双亲和长子</td>\n<td>双亲和左孩子</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"森林与二叉树的相互转换\"><a href=\"#森林与二叉树的相互转换\" class=\"headerlink\" title=\"森林与二叉树的相互转换\"></a>森林与二叉树的相互转换</h5><ul>\n<li>森林转化成二叉树：</li>\n</ul>\n<p>1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）</p>\n<p> 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 </p>\n<p>3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）</p>\n<ul>\n<li>二叉树转化成森林（树）</li>\n</ul>\n<p>连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；</p>\n<p> 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; </p>\n<p>旋转： 按逆时针旋转45度角（即把结点按层次排列）</p>\n<ul>\n<li>将一株树转换为二叉树，二叉树一定没有右子树</li>\n<li>一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；</li>\n<li><p>任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；</p>\n</li>\n<li><p>森林(树)转换成二叉树的递归算法：</p>\n<p>F ={T1,T2, …,Tn}<br>二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则<br>B(F)的根就是root（T1）；<br>B(F)的左子树是F的第一棵树T1的子树森林；<br>B(F)的右子树F的其余子树森林。 </p>\n</li>\n<li><p>二叉树转换成森林(树) 的递归算法 ：</p>\n</li>\n</ul>\n<p>若B 为空，则F 为空；若B 不空，则<br> F中的第一株树T1 的根对应二叉树B 的根；<br> T1中根结点的子树森林F1是由B的左子树转换来的；<br> F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。</p>\n<h5 id=\"树的应用\"><a href=\"#树的应用\" class=\"headerlink\" title=\"树的应用\"></a>树的应用</h5><ul>\n<li><p>堆的复杂度：O(n)</p>\n</li>\n<li><p>败者树的复杂度：O(2n-1)</p>\n</li>\n</ul>\n<h6 id=\"用树结构表示集合：\"><a href=\"#用树结构表示集合：\" class=\"headerlink\" title=\"用树结构表示集合：\"></a>用树结构表示集合：</h6><p>等价分类算法： </p>\n<ol>\n<li><p>令S中的每一个元素自身构成一个等价类，S1,S2,…S7 </p>\n</li>\n<li><p>重复读入等价对（i,  j）<br>2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性）<br>2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Equivalence</span> <span class=\"params\">(MFSET S)</span>   <span class=\"comment\">//等价分类算法 &#123; </span></span></span><br><span class=\"line\">   int i ,j , k ,m; </span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n+<span class=\"number\">1</span>;i++) Initial(i,S);  <span class=\"comment\">//使集合S只包含元素i</span></span><br><span class=\"line\">   <span class=\"built_in\">cin</span>&gt;&gt;i&gt;&gt;j;        <span class=\"comment\">// 读入等价对</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(!(i==<span class=\"number\">0</span>&amp;&amp;j==<span class=\"number\">0</span>)&#123; <span class=\"comment\">// 等价对未读完</span></span><br><span class=\"line\">       k=Find(i,S);           <span class=\"comment\">//求i的根 </span></span><br><span class=\"line\">       m=Find(j,S);        <span class=\"comment\">// 求j的根</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(k!=m)          <span class=\"comment\">//if k==m,i,j已在一个树中，不需合并 </span></span><br><span class=\"line\">           Union(i,j,S);     <span class=\"comment\">//合并 </span></span><br><span class=\"line\">       <span class=\"built_in\">cin</span>&lt;&lt;i&lt;&lt;j;          </span><br><span class=\"line\">   &#125;  &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"判定树\"><a href=\"#判定树\" class=\"headerlink\" title=\"判定树\"></a>判定树</h6><p>判定树的特点：</p>\n<p> 一个判定树是一个算法的描述；<br>每个内部结点对应一个部分解； 每个叶子对应一个解；<br>每个内部结点连接与一个获得新信息的测试；<br> 从每个结点出发的分支标记着不同的测试结果；<br> 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合</p>\n<p>判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$</p>\n<h6 id=\"哈夫曼树：\"><a href=\"#哈夫曼树：\" class=\"headerlink\" title=\"哈夫曼树：\"></a>哈夫曼树：</h6><ul>\n<li>内外路径：</li>\n</ul>\n<p><img src=\"/img/ds/内外路径.PNG\" width=\"60%\"></p>\n<ul>\n<li>哈夫曼树性质：</li>\n</ul>\n<p>没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。</p>\n<p><img src=\"/img/ds/哈夫曼树性质1.PNG\" width=\"60%\"></p>\n<ul>\n<li>码长计算：</li>\n</ul>\n<p><img src=\"/img/ds/码长计算.PNG\" width=\"60%\"></p>\n<ul>\n<li>哈夫曼编码一定具有前缀性；<br>哈夫曼编码是最小冗余码;<br>哈夫曼编码方法，使出现概率大的字符对应的码长较短；<br>哈夫曼编码不唯一，可以用于加密；<br>哈夫曼编码译码简单唯一，没有二义性.</li>\n</ul>\n<h6 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h6><p>把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值</p>\n<p> 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。</p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><p>简单路径：若路径上各顶点 v1,v2,…,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。</p>\n<p> 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。</p>\n<h5 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>空间性能</th>\n<th>时间性能</th>\n<th>唯一性</th>\n<th>适用范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>邻接矩阵</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>唯一</td>\n<td>稠密图</td>\n</tr>\n<tr>\n<td>邻接表</td>\n<td>O(n+e)</td>\n<td>O(n+e)</td>\n<td>不唯一</td>\n<td>稀疏图</td>\n</tr>\n</tbody>\n</table>\n<p>十字链表、邻接多重表</p>\n<h5 id=\"图的搜索\"><a href=\"#图的搜索\" class=\"headerlink\" title=\"图的搜索\"></a>图的搜索</h5><ul>\n<li>深度优先搜索</li>\n</ul>\n<p>从一个顶点出发的一次深度优先遍历算法：<br>实现步骤： </p>\n<ol>\n<li>访问顶点v; visited[v]=1; </li>\n<li>w=顶点v的第一个邻接点； </li>\n<li>while (w存在)<br>3.1 if (w未被访问) 从顶点w出发递归执行该算法;<br>3.2 w=顶点v的下一个邻接点;</li>\n</ol>\n<p>邻接矩阵：空间：O(n^2)       时间： O(n^2)</p>\n<p>邻接表：O(n)  O(V+E)</p>\n<ul>\n<li>广度优先搜索</li>\n</ul>\n<p>1 . 初始化队列Q;</p>\n<ol start=\"2\">\n<li>访问顶点v; visited [v]=1; 顶点v入队Q;</li>\n<li>while (队列Q非空)<br> 3.1 v=队列Q的队头元素出队;<br> 3.2 w=顶点v的第一个邻接点;<br> 3.3 while (w存在) <pre><code>3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n3.3.2 w=顶点v的下一个邻接点；\n</code></pre></li>\n</ol>\n<h5 id=\"图与树、最小生成树\"><a href=\"#图与树、最小生成树\" class=\"headerlink\" title=\"图与树、最小生成树\"></a>图与树、最小生成树</h5><h6 id=\"先深和先广生成森林\"><a href=\"#先深和先广生成森林\" class=\"headerlink\" title=\"先深和先广生成森林\"></a>先深和先广生成森林</h6><ul>\n<li>先深搜索对边的分类<br>两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;<br>结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然</li>\n<li>先广搜索对边的分类<br>两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.<br>结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然</li>\n</ul>\n<h6 id=\"无向图与开放树\"><a href=\"#无向图与开放树\" class=\"headerlink\" title=\"无向图与开放树\"></a>无向图与开放树</h6><p>连通而无环路的无向图称作开放树（Free  Tree）</p>\n<p>（1）具有n≥1个顶点的开放树包含n-1条边； </p>\n<p>（2）如果在开放树中任意加上一条边，便得到一条回路</p>\n<h6 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h6><ul>\n<li>普里姆Prim算法：</li>\n</ul>\n<p>基本思想<br>① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ }<br>② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U<br>③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树</p>\n<p>如何找到连接U和V-U的最短边 ：<br>利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。</p>\n<ol>\n<li><p>初始化两个辅助数组LOWCOST和CLOSEST；</p>\n</li>\n<li><p>输出顶点v0，将顶点v0加入集合U中；</p>\n</li>\n<li><p>重复执行下列操作n-1次<br>3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；<br>3.2 输出顶点k和对应的权值；<br>3.3 将顶点k加入集合U中；<br>3.4 调整数组LOWCOST和CLOSEST；</p>\n<p>LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]}<br>CLOSEST[j]=k</p>\n</li>\n</ol>\n<p>时间复杂度：O(n^2)</p>\n<ul>\n<li>克鲁斯卡尔（Kruskal）算法</li>\n</ul>\n<p>注：边值各不相同时生成树唯一</p>\n<p>基本思想：<br>设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }，<br>然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。<br>若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，<br>如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。</p>\n<ol>\n<li>初始化：U=V； TE={ }； </li>\n<li>循环直到T中的连通分量个数为1<br> 2.1 在E中选择最短边(u，v);<br> 2.2 如果顶点u、v位于T的两个不同连通分量，则<br> ​    2.2.1 将边(u，v)并入TE；<br> ​    2.2.2 将这两个连通分量合为一个；<br> 2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取</li>\n</ol>\n<p>时间复杂度：O(eloge)</p>\n<h5 id=\"无向图的双连通性\"><a href=\"#无向图的双连通性\" class=\"headerlink\" title=\"无向图的双连通性\"></a>无向图的双连通性</h5><p>若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。</p>\n<p>1、没有关节点的连通图称为双连通图。<br>2、双连通的无向图是连通的，但连通的无向图未必双连通。<br>3、一个连通的无向图是双连通的，当且仅当它没有关节点。<br>4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。<br>5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。</p>\n<ul>\n<li><p>由先深生成树可得出两类关节点的特性：</p>\n<p>1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 </p>\n</li>\n</ul>\n<p>2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来</p>\n<p>算法要点：<br> 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。<br> 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：<br> (1)  dfn[v]；<br> (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；<br> (3)  low[y]，对v的任何儿子y。<br> 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求双连通分量的算法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">\tcount = <span class=\"number\">1</span>; <span class=\"keyword\">for</span> (all v ∈ V)  mark v “<span class=\"keyword\">new</span>”; searchB( v0 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">searchB</span><span class=\"params\">(v)</span> </span>&#123; </span><br><span class=\"line\">\tmark v “old”;</span><br><span class=\"line\">\tdfn[v] = count;count++; </span><br><span class=\"line\">\tlow[v]=dfn[v]; </span><br><span class=\"line\"> \t<span class=\"keyword\">for</span> (each w ∈ L[v])</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span> (w is marked “<span class=\"keyword\">new</span>”) &#123; </span><br><span class=\"line\">         \tfather [w]=v；searchB (w); </span><br><span class=\"line\">         \tlow [v]= min &#123; low [v], low [w] &#125;; </span><br><span class=\"line\">        \t<span class=\"keyword\">if</span> (low[w]&gt;=dfn[v]) <span class=\"comment\">//表明W及子孙均无指向V的祖先的回退边，v是关节点</span></span><br><span class=\"line\">           \t <span class=\"built_in\">cout</span>&lt;&lt;“a biconnected component”; &#125; </span><br><span class=\"line\">    \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (w != father [v]) <span class=\"comment\">//(v ,w)是回退边   </span></span><br><span class=\"line\">          low [v]= min &#123; low [v],  dfn [w] &#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h5><p>是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） </p>\n<p>实质：广度优先搜索算法</p>\n<p>AOV网（有向图）</p>\n<ul>\n<li><p>利用队列算法：<br>1.建立入度为零的顶点排队<br>2.扫描顶点表，将入度为0的顶点入队；<br>3.while（排队不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入队 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n<li><p>利用栈算法：<br>1.建立入度为零的顶点栈<br>2.扫描顶点表，将入度为0的顶点栈；<br>3.while（栈不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入栈 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n</ul>\n<p>注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。</p>\n<ul>\n<li>说明：<ul>\n<li>与先广搜索的差别：<br>​      搜索起点是入度为0的顶点；<br>​      需判断是否有环路；<br>​      需对访问并输出的顶点计数（引入计数器nodes）。<br>​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。</li>\n<li>也可以采用栈数据结构进行广度优先拓扑排序。 </li>\n<li>亦可采用无后继顶点优先的拓扑排序算法</li>\n<li>也可以利用DFS遍历进行拓扑排序</li>\n</ul>\n</li>\n<li>基于DFS的拓扑排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topodfs</span> <span class=\"params\">( v )</span> </span>&#123;   </span><br><span class=\"line\">    Push( v ,S ) ; </span><br><span class=\"line\">    mark[v]=True; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( L[v] 中的每一个顶点w) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( mark[w] = False ) topodfs ( w ) ; </span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( Top( S ) ) ; </span><br><span class=\"line\">    Pop ( S ) ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span>  dfs-topo ( GRAPH  L ) &#123;  </span><br><span class=\"line\">    MakeNull( S ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n; u++) </span><br><span class=\"line\">        mark[u]=False; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n;u++) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !mark[u] ) </span><br><span class=\"line\">            topodfs( u ) ;</span><br></pre></td></tr></table></figure>\n<p>思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。</p>\n<h5 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h5><p>AOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）</p>\n<p>最大长度的路径称为关键路径。<br>一个AOE中，关键路径可能不只一条。<br>关键活动：关键路径上的活动称为关键活动。</p>\n<p>关键路径算法步骤：</p>\n<p>（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}<br>其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）</p>\n<p>（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }<br>其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S</p>\n<p>（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 </p>\n<p>（４）若某条边满足E( i ) = L( i )，则它是关键活动。</p>\n<p>注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。</p>\n<h5 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h5><ul>\n<li>边上权值非负情形的单源最短路径问题 — Dijkstra算法 </li>\n</ul>\n<p>Dijkstra算法实现步骤：</p>\n<ol>\n<li>将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。</li>\n<li>从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。</li>\n<li>调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 </li>\n<li>重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">costtype <span class=\"title\">MinCost</span> <span class=\"params\">(D, S)</span> </span>&#123; </span><br><span class=\"line\">\ttemp = INFINITY ; w = <span class=\"number\">2</span> ;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n ; i++ )</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!S[i]&amp;&amp;D[i]&lt;temp)  &#123;</span><br><span class=\"line\">  \t\t\ttemp = D[i] ; w = i ; &#125; </span><br><span class=\"line\">\t<span class=\"keyword\">return</span>  w ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">Dijkstra</span><span class=\"params\">(GRAPH  C, costtype D[n+<span class=\"number\">1</span>] ，<span class=\"keyword\">int</span> P[n+<span class=\"number\">1</span>]，<span class=\"keyword\">bool</span> S[n+<span class=\"number\">1</span>])</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n; i++ ) &#123;  </span><br><span class=\"line\">\tD[i]=C[<span class=\"number\">1</span>][i] ; S[i]=False ;P[i]=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">\tS [<span class=\"number\">1</span>]= True ; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( i=<span class=\"number\">1</span>; i&lt;=n<span class=\"number\">-1</span>; i++) &#123;  </span><br><span class=\"line\">\t\tw=MinCost ( D, S ) ; S[w]=True ; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( v=<span class=\"number\">2</span> ; v&lt;= n ; n++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( S[v]!=True ) &#123;  </span><br><span class=\"line\">        \t        sum=D[w] + C[w][v] ;</span><br><span class=\"line\"> \t\t\t<span class=\"keyword\">if</span> (sum &lt; D[v】 )&#123;D[v] = sum ; P[v]=w;&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;<span class=\"comment\">//   时间复杂度：O（n^2）</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有顶点之间的最短路径问题 — Floyd算法 </li>\n</ul>\n<p>基本思想：动态规划</p>\n<p>求解过程：</p>\n<p>设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i —&gt; j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞</p>\n<p> 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] </p>\n<p>2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Floyd</span><span class=\"params\">( costtype A[][], costtype C[][], <span class=\"keyword\">int</span> P[][], <span class=\"keyword\">int</span> n)</span> </span>&#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ )</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j&lt; n; j++ ) &#123;</span><br><span class=\"line\">\t\t\tA[i][j] = C[i][j];  P[i][j] = <span class=\"number\">-1</span>； &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( k = <span class=\"number\">0</span>; k &lt; n; k++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ ) </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; n; j++ )</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ( A[i][k] + A[k][j] &lt; A[i][j] )&#123; </span><br><span class=\"line\">                \tA[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">&#125; <span class=\"comment\">/* 时间复杂度：O(n3) */</span></span><br><span class=\"line\">Warshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]);</span><br><span class=\"line\">可以判定有向图任意两点间是否存在有向 路。</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><h5 id=\"线性查找\"><a href=\"#线性查找\" class=\"headerlink\" title=\"线性查找\"></a>线性查找</h5><p>插入和删除：从后往前</p>\n<p>第0个元素做为伪记录或哨兵 </p>\n<h5 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h5><p>折半查找只适合于静态查找</p>\n<ul>\n<li><p>数组：时间复杂度O(logn)</p>\n</li>\n<li><p>判定树:</p>\n</li>\n</ul>\n<p>高度： (n+1)/nlog2(n+1)-1</p>\n<p>当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近</p>\n<h5 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h5><p>基本思想：均匀分块，块间有序，块内无序</p>\n<p>索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.</p>\n<p>块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j </p>\n<p>所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。</p>\n<h5 id=\"BST-二叉查找树\"><a href=\"#BST-二叉查找树\" class=\"headerlink\" title=\"BST-二叉查找树\"></a>BST-二叉查找树</h5><ul>\n<li><p>插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. </p>\n</li>\n<li><p>删除：</p>\n</li>\n</ul>\n<ol>\n<li>若结点p是叶子，则直接删除结点p； </li>\n<li>若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； </li>\n<li>若结点p的左右子树均不空，则<br> 3.1 查找结点p的右子树上的最左下结点s及其双亲结点par；<br> 3.2 将结点s数据域替换到被删结点p的数据域；<br> 3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上；<br> 3.4 删除结点s；</li>\n</ol>\n<ul>\n<li>性能：</li>\n</ul>\n<p>二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。</p>\n<p> 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。</p>\n<p> 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) </p>\n<p>就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。</p>\n<h5 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h5><p>AVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。<br>令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。<br>因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）<br>Fh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1<br>所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2<br>因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)</p>\n<h5 id=\"B-树和B-树\"><a href=\"#B-树和B-树\" class=\"headerlink\" title=\"B-树和B+树\"></a>B-树和B+树</h5><ul>\n<li><p>B-树</p>\n<ul>\n<li><p>树中可容纳结点数量最大值，关键字个数最多：m^h-1</p>\n</li>\n<li><p>树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；</p>\n</li>\n<li><p>除根结点和失败结点外，所有结点至少有 m/2 棵子树； </p>\n</li>\n<li><p>所有的终端结点和叶子结点（失败结点）都位于同一层。</p>\n</li>\n<li><p>h 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)</p>\n</li>\n<li><p>关键字个数N：N +1 = 位于第 h+1 层的结点数 &gt;= 2 *(m / 2)^ (h -1)</p>\n</li>\n<li><p>N+1&gt;= 2 *(m / 2)^ (h -1)  ;    h-1 &lt;= log(m / 2)(( N + 1 ) / 2 ) </p>\n</li>\n</ul>\n</li>\n<li><p>B+树</p>\n<ul>\n<li><p>(1) 有k个子结点的结点必然有k个关键字；</p>\n</li>\n<li><p>(2) 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。<br>3阶B+树</p>\n</li>\n<li><p>(3) 所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。<br>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>\n</li>\n<li><p>(4) 可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h5><p>不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词</p>\n<p>散列函数的构造的原则： 计算简单、分布均匀</p>\n<ul>\n<li><p>构造方法：<br>直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、</p>\n</li>\n<li><p>冲突处理：</p>\n</li>\n</ul>\n<p>1、开放定址法：<br>–线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               –线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…）<br>–二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2）<br>–随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） </p>\n<p>2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高</p>\n<p>3、拉链法\\链地址法：</p>\n<h4 id=\"内部排序\"><a href=\"#内部排序\" class=\"headerlink\" title=\"内部排序\"></a>内部排序</h4><h5 id=\"气泡排序\"><a href=\"#气泡排序\" class=\"headerlink\" title=\"气泡排序\"></a>气泡排序</h5><p>最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； </p>\n<p>最坏情况（反序）： 比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2         时间复杂度： O(n^2)</p>\n<p>平均情况：时间复杂度为O(n^2)  </p>\n<p>空间复杂度： O(1)</p>\n<h5 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h5><p>对气泡排序的改进</p>\n<p>最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)</p>\n<p>最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)</p>\n<p>平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)</p>\n<h5 id=\"直接选择排序\"><a href=\"#直接选择排序\" class=\"headerlink\" title=\"直接选择排序\"></a>直接选择排序</h5><p>移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次</p>\n<p>比较次数：n(n-1)/2</p>\n<p>时间复杂度为O(n^2)</p>\n<p> 空间复杂度为O(1)</p>\n<h5 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h5><p>对直接选择排序的改进</p>\n<p>首先将待排序的记录序列用完全二叉树表示；<br>然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；<br>最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。</p>\n<p>堆排序：令i = n, n-1 ,…, 2 </p>\n<p>1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])；<br>2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)；<br>3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(1)</p>\n<h5 id=\"（直接）插入排序\"><a href=\"#（直接）插入排序\" class=\"headerlink\" title=\"（直接）插入排序\"></a>（直接）插入排序</h5><p>最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)</p>\n<p>最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)</p>\n<p>最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)</p>\n<h5 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h5><p>对直接插入排序的改进</p>\n<p>时间性能：在O(n^2)和O(nlog2n)之间。</p>\n<p>当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) </p>\n<h5 id=\"二路-归并排序\"><a href=\"#二路-归并排序\" class=\"headerlink\" title=\"(二路)归并排序\"></a>(二路)归并排序</h5><p>基本思想：自底向上的非递归算法</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(n)</p>\n<h5 id=\"基数排序–多关键字排序\"><a href=\"#基数排序–多关键字排序\" class=\"headerlink\" title=\"基数排序–多关键字排序\"></a>基数排序–多关键字排序</h5><p>次序：从最低位排序，使用了队列</p>\n<p>改进：桶—-链式排队</p>\n<p>时间复杂度：O(d(n+r))    （n—记录数，d—-关键字(分量)个数，r—-基数）</p>\n<p>空间复杂度：O((n+r)) </p>\n<h5 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h5><p>数组记录对应关键字出现的最后一个位置</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>快排</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n^2)</td>\n<td>O(log2n)~O(n)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>直接选择</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(1)</td>\n<td>否/1,2,2(最小堆)</td>\n</tr>\n<tr>\n<td>直接插入</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(nlog2n)</td>\n<td>O(n^1.3)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/3,2,2(d=2/1)</td>\n</tr>\n<tr>\n<td>二路归并</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(n+r)</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p>最坏：</p>\n<p> 气泡排序：比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2  </p>\n<p>选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   </p>\n<p>插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)</p>\n<h4 id=\"外排序\"><a href=\"#外排序\" class=\"headerlink\" title=\"外排序\"></a>外排序</h4><h5 id=\"磁盘文件的归并排序\"><a href=\"#磁盘文件的归并排序\" class=\"headerlink\" title=\"磁盘文件的归并排序\"></a>磁盘文件的归并排序</h5><p>方法：多路归并 、 I/O并行处理  、生成初始归并段</p>\n<ul>\n<li>磁盘文件的归并排序</li>\n</ul>\n<p>第一阶段：初始归并段形成 </p>\n<p>第二阶段：多路归并 </p>\n<ul>\n<li>多路归并-减少归并遍数</li>\n</ul>\n<p>一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。</p>\n<p>在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）<em>(K-1)</em>[logkm]=（n-1）<em>(K-1) </em>[log2(m/log2K)]</p>\n<ul>\n<li><p>K 路平衡归并与选择树</p>\n<ul>\n<li><p>第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) </p>\n</li>\n<li><p>而后每次重新建造选择树所需时间为： O( log2k ) </p>\n</li>\n<li><p>n 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间:</p>\n</li>\n</ul>\n<p>​      O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 </p>\n<ul>\n<li>归并遍数为 logkm，总时间为:O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )</li>\n</ul>\n</li>\n<li><p>并行操作的缓冲区处理</p>\n<p>​                    ——-使输入、输出和CPU处理尽可能重叠</p>\n</li>\n</ul>\n<p>对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作</p>\n<ul>\n<li>生成初始归并段（使用选择树法）：多路平衡归并</li>\n</ul>\n<p>假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：<br>(1) 从FI输入P个记录到缓冲区W;<br>(2)从W中选择出关键字最小的记录MIN；<br>(3)将MIN记录输出到FO中去；<br>(4)若FI不空，则从FI输入下一个记录到W;<br>(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN;<br>(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中<br>(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段</p>\n<p>生成的初始归并段的平均长度是缓冲区长度的两倍</p>\n<p>最佳归并树：使外存读写次数最少，是一棵正则树</p>\n<p>对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1</p>\n<p>加入细节点：</p>\n<ul>\n<li>已知前序和后序不能确定唯一二叉树</li>\n<li>//判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号</li>\n<li><p>树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树</p>\n</li>\n<li><p>解决冲突的方法：线性再散列、内散列表、外散列表</p>\n</li>\n<li><p>左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针</p>\n</li>\n<li><p>折半查找树高度： (n+1)/nlog2(n+1)-1</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjvrtri0k0001tku367wzpsxo","category_id":"cjvrtri0y0005tku3rjm3roz2","_id":"cjvrtri18000btku3ryuzda7z"},{"post_id":"cjvrtri0s0003tku31yen1jd0","category_id":"cjvrtri160009tku3gspipji1","_id":"cjvrtri1a000ftku3zlrmctaw"},{"post_id":"cjvrtri51000ntku3tr59dadz","category_id":"cjvrtri54000ptku3zumq0zus","_id":"cjvrtri5d000xtku378cbvy6h"},{"post_id":"cjvrtri52000otku3527ansj7","category_id":"cjvrtri54000ptku3zumq0zus","_id":"cjvrtri5f0010tku3ikm0y3fc"},{"post_id":"cjvrtri55000rtku3jrhl2h8q","category_id":"cjvrtri5d000wtku37pexbdnt","_id":"cjvrtri5g0014tku386ggjk0c"},{"post_id":"cjvrtri57000stku3o5h3n120","category_id":"cjvrtri5f0012tku32jo0psky","_id":"cjvrtri5j0019tku3gbc1t06k"},{"post_id":"cjvrtri59000ttku3f0s35heu","category_id":"cjvrtri5d000wtku37pexbdnt","_id":"cjvrtri5k001ctku33zz5952b"},{"post_id":"cjvrtri8o001itku3fe6o3a51","category_id":"cjvrtri8q001jtku3aoybpsfz","_id":"cjvrtri8t001ntku31ridx6uy"}],"PostTag":[{"post_id":"cjvrtri0k0001tku367wzpsxo","tag_id":"cjvrtri110006tku3e42uwd76","_id":"cjvrtri19000dtku33y9k6n3n"},{"post_id":"cjvrtri0k0001tku367wzpsxo","tag_id":"cjvrtri16000atku3p24v1fyc","_id":"cjvrtri1a000etku38wx35go3"},{"post_id":"cjvrtri0s0003tku31yen1jd0","tag_id":"cjvrtri18000ctku36gxfu91i","_id":"cjvrtri1g000jtku33gqvwpiz"},{"post_id":"cjvrtri0s0003tku31yen1jd0","tag_id":"cjvrtri1a000gtku389jrpaeh","_id":"cjvrtri1g000ktku3z3n4x6yt"},{"post_id":"cjvrtri0s0003tku31yen1jd0","tag_id":"cjvrtri1b000htku3nte7hkb0","_id":"cjvrtri1h000ltku3ji70x8zt"},{"post_id":"cjvrtri0s0003tku31yen1jd0","tag_id":"cjvrtri1e000itku3wppzy5wv","_id":"cjvrtri1h000mtku3feq3has0"},{"post_id":"cjvrtri51000ntku3tr59dadz","tag_id":"cjvrtri55000qtku3kmkmy35o","_id":"cjvrtri5e000ztku3qt7n1qow"},{"post_id":"cjvrtri51000ntku3tr59dadz","tag_id":"cjvrtri5a000vtku3ukge03bq","_id":"cjvrtri5f0011tku3oz8aca7e"},{"post_id":"cjvrtri52000otku3527ansj7","tag_id":"cjvrtri5e000ytku3bbn9twjn","_id":"cjvrtri5i0017tku31v8f9nyv"},{"post_id":"cjvrtri52000otku3527ansj7","tag_id":"cjvrtri5a000vtku3ukge03bq","_id":"cjvrtri5i0018tku3m6qnyxed"},{"post_id":"cjvrtri55000rtku3jrhl2h8q","tag_id":"cjvrtri5h0016tku30w5w1il4","_id":"cjvrtri5j001btku3osdt3g5j"},{"post_id":"cjvrtri57000stku3o5h3n120","tag_id":"cjvrtri5j001atku3d5r82ykc","_id":"cjvrtri5l001ftku33wzttlmg"},{"post_id":"cjvrtri57000stku3o5h3n120","tag_id":"cjvrtri5k001dtku3886xz7hd","_id":"cjvrtri5l001gtku38ik68spr"},{"post_id":"cjvrtri59000ttku3f0s35heu","tag_id":"cjvrtri5h0016tku30w5w1il4","_id":"cjvrtri5l001htku3q9rn6g5z"},{"post_id":"cjvrtri8o001itku3fe6o3a51","tag_id":"cjvrtri8r001ktku3qn0eclbq","_id":"cjvrtri8s001ltku32uibwz8f"},{"post_id":"cjvrtri8o001itku3fe6o3a51","tag_id":"cjvrtri5k001dtku3886xz7hd","_id":"cjvrtri8t001mtku3fd7omxt2"}],"Tag":[{"name":"LeetCode","_id":"cjvrtri110006tku3e42uwd76"},{"name":"Two sum","_id":"cjvrtri16000atku3p24v1fyc"},{"name":"算法","_id":"cjvrtri18000ctku36gxfu91i"},{"name":"矩阵连乘","_id":"cjvrtri1a000gtku389jrpaeh"},{"name":"动态规划","_id":"cjvrtri1b000htku3nte7hkb0"},{"name":"贪心","_id":"cjvrtri1e000itku3wppzy5wv"},{"name":"Struts2","_id":"cjvrtri55000qtku3kmkmy35o"},{"name":"javaEE framework","_id":"cjvrtri5a000vtku3ukge03bq"},{"name":"hibernate","_id":"cjvrtri5e000ytku3bbn9twjn"},{"name":"软件构造","_id":"cjvrtri5h0016tku30w5w1il4"},{"name":"计算机系统","_id":"cjvrtri5j001atku3d5r82ykc"},{"name":"期末复习","_id":"cjvrtri5k001dtku3886xz7hd"},{"name":"数据结构","_id":"cjvrtri8r001ktku3qn0eclbq"}]}}