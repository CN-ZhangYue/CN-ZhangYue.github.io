{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/ds/双循环2.PNG","path":"img/ds/双循环2.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/图的深度优先搜索.PNG","path":"img/ds/图的深度优先搜索.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/游标逆置.PNG","path":"img/ds/游标逆置.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/磁盘读取时间计算.PNG","path":"img/深入理解计算机系统/磁盘读取时间计算.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/img/ds/Kruskal算法.PNG","path":"img/ds/Kruskal算法.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/Prim算法.PNG","path":"img/ds/Prim算法.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/中序非.PNG","path":"img/ds/中序非.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/二叉树先序遍历.PNG","path":"img/ds/二叉树先序遍历.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/先序.PNG","path":"img/ds/先序.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/先序建立.PNG","path":"img/ds/先序建立.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/先序非.PNG","path":"img/ds/先序非.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/内外路径.PNG","path":"img/ds/内外路径.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/双向单链表.PNG","path":"img/ds/双向单链表.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/双循环1.PNG","path":"img/ds/双循环1.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/后序非.PNG","path":"img/ds/后序非.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/哈夫曼树性质1.PNG","path":"img/ds/哈夫曼树性质1.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/图-拓扑排序.PNG","path":"img/ds/图-拓扑排序.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/图的存储结构.PNG","path":"img/ds/图的存储结构.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/层序遍历.PNG","path":"img/ds/层序遍历.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/已知先序中序构二叉树.PNG","path":"img/ds/已知先序中序构二叉树.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/建立1.PNG","path":"img/ds/建立1.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/快排.PNG","path":"img/ds/快排.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/气泡排序.PNG","path":"img/ds/气泡排序.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/码长计算.PNG","path":"img/ds/码长计算.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/选择排序.PNG","path":"img/ds/选择排序.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/SRAM和DRAM对比.PNG","path":"img/深入理解计算机系统/SRAM和DRAM对比.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/信号处理程序被中断.PNG","path":"img/深入理解计算机系统/信号处理程序被中断.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/存储器层次结构.PNG","path":"img/深入理解计算机系统/存储器层次结构.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/浮点数舍入.PNG","path":"img/深入理解计算机系统/浮点数舍入.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/二叉树前序遍历.PNG","path":"img/ds/二叉树前序遍历.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/二叉树层序遍历.PNG","path":"img/ds/二叉树层序遍历.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/二叉树遍历.PNG","path":"img/ds/二叉树遍历.PNG","modified":1,"renderable":0},{"_id":"source/img/ds/建立非.PNG","path":"img/ds/建立非.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/8.1事件处理.PNG","path":"img/深入理解计算机系统/8.1事件处理.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/set指令.PNG","path":"img/深入理解计算机系统/set指令.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/异常分类.PNG","path":"img/深入理解计算机系统/异常分类.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/异常分类2.PNG","path":"img/深入理解计算机系统/异常分类2.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/栈结构.PNG","path":"img/深入理解计算机系统/栈结构.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/next-boot.js","path":"js/src/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/img/深入理解计算机系统/6.1.1内存地址取值.PNG","path":"img/深入理解计算机系统/6.1.1内存地址取值.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/特殊的操作指令.PNG","path":"img/深入理解计算机系统/特殊的操作指令.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/算术和逻辑操作指令.PNG","path":"img/深入理解计算机系统/算术和逻辑操作指令.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"source/img/ds/后缀表达式计算.PNG","path":"img/ds/后缀表达式计算.PNG","modified":1,"renderable":0},{"_id":"source/img/深入理解计算机系统/浮点数标准分类.PNG","path":"img/深入理解计算机系统/浮点数标准分类.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/schemes/muse.js","path":"js/src/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"source/img/深入理解计算机系统/浮点数规格化的值.PNG","path":"img/深入理解计算机系统/浮点数规格化的值.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"source/img/ds/中缀转后缀表达式.PNG","path":"img/ds/中缀转后缀表达式.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"source/img/深入理解计算机系统/进程地址空间.PNG","path":"img/深入理解计算机系统/进程地址空间.PNG","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1550977740362},{"_id":"themes/next/.all-contributorsrc","hash":"6e5abe56bd8bbc5e926db941d5c9a79b42cc5049","modified":1551770992222},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1551770992222},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1551770992222},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1551770992222},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1551770992222},{"_id":"themes/next/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1551770992222},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1551770992222},{"_id":"themes/next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1551770992222},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1551770992222},{"_id":"themes/next/README.md","hash":"283621190d680b081376a1ac0997a3175f7ef054","modified":1551770992222},{"_id":"themes/next/_config.yml","hash":"deb7a86417772a51b9f747de6da51f469b91e775","modified":1551830273968},{"_id":"themes/next/bower.json","hash":"237d0a2bf89418dee4a4e9cdfef0d66dd7a1d18c","modified":1551770992237},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1551770992237},{"_id":"themes/next/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1551770992253},{"_id":"themes/next/package.json","hash":"5912233efcabf8c6d7dcd2c2036c77b6631b5677","modified":1551770992324},{"_id":"source/_posts/数据结构与算法.md","hash":"4df4223fe9a59fc0ed3d1645ff14cbb2007bfae3","modified":1551830064691},{"_id":"source/_posts/深入理解计算机系统.md","hash":"88acc7bcc26b96200c7b5981cbaa9a80a3bf17cf","modified":1551769526609},{"_id":"source/about/index.md","hash":"ed1dd1c58371cbcb24ad03414991b02fa7ae6b8d","modified":1550977740377},{"_id":"source/archives/index.md","hash":"a9f0b3e5433bcb0efff2faa5709ab44da3bfd146","modified":1550977740377},{"_id":"source/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1550977740393},{"_id":"source/tags/index.md","hash":"bc710b5b8db6f01940957ce744a37fd564752c3b","modified":1550977740393},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1551770992237},{"_id":"themes/next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1551770992237},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1551770992237},{"_id":"themes/next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1551770992237},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"721a1aa9feed1b580ab99af8e69ed22699121e88","modified":1551770992237},{"_id":"themes/next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1551770992237},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1551770992237},{"_id":"themes/next/docs/MATH.md","hash":"0540cd9c961b07931af9f38a83bc9a0f90cd5291","modified":1551770992237},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1551770992237},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1551770992253},{"_id":"themes/next/languages/de.yml","hash":"79b3221344da335743b5ef5a82efa9338d64feb0","modified":1551770992253},{"_id":"themes/next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1551770992253},{"_id":"themes/next/languages/fr.yml","hash":"0393558717065293bdf732866471cebb0c884f6a","modified":1551770992253},{"_id":"themes/next/languages/id.yml","hash":"f3302a4dfdc9be38a52d6e081411574b1ea01671","modified":1551770992253},{"_id":"themes/next/languages/it.yml","hash":"31eb878b53d60ff47e3e534cdd7a839c8801ac6e","modified":1551770992253},{"_id":"themes/next/languages/ja.yml","hash":"3f25eca504ee5a519987b4402731f1bb7f5191c9","modified":1551770992253},{"_id":"themes/next/languages/ko.yml","hash":"75f2fe142f76bf623e34ed3570598226f55f2b8b","modified":1551770992253},{"_id":"themes/next/languages/nl.yml","hash":"08f16ce395dacc88847fc30dc6b985ce22fb8948","modified":1551770992253},{"_id":"themes/next/languages/pt-BR.yml","hash":"c7de8b77f44e75be4f04423088a1c891537aa601","modified":1551770992253},{"_id":"themes/next/languages/pt.yml","hash":"ca5072c967e5eb1178ffed91827459eda6e4e6e2","modified":1551770992253},{"_id":"themes/next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1551770992253},{"_id":"themes/next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1551770992253},{"_id":"themes/next/languages/uk.yml","hash":"6320439c6e9ff81e5b8f8129ca16e9a744b37032","modified":1551770992253},{"_id":"themes/next/languages/vi.yml","hash":"e2f0dd7f020a36aa6b73ed4d00dcc4259a7e5e9d","modified":1551770992253},{"_id":"themes/next/languages/zh-CN.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1551770992253},{"_id":"themes/next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1551770992253},{"_id":"themes/next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1551770992253},{"_id":"themes/next/layout/_layout.swig","hash":"88c5567cdde8123ef202a7af469df0a2c82a9d55","modified":1551770992269},{"_id":"themes/next/layout/archive.swig","hash":"61bc56e77e653684fc834f63dcbdadf18687c748","modified":1551770992324},{"_id":"themes/next/layout/category.swig","hash":"ad0ac6a1ff341f8eab9570e7fb443962948c5f9d","modified":1551770992324},{"_id":"themes/next/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1551770992324},{"_id":"themes/next/layout/page.swig","hash":"948616c82d80246a3476cd7681aede249dcfc5cc","modified":1551770992324},{"_id":"themes/next/layout/post.swig","hash":"af74e97d57cf00cde6f8dbd4364f27910915454e","modified":1551770992324},{"_id":"themes/next/layout/schedule.swig","hash":"e79f43df0e9a6cf48bbf00882de48c5a58080247","modified":1551770992324},{"_id":"themes/next/layout/tag.swig","hash":"283519d4d5b67814412863a3e0212bac18bcc5a0","modified":1551770992324},{"_id":"themes/next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1551770992339},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1551770992339},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1551770992472},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1551770992472},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1551770992472},{"_id":"themes/next/layout/_custom/head.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551831059293},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992433},{"_id":"source/img/ds/双循环2.PNG","hash":"187e42fe43df786f10a73bd301c0f285661d93eb","modified":1540529025187},{"_id":"source/img/ds/图的深度优先搜索.PNG","hash":"10fb691ded4eeba6740cba6ffcb45fc1e6ce8ada","modified":1542944118106},{"_id":"source/img/ds/游标逆置.PNG","hash":"ddc1a22c686779aef1e2a82d7a93a10597ca02fb","modified":1540528759367},{"_id":"source/img/深入理解计算机系统/磁盘读取时间计算.PNG","hash":"961f9811f7e87f901aafbbe7dcce9540e845452f","modified":1543995794142},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1551770992237},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1551770992237},{"_id":"themes/next/docs/ru/README.md","hash":"3e191bd6b09dee33e6b8931c3bc338db3d04e479","modified":1551770992237},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"018a259694f4a8c7c384e1f323531442cba5fbf3","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"415aa36be2d985c6ebb1a30a446aaffa1b9e471b","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1551770992237},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"b17fc344ff61603f83387c0f9b2b2189aae81d50","modified":1551770992253},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"734b371a0dd910eb9fe087f50c95ce35340bb832","modified":1551770992253},{"_id":"themes/next/docs/zh-CN/README.md","hash":"fe4bfa69bcb16a777d5c5ab5d2b617bff548d6a0","modified":1551770992253},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1551770992253},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1551770992269},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1551770992269},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"891ab67815969dd8736cb22fbbb3f791b8fff4e4","modified":1551770992269},{"_id":"themes/next/layout/_macro/post.swig","hash":"e4123aa3e79012cc4e615e9de55de7612d01e8d5","modified":1551770992269},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b9054a508190ce85560b0dc0578b26f84f6112fc","modified":1551770992269},{"_id":"themes/next/layout/_partials/comments.swig","hash":"54afb7b78509ed8fac5d23daecc147b0fe615d1d","modified":1551770992277},{"_id":"themes/next/layout/_partials/footer.swig","hash":"6d56acdcdc12ebca9c1d90f8a2b52ad17aafca6e","modified":1551770992277},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"94c5d55df7121d73ee0340beac85b9c7c103a3e2","modified":1551770992277},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1551770992277},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"dee345054d564dd56f74bb143942d3edd1cb8150","modified":1551770992277},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"c31d54154eed347f603009d2d65f7bf8d9a6885a","modified":1551770992292},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"28b1cd4c065fcd214a1d6dd06f54bb62c3519aad","modified":1551770992292},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"efb3404a3303622f3be60944d9d1926972c5c248","modified":1551770992292},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"68ad21aef6481d014e7ec0b674e469f2f82ea231","modified":1551770992292},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"87bcb495f7ddd81cc3fe2c2a886e51c08053019b","modified":1551770992308},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"4b93dc7ac0573c402aabcb5c933bbcb893b07c51","modified":1551770992308},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"6b1bd41f6654b5d6577b60859156544a3ca1c037","modified":1551770992308},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"9e00cb9b3fdfe2e2c4877a874d0d3ecb7fd0f3ee","modified":1551770992308},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"7db4ad4a8dd5420dad2f6890f5299945df0af970","modified":1551770992324},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"76f5933925670044ec65b454295ba7e0a8439986","modified":1551770992324},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"d66dec72ea7ad5026260914e3545551645e0ab37","modified":1551770992324},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"c476dc3693a9dd0be2d136a45b0d7fdef55d4d92","modified":1551770992324},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"882cd0b68c493af1b6d945660f9c21085e006ffc","modified":1551770992324},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"f58463133bf8cfef5ff07f686b834ff8cbbe492f","modified":1551770992324},{"_id":"themes/next/scripts/filters/exturl.js","hash":"b19c7c1021e57367b3b3bbf5678381017ed5667d","modified":1551770992324},{"_id":"themes/next/scripts/helpers/engine.js","hash":"cdb6152582313268d970ffeef99b4a8a7850f034","modified":1551770992339},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a40ce6bc852bb4bff8b9f984fa064741dd151e96","modified":1551770992339},{"_id":"themes/next/scripts/tags/button.js","hash":"6ef342a0c4b58000ba11148b4c9b2b599edd86b5","modified":1551770992339},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1551770992339},{"_id":"themes/next/scripts/tags/exturl.js","hash":"e9dab948e6327b22b4fc0c66cf97f6600a444dd5","modified":1551770992339},{"_id":"themes/next/scripts/tags/full-image.js","hash":"755b0d518352ec27354124105b48e302ac84d66f","modified":1551770992339},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"03575b534303f42c81ba6187ec601a5578913a39","modified":1551770992339},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1551770992339},{"_id":"themes/next/scripts/tags/label.js","hash":"4cee94f53fdecc7f9c2d91c06ab9e7a433b5ec5a","modified":1551770992339},{"_id":"themes/next/scripts/tags/note.js","hash":"f1b560d6e63d1b06fd80e12bbac32660125c223c","modified":1551770992339},{"_id":"themes/next/scripts/tags/tabs.js","hash":"ca885c8fa46a76a7b8977730575551622497410b","modified":1551770992339},{"_id":"themes/next/source/css/main.styl","hash":"5e7d28bc539e84f8b03e68df82292f7fc0f2d023","modified":1551770992433},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1551770992433},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1551770992433},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1551770992433},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1551770992433},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1551770992433},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1551770992433},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1551770992433},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1551770992433},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551770992433},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1551770992433},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551770992433},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1551770992433},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1551770992433},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551770992433},{"_id":"source/img/ds/Kruskal算法.PNG","hash":"af952ae7b5eedb0ef9870187c07699c2a1030c8a","modified":1544274324945},{"_id":"source/img/ds/Prim算法.PNG","hash":"be94bc823a83c8e303c354d99a1efb8e697794dc","modified":1544274104434},{"_id":"source/img/ds/中序非.PNG","hash":"f4a64d93be2dfe621814bf218b92ae7b59bd0f48","modified":1542727203153},{"_id":"source/img/ds/二叉树先序遍历.PNG","hash":"d37a44517aeba46c6c6861b7c75f9816c2a92224","modified":1541733208474},{"_id":"source/img/ds/先序.PNG","hash":"9f1acdcc4e1a8c69d65878fd63a4e5f261cdd335","modified":1542727266841},{"_id":"source/img/ds/先序建立.PNG","hash":"db013c0c6400060a369807c629089ae71f556124","modified":1542727367605},{"_id":"source/img/ds/先序非.PNG","hash":"50795b62f8f0da112fc9edbdd30e09960f4ad66a","modified":1542727234109},{"_id":"source/img/ds/内外路径.PNG","hash":"3fb9280189a7c44e8bd4f11f35d9281c43a26dac","modified":1542760787817},{"_id":"source/img/ds/双向单链表.PNG","hash":"2627c45a03d4e2971fc31284ab370323a714404e","modified":1540528875638},{"_id":"source/img/ds/双循环1.PNG","hash":"55f20c9bc6e5e15b2ce822351202761c33b0795f","modified":1540528988641},{"_id":"source/img/ds/后序非.PNG","hash":"fc6cb567d2c8d21d4b32f4e22eea6210e7850003","modified":1542727172422},{"_id":"source/img/ds/哈夫曼树性质1.PNG","hash":"6b32cedbc27e6b25aa96e565ea86cf13a20112b9","modified":1542760851790},{"_id":"source/img/ds/图-拓扑排序.PNG","hash":"ab5fb0e83412bfb9f156f2e61c3e7b1f2ba2c96c","modified":1544430371906},{"_id":"source/img/ds/图的存储结构.PNG","hash":"6fe99c2bf6dd0a9d7c23f3435e554fa2ab45f650","modified":1542941116975},{"_id":"source/img/ds/层序遍历.PNG","hash":"1c533cab4fd6d5dae1c4d35c8aee0a76a0ba4a08","modified":1542727124893},{"_id":"source/img/ds/已知先序中序构二叉树.PNG","hash":"edda52d2e9fd5cbfcc5338586051f34d45cc49b9","modified":1545919163880},{"_id":"source/img/ds/建立1.PNG","hash":"db63c8bb50e7f147977d0044978f199ecef13351","modified":1542727333155},{"_id":"source/img/ds/快排.PNG","hash":"bd9e6f350f1a9d54c49851e9838ebf27c2252a16","modified":1545052213319},{"_id":"source/img/ds/气泡排序.PNG","hash":"755f231b1473eed0cae3a7d0ab1b15e5245020ed","modified":1545052114867},{"_id":"source/img/ds/码长计算.PNG","hash":"a870d3bafb94447cd7adac4ccaf3b416d13abe84","modified":1542760928530},{"_id":"source/img/ds/选择排序.PNG","hash":"4791878c4a59e96aafe114b5969e7ebb21826475","modified":1545058832477},{"_id":"source/img/深入理解计算机系统/SRAM和DRAM对比.PNG","hash":"fbdc048b712161a07712459483ca38cc2d0cbcae","modified":1543458967149},{"_id":"source/img/深入理解计算机系统/信号处理程序被中断.PNG","hash":"b8d5716226f64a220914c48a75e5397c367bd132","modified":1544796644232},{"_id":"source/img/深入理解计算机系统/存储器层次结构.PNG","hash":"dfff26cbcc2184c78b506f59374087189b4144a4","modified":1543491686499},{"_id":"source/img/深入理解计算机系统/浮点数舍入.PNG","hash":"ab6db20e3b3859e17aaad66d7d01204447143611","modified":1542790108412},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992402},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992417},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551770992433},{"_id":"source/img/ds/二叉树前序遍历.PNG","hash":"ed70c869cbf9ee1749f8c182a390b28393cfc5ab","modified":1541733158786},{"_id":"source/img/ds/二叉树层序遍历.PNG","hash":"90e288b9c351d6595eb638fcfa232a79d54f3678","modified":1541734376595},{"_id":"source/img/ds/二叉树遍历.PNG","hash":"516ffc9912d2ba54614307d9b094915a73982d80","modified":1541733776325},{"_id":"source/img/ds/建立非.PNG","hash":"04dc5c76eb5d8fa6b8932f21bd432e0e74263267","modified":1542727402059},{"_id":"source/img/深入理解计算机系统/8.1事件处理.PNG","hash":"384ecfbc47d70a1e765ac06b6746a96125848f30","modified":1543457671156},{"_id":"source/img/深入理解计算机系统/set指令.PNG","hash":"82acf2ebbb9ac4ded80acf235c68354ba2ef0669","modified":1543234265561},{"_id":"source/img/深入理解计算机系统/异常分类.PNG","hash":"5df9edc777b72d4d5ceee6214a4411452ea05cdf","modified":1544704475537},{"_id":"source/img/深入理解计算机系统/异常分类2.PNG","hash":"b2f6a60a908b8170e54dee16169f4cf39130b108","modified":1544704555191},{"_id":"source/img/深入理解计算机系统/栈结构.PNG","hash":"0b93110b8e601d16eba62cbe7a248830b0293916","modified":1543317822864},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1551770992269},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"25aea3d764b952f3f6d28ab86d7212d138e892df","modified":1551770992269},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"b57bf9c865bed0f22157176a8085de168a1aef77","modified":1551770992277},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"187316a1d565f98eac138b5ce2180b52a190028c","modified":1551770992277},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"4b53a0659a7e800871d8e9a4bd20f7b892a8e29b","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"03f669356bbaa70144b743f3312178e1981ac3a8","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"39c4ad0e36b7c1260da98ba345f7bd72a2ac0f2e","modified":1551770992277},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"e015c7d9b84062b60b15b36be3ef11929dd10943","modified":1551770992277},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"daa6e5b7dbc409d6bf8a031d5413d8229e9c0995","modified":1551770992277},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"f46699a9daa5fef599733cbab35cb75cf7a05444","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"be6683db6a269d83bb0441d7cf74db63a240fa8a","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f331ad02beea8990066d32ad6ec9f859672c3615","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"fc69f1f3950d9b81b0d474735e512053be169e8e","modified":1551770992277},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"fb7727e8ec63a58238a7206bf70eb273c8879993","modified":1551770992277},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1551770992277},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"f14e9e8c27af82f1bfe794e252dec0d7e521f503","modified":1551770992277},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1551770992292},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"31245e09ce0465b994cebd94223a531585c4eab4","modified":1551770992292},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c609097b95eb6127c2784f47f2230e6e6efc0be2","modified":1551770992292},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"54b43d406cf37932e7b60f46814e864d31b1842c","modified":1551770992292},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"e0f0a753d4920ffb37ddbc8270515654a0b9b92a","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a62c93f19429f159bcf0c2e533ffc619aa399755","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"3c548934b97cc426544947f7a2ae35c270b5e33f","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"84018384d00e4a584d613589adae6674a3060a36","modified":1551770992292},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"23c6d15aa2a305f9d29caee1b60cfae84d32fa09","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"66d562b3778dbc839f7c00103bd0099c5d61602a","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"83dd7df11b100bae38c9faab9a478f92149a0315","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"73576c9683d9ad9b124916dc6c660607fe7cc1fa","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"2e1de38f44af00209129d4051b7ae307cb11ad68","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"335005a9f8b36349f0ad0a7beeba6969c55fc7f7","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"53202062267391353d49f269e7eb74eb87d30921","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1551770992292},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"453df3add0e0531950b5ae5b0e09c6b890daf9ee","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"623e73bedef067ac24a398ef27c8197295da872d","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"39928f358dd13d9fc1a4641800e57be157ecd815","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"71fb01bcad43bc9410ab19190373b9f7e59215b5","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"d18c87d7839e7407e39acd2998bcc9e0b34611b0","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"a22d1ea29a5ffe46199ab7d108a291a05af8d5b6","modified":1551770992308},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"4cff8bf5c42c62f7f0ac1f0d70f839dae39ba77a","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"bc3fc9d053b3d1fc0cd3918bf9a629a6f38f6414","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"d685df1516cb138d7a83bac5d7878a1e0fa8bc04","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"4e86e1ace90a70bb8862f5e6de9dbe7bfc046bee","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"0149e803ed7d30163df3b3ba3f578e5584a2e4af","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"bd529bf26f28745eb8ded3be7652d33d55fec8d4","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"1a5d94f5779a2ce13abc886dd78e0617f89c34b9","modified":1551770992308},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"bd6d763c1233cd89512c323ce0992daf7f9fd0e5","modified":1551770992308},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"43a20fa0e9ae2f4254f04813f9c619dd36b49ae5","modified":1551770992308},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"ea1c136f960667a0a13b334db497b9b19c41f629","modified":1551770992308},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"2cbc7a4df451b52da9552aafc0745de17c24c9a4","modified":1551770992308},{"_id":"themes/next/layout/_third-party/quicklink/index.swig","hash":"9297195791600394b1c16234b04498f50a3ad985","modified":1551770992324},{"_id":"themes/next/layout/_third-party/quicklink/quicklink.swig","hash":"58e1abe7b9a4c0260a9a3535540a8f4d0d4ff46f","modified":1551770992324},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"078bd2d5815eb23e8c5f74467dc0042babea00ae","modified":1551770992324},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"89e41d4c298d8d70b4d1c833c7e599d089f2b3d4","modified":1551770992324},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"d45ca53af17d1d83fd27f8ed0917a72f0060e1a9","modified":1551770992324},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1551770992402},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"d1deb849e697cfb6258b8ab7bfb47e219210ccd9","modified":1551770992402},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e9b0752f08398709e787546a246baca12b4c557f","modified":1551770992417},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1551770992417},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"da7049f3d9a157abe0ecc62611edcf43605ba84d","modified":1551770992417},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e37aab667be94576f6145b61a78cfe87836c68b6","modified":1551770992433},{"_id":"themes/next/source/js/src/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1551770992449},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1551770992449},{"_id":"themes/next/source/js/src/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1551770992449},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1551770992449},{"_id":"themes/next/source/js/src/motion.js","hash":"e70f961d24e4e61a2df5bf640ab51acee8f1ffbd","modified":1551770992449},{"_id":"themes/next/source/js/src/next-boot.js","hash":"c7e2a588b679d46379124141bb2f30bc2f3210e2","modified":1551770992449},{"_id":"themes/next/source/js/src/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1551770992449},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1551770992457},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1551770992457},{"_id":"themes/next/source/js/src/utils.js","hash":"a6efa988f4f3e16fb55e2f5a2e8e9e7612b3da3b","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1551770992457},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1551770992472},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1551770992472},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1551770992472},{"_id":"source/img/深入理解计算机系统/6.1.1内存地址取值.PNG","hash":"6fc29016b4f6f86b01d9717c300f00929ed0df7e","modified":1543461895135},{"_id":"source/img/深入理解计算机系统/特殊的操作指令.PNG","hash":"1d30c2d6a99fc945477d7413889bca5d266097aa","modified":1542876954972},{"_id":"source/img/深入理解计算机系统/算术和逻辑操作指令.PNG","hash":"b19cae0bbf9131b8bf610609dfc8dc2708406aec","modified":1542874851207},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1551770992472},{"_id":"source/img/ds/后缀表达式计算.PNG","hash":"ac3ff76073e917e686e35d7c75f160204bc67159","modified":1545797356420},{"_id":"source/img/深入理解计算机系统/浮点数标准分类.PNG","hash":"4e3bf7d66d2fc81f0a3c19a24e5d92b8e0221fda","modified":1542786790327},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"1a4ac0d119f2126ef8951897338706edce112235","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"bbb788b453236e5b4af7c81df8efcfc6bde08903","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1551770992339},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"c97c819a65f6967485184399397601e5133deda6","modified":1551770992386},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"c0e8647244e1ef106e94c3c8ac4a64bca2677159","modified":1551770992386},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"cb2c0beb69bfc56c0ed86e609bc1c35edb799b99","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"33a74fcd6c38cea356f6d2994a19f46dcfd5d8a4","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1551770992402},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"c4bfce1fca9ea5d0fd991d98e08b8e771d33d731","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"5f1e5d7b9d44ef3e6ad442e083753fee76d3b112","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"eecb2081ee1eef1e2152c7fea9310366e33b1eac","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"a80782a6eb3b40da2e14251da49069aff3115d8a","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"06d9d00257abd28414ec0b746f866bf9911cf5ec","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"9f35b95beb344f4eeca5ca584fbe7206f791372e","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"15254414a52f05618c54a2ac7f4635f99077ec30","modified":1551770992402},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"157e6915dcf5990566e463acffa71043b2651c07","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4ed12bf17eeb7cd4f22dd01fdd486cda68d169a8","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"9f35b95beb344f4eeca5ca584fbe7206f791372e","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"30d61fa31e405fcfe3d2ff6174ccad60be1745f9","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"28f0444ccdc85a34ada651d8ee52479e16311167","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"11fcaaf7524445a194801e1048ea2fb84b316414","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"a5395766dfdda81285d0cd3ddebe8e8bc924fa2a","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0d6f0df798449b710e1e5dbd43d470089b2a3c95","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1551770992417},{"_id":"themes/next/source/js/src/schemes/muse.js","hash":"ccc0c5cd4ec6f8159c98990ad83f11a5c0b0234c","modified":1551770992449},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"3eea56cc9ce47bb4760930c4c69cebf847a7fbb2","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1551770992457},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1551770992457},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1551770992472},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1551770992472},{"_id":"source/img/深入理解计算机系统/浮点数规格化的值.PNG","hash":"ab71d12d791a4aaec0423dcf31e0a6d728a95c01","modified":1542786985841},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551770992457},{"_id":"source/img/ds/中缀转后缀表达式.PNG","hash":"eed179716750b4ec27f97503eb2be409d7c8c961","modified":1545796511161},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"2df409df04fdb52d7234876a9f6e502edd4e3929","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"48bb741f6bda73b322a25a8fbe37fd3d5e0ff601","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1ec3102ee8f5b8cc0877da1fd109d37470401e7b","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"b8647d6140141b0a160607f6353e4d4594cca92e","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"32bbf059c57677e754a918c927ac63e2d843108f","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"e5a5f8747fdf2ca960e4e73c081b8952afd62224","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fa1cea6fcc3f552d57cc7d28380a304859139bf6","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"db1df0186a4572844d69d0d7bb974bd120cb64d5","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3241c9ae85ca11b6c4e125ac471aa4342ba1ce9c","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"fc94dd09b4245143b452d6cf2fc4c12134d99d6d","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"77da38898bdd99cf8fd3e0ae8cc4d2ac943bcb60","modified":1551770992355},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"8703ff5ebfc76420565b92b1b873e03fb9d9cf15","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"b6a241626783d2ac115d683fd59ec283af68e5bb","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"a0e84b21ecc1f69d8d42c83630c1004d3419e3fd","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"7b69c1ad392f8a386854e318d4c8ddeb9ba8d793","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"2ea91d7b75966d471bf857a9f3fbf87fd01aea90","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"989b7d718914b5242506947aa5767b3f2480d8f9","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"539fc0880b2e035e8316d5d4b423703195c1b7ba","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"981795aad232c8bd3f52a0ed8720db696d18a234","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"2e36956c5f8802f703c7ce3893d16323a0e09d4c","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"2e26e4429c2457b8ca12555426659c2fc65a5cea","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"41858f2dfd34a57d0a2016b1bce08efb61943b7a","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"2994c15172bcc916c64f484ca34c0c45951e95ca","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"7af14846bb8623ef1379575dd6f36c65589e69b4","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"7e2ba73073daaea0a18c3d67ff137dd683af7011","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"dd5f7057680faefc9306fab3172106f762c1a517","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"b9a19654b6a2685b5426afac8b09cdbd80fae00c","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"9da1cd122cd61896760b6f5edaed0be06c17fd6c","modified":1551770992371},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"64148d1d53f4a4a13dfe148fcf698486fc5c72ca","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"72cabf6edfd64697e37950cc3e66fbea6ba47b66","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"2937e566ad0f3d9adc0865b269fdca62b7576fdd","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"30ccc107061dc23943198f087759079161ee24e9","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"f1640253cbbf71d0c04c34c25bd61045894f98bc","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"f26c32a0c3045e5ae826b983abc3a3c139456663","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"a01484e350ad5fc9b1fdfbfafb2ddd9687ad4d20","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"49913bb2b702d52d77528cd9378126aa67c0082c","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"2a1008f1044b450b806adc166754ba9513e68375","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"74412b0bf4ec0d28aedd2e60b27affd4d5cd1452","modified":1551770992386},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3529aae283864fa0f09925ee8217905632e9a930","modified":1551770992386},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1551770992417},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1551770992417},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551770992457},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1551770992472},{"_id":"source/img/深入理解计算机系统/进程地址空间.PNG","hash":"66f40ecd1f2987980bfdb12b1084f379df6ef336","modified":1544706670826},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551770992457}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2019-02-24T03:19:45.475Z","updated":"2019-02-24T03:09:00.362Z","path":"404.html","title":"","comments":1,"_id":"cjswg90wd0000qcu3emxl6cqm","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Hey, this is Kaijun.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Hey, this is Kaijun.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","updated":"2019-02-24T03:09:00.377Z","path":"about/index.html","_id":"cjswg91420001qcu3gui8cs73","content":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"noopener\">李书航 － 什么是「共产中文腔调」？ </a><br></p>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"noopener\">李书航 － 什么是「共产中文腔调」？ </a><br></p>"},{"layout":"archives","title":"Archives","description":"Hey, this is Archives.","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Hey, this is Archives.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2019-02-24T03:09:00.377Z","updated":"2019-02-24T03:09:00.377Z","path":"archives/index.html","comments":1,"_id":"cjswg91440002qcu3hxghrswo","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2019-02-24T03:09:00.393Z","updated":"2019-02-24T03:09:00.393Z","path":"tags/index.html","comments":1,"_id":"cjswg91460003qcu3amkdcidg","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"哈尔滨工业大学计算机系统2018年秋期末复习","urlname":"hit_data_structure_review","mathjax":true,"description":"一直想拥有一个自己的博客，但是却一拖再拖，始终没有推送一篇博文，仅以此篇--哈尔滨工业大学计算机系统的复习提纲，仅为期末复习所准备，慰藉以往无bolg的时光。","abbrlink":22353,"date":"2019-03-05T06:00:00.000Z","_content":"\n\n- 计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小\n\n- ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件\n\n- 核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。\n\n- 存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存\n\n- 操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 \n\n### 信息的表示和处理\n\n#### 信息存储\n\n- 信息：\n\n```\n数值：值   小数点  符号（三要素）\n\n非数值：文字 图像 视频 语言\n```\n\n- 软件：\n\n  ```\n  系统软件：（用来管理整个计算机系统）\n  \n  语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件\n  ```\n\n- 计算机系统的层次结构：\n\n| 高级语言          | 虚拟机器M3   |\n| ----------------- | ------------ |\n| 汇编语言          | 虚拟机器M2   |\n| 操作系统          | 虚拟机器     |\n| 机器语言          | 实际机器M1   |\n| 微指令语言（时间) | 微程序机器M0 |\n- 机器数（码）：原码 反码 移码  补码\n\n- 数的逻辑：逻辑   算术（+ - * /） c语言中的数\n\n- 逻辑运算符&&和||与对应的位级运算符&和|第二个区别：\n\n  如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&&5/a不会造成被零除，p&&*p++不会导致间接引用空指针 \n\n- 集合的表示与运算\n\n  - 表示：位向量表示有限集合\n\n```\neg：10100110   从右到左表示 该集合={1，2，5，7}\n```\n\n- 运算：& 交集     |  并集    ^  对称差集    ~  补集                  \n\n- 左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x>>k表示x算术右移k个位置，x>>>k表示逻辑右移\n\n#### 整数表示\n\n##### 整数编码\n\n有符号数：补码\n\nB2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$\n\n例：\n\n|      | 10进制 | 16进制 | 2进制                             |\n| ---- | ------ | ------ | --------------------------------- |\n| X    | 15213  | 3B 6D  | 0011011 01101101                  |\n| Y    | -15213 | C4 93  | 1100100 10010011(最高位1表示负数) |\n\n\n|      | 原码       | 反码      | 补码      |\n| ---- | ---------- | --------- | --------- |\n| 11   | 0000 1011  | 0000 1011 | 0000 1011 |\n| -11  | 1000  1011 | 1111 0100 | 1111 0101 |\n\n注:负数的补码为反码加1,  正数的 原码、反码、补码都相同\n\n##### 知识细节\n\n- 有符号数同一表示形式下，负数的表示范围 比正数的范围大1  \n\n  同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                        \t  \t同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​\t\t\t\t\n\n- 对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变\n\n​\teg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同\n\n​\t无符号数和有符号数之间的转换规则：T-->U:补码转化为无符号数       U-->T:无符号数转化为补码\n\n​\t参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\n- 扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n- 截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n#### 整数运算\n\n##### 有符号数和无符号数转换的基本原则：\n\n```\n-位模式不变\n\n-重新解读（按目标编码类型的规则解读）\n\n-会有意外的副作用：数值被 + 或 -$2^w$\n\n-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数\n```\n\n加法:\t无/有符号数的加法：正常加法后再截断，位级的运算相同\n\n​\t\t无符号数：加后对$2^w$求模\n\n##### 符号位扩展\n\n```\n-无符号数：填充0\n\n-有符号位：符号扩展\n\n\t\t\teg：-15213    二进制：11000100 10010011  ---> 11111111 11111111 11000100 10010011\n\n-结果都是明确的预期值\n```\n\n##### 截断\n\n```\n-无论有无符号数，多出的位数都被截断\n\n-结果重新解读\n\n-无符号数: 相当于求模运算\n\n-有符号数：和求模运算相似\n```\n\n​\t-对于小整数，结果是明确的预期值\n\n##### 检测无符号数加法中的溢出：\n\n​\ts =x+y,当且仅当s < x(或等价的s < y)时发生了溢出\n\n​\t无符号数逆元（求反）：x=0时：-x=0\n\n​\t\t\t\t   x > 0时: -x = $2^w$\n\n##### 补码加法：\n\n对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有\n$$\n\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w& 2^{w-1}\\le{x+y} & 正溢出\\\\x+y & -2^{w-1}\\le{x+y}<2^{w-1} & 正常\\\\x+y+2^w & x+y<-2^{w-1} & 负溢出\\end{cases}\\end{equation}\n$$\n​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x > 0,y > 0但s$\\le$0时发生了正溢出；当且仅当x < 0,y < 0但s$\\geq$0时发生了正溢出  \n\n##### 补码的非                                                                                    \n\n对满足$TMin_w\\le x\\le TMax_w$\t的$x$，其补码的非$-^t_wx$由下式给出：\n$$\n\\begin{equation}-^t_wx=\\begin{cases}TMin_w& x = TMin_w\\\\-x & x>TMin_w\\end{cases}\\end{equation}\n$$\n也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆\n\n##### 补码非的位级表示\n\n​\t方法一：对每一位求补，再对结果加1\n\n​\t方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反\n\n#### 浮点数\n\n- IEEE标准：\n\n![浮点数标准分类](/img/深入理解计算机系统/浮点数标准分类.PNG)\n\n- 浮点数规格化的值（frac、exp）\n\n![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG)\n\n- 对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 ![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG) \n\n- 舍入\n\n![浮点数舍入](/img/深入理解计算机系统/浮点数舍入.PNG)\n\n​\t将float或double转化成int，值将向零舍入                    \n\n### 程序的机器级表示\n\n#### 数据格式\n\nc数据类型的宽度\n\n| c数据类型   | 32位 | 64位 | x86-64 |\n| ----------- | ---- | ---- | ------ |\n| char        | 1    | 1    | 1      |\n| short       | 2    | 2    | 2      |\n| int         | 4    | 4    | 4      |\n| long        | 4    | 8    | 8      |\n| float       | 4    | 4    | 4      |\n| double      | 8    | 8    | 8      |\n| long double | -    | -    | 10/16  |\n| pointer     | 4    | 8    | 8      |\n\n\n#### 访问信息\n\n- 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；\n\n- MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。\n\n​\tMOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；\n\n​\tMOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax\n\n#### 算术和逻辑操作\n\n![算术和逻辑操作指令](/img/深入理解计算机系统/算术和逻辑操作指令.PNG)\n\n（1）leap指令目的操作数必须是寄存器\n\n（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0\n\n（3）特殊的算术操作\n\n![特殊的操作指令](/img/深入理解计算机系统/特殊的操作指令.PNG)\n\n有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx\n\ncqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位\n\n#### 控制\n\n（1）leaq指令不改变条件码\n\n（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and\n\n（3）条件码通常不会直接读取，常用使用方法：\n\n​\ta、根据条件码的某种组合将一个字节设置为0或1（即set指令）\n\n​\tb、条件跳转到程序的某个其他部分\n\n​\tc、有条件的传送数据\n\n（4）set指令：\n\n![set指令](/img/深入理解计算机系统/set指令.PNG)\n\n#### 过程\n\n （1）传递控制、传递数据、分配和释放内存\n\n![栈结构](/img/深入理解计算机系统/栈结构.PNG)\n\n（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数\n\n（3）栈上的局部变量（局部数据必须用主存的情况)\n\n​\t1）寄存器不足够存放所有的本地数据\n\n​\t2）对一个局部变量使用取址符&，因此必须为其产生一个地址\n\n​\t3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。\n\n注：寄存器是唯一被所有过程共享的资源\n\n#### 对抗缓冲区溢出\n\n方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域\n\n#### 过程中的浮点代码\n\n- XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。\n\n- 函数使用寄存器%xmm0来返回浮点值。\n\n- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器\n  中任意一个。\n\n  | 单精度 | 双精度 | 效果   | 描述                    |\n  | ------ | ------ | ------ | ----------------------- |\n  | vxorps | vorpd  | D<-x*y | 位级异或（EXCLUSIVE-OR) |\n  | vandps | andpd  | D<-x&y | 位级与（AND）           |\n\n| 指令        | 基于 | 描述         |\n| ----------- | ---- | ------------ |\n| ucomiss x,y | y-x  | 比较单精度值 |\n| ucomisd x,y | y-x  | 比较双精度值 |\n\n### 处理器体系结构\n\n1、程序计数器PC保存当前正在执行指令的地址\n\n2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址\n\n3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。\n\n4、指令集的一个重要性质就是每个字节编码必须有唯一的解释\n\n5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字\n\n6、指令处理：\n\n取指、译码、执行、访存、写回、更新PC\n\n7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。\n\n8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。\n\n9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。\n\n### 优化程序性能\n\n- 程序性能标准：每元素的周期数CPE\n\n- 优化方法：\n\n  1、消除循环低效率：代码移动：\n\n  2、减少过程调用\n\n  3、消除不必要的内存引用\n\n  4、循环展开：减少迭代次数\n\n  5、提高并行性：多个累计变量并行求、重新结合变换\n\n- 课本总结：\n\n  1）高级设计：算法和数据结构\n\n  2）基本编码原则：\n\n  - 消除连续的函数调用：将计算移动到循环外\n\n  - 消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量\n\n  3）低级优化：\n\n  - 展开循环，降低开销，并且使进一步优化成为可能\n\n  - 通过使用例如多个累积变量和重新结合等技术，提高指令集并行\n\n  - 用功能性的风格重写条件操作，使得编译采用条件数据传送\n\n- 限制因素：\n\n  1、寄存器溢出\n\n  2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码\n\n### 存储器层次结构\n\n#### 存储技术\n\n#####  随机访问存储器\n\n随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM\n\n（1）静态（SRAM）\n\nSRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一\n\n（2）动态（DRAM）\n\nDRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复\n\n对比：\n\n![SRAM和DRAM对比](/img/深入理解计算机系统/SRAM和DRAM对比.PNG)\n\n（3）传统的DRAM\n\nDRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。\n\n每个超单元存储一个字节\n\n(4)内存模块\n\n--DRAM芯片封装在内存模块中，插到主板的扩展槽上\n\n--内存地址A取值过程：\n\n![6.1.1内存地址取值](/img/深入理解计算机系统/6.1.1内存地址取值.PNG)\n\n\n\n（5）增强的DRAM\n\n快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM\n\n（6）非易失性存储器\n\nROM\n\n（7）访问主存\n\n总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线\n\n##### 磁盘存储\n\n磁盘读取时间计算：\n\n![磁盘读取时间计算](/img/深入理解计算机系统/磁盘读取时间计算.PNG)\n\n#### 局部性\n\n   (1)重复引用相同局部变量的程序具有良好的时间局部性\n\n（2）步长越小，空间局部性越好\n\n（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好\n\n#### 存储器层次结构\n\n存储器层次结构\n\n![存储器层次结构](/img/深入理解计算机系统/存储器层次结构.PNG)\n\n\n\n#### 高速缓存存储器\n\n缓存不命中：\n\n- 冷不命中（强制性不命中）：\n\n  k层缓存有空行，程序最开始运行时均为冷不命中\n\n- 冲突不命中\n\n  k层中没有空行 \n\n- 容量不命中\n\n组相连高速缓存、组相连高速缓存、全相连高速缓存\n\n#### 编写高速缓存存储器\n\n写命中：\n\n直写：高速缓存中更新的数据立即写回到低一层中\n\n写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中\n\n写不命中：\n\n写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块\n\n非写分配：避开高速缓存，直接把这个字写到低一层中\n\n**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的\n\n#### 综合：高速缓存对程序性能的影响\n\n如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中\n\n### 异常控制流\n\n#### 异常\n\n（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现\n\n（2）事件处理：\n\n![8.1事件处理](/img/深入理解计算机系统/8.1事件处理.PNG)\n\n（3）异常分类\n\n![异常分类](/img/深入理解计算机系统/异常分类.PNG)\n\n![异常分类2](/img/深入理解计算机系统/异常分类2.PNG)\n\n#### 进程\n\n进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成\n\n进程提供的关键抽象：\n\n一个独立的逻辑控制流、一个私有的地址空间\n\n- 并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。\n\n- 如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行\n\n- 进程地址空间\n\n  ![进程地址空间](/img/深入理解计算机系统/进程地址空间.PNG)\n\n- 用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常\n\n- 上下文切换：\n\n  1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程\n\n#### 进程控制\n\n- 进程的三种状态：\n\n运行：进程要么被执行，要么等待被执行且被内核调度\n\n停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号\n\n终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数\n\n- 父进程和子进程最大的区别是PID不同。\n\nfork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；\n\n- 子进程和父进程：\n\n  1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件\n\n- pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1\n\n- unsigned int sleep(unsigned int secs)：返回还要休眠的秒数\n\n- int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号\n\n- execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。\n\n#### 编写信号处理程序\n\n1、安全的信号处理\n\n（1）处理程序要尽可能的简单\n\n（2）在处理程序中只调用异步信号安全的函数\n\n（3）保存和恢复errno\n\n（4）阻塞所有信号，保护对共享数据结构的访问\n\n（5）用volatile声明全局变量\n\n（6）用sig_atomic_t声明标志\n\n2、正确的信号处理：未处理的信号不排队\n\n3、可移植的信号处理\n\n\n\n由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦-----\n\n","source":"_posts/深入理解计算机系统.md","raw":"---\ntitle: 哈尔滨工业大学计算机系统2018年秋期末复习\nurlname: hit_data_structure_review\nmathjax: true\ntags:\n  - 计算机系统\n  - 期末复习\ndescription: 一直想拥有一个自己的博客，但是却一拖再拖，始终没有推送一篇博文，仅以此篇--哈尔滨工业大学计算机系统的复习提纲，仅为期末复习所准备，慰藉以往无bolg的时光。\nabbrlink: 22353\ndate: 2019-03-05 14:00:00\n---\n\n\n- 计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小\n\n- ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件\n\n- 核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。\n\n- 存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存\n\n- 操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 \n\n### 信息的表示和处理\n\n#### 信息存储\n\n- 信息：\n\n```\n数值：值   小数点  符号（三要素）\n\n非数值：文字 图像 视频 语言\n```\n\n- 软件：\n\n  ```\n  系统软件：（用来管理整个计算机系统）\n  \n  语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件\n  ```\n\n- 计算机系统的层次结构：\n\n| 高级语言          | 虚拟机器M3   |\n| ----------------- | ------------ |\n| 汇编语言          | 虚拟机器M2   |\n| 操作系统          | 虚拟机器     |\n| 机器语言          | 实际机器M1   |\n| 微指令语言（时间) | 微程序机器M0 |\n- 机器数（码）：原码 反码 移码  补码\n\n- 数的逻辑：逻辑   算术（+ - * /） c语言中的数\n\n- 逻辑运算符&&和||与对应的位级运算符&和|第二个区别：\n\n  如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&&5/a不会造成被零除，p&&*p++不会导致间接引用空指针 \n\n- 集合的表示与运算\n\n  - 表示：位向量表示有限集合\n\n```\neg：10100110   从右到左表示 该集合={1，2，5，7}\n```\n\n- 运算：& 交集     |  并集    ^  对称差集    ~  补集                  \n\n- 左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x>>k表示x算术右移k个位置，x>>>k表示逻辑右移\n\n#### 整数表示\n\n##### 整数编码\n\n有符号数：补码\n\nB2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$\n\n例：\n\n|      | 10进制 | 16进制 | 2进制                             |\n| ---- | ------ | ------ | --------------------------------- |\n| X    | 15213  | 3B 6D  | 0011011 01101101                  |\n| Y    | -15213 | C4 93  | 1100100 10010011(最高位1表示负数) |\n\n\n|      | 原码       | 反码      | 补码      |\n| ---- | ---------- | --------- | --------- |\n| 11   | 0000 1011  | 0000 1011 | 0000 1011 |\n| -11  | 1000  1011 | 1111 0100 | 1111 0101 |\n\n注:负数的补码为反码加1,  正数的 原码、反码、补码都相同\n\n##### 知识细节\n\n- 有符号数同一表示形式下，负数的表示范围 比正数的范围大1  \n\n  同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                        \t  \t同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​\t\t\t\t\n\n- 对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变\n\n​\teg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同\n\n​\t无符号数和有符号数之间的转换规则：T-->U:补码转化为无符号数       U-->T:无符号数转化为补码\n\n​\t参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\n- 扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n- 截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n#### 整数运算\n\n##### 有符号数和无符号数转换的基本原则：\n\n```\n-位模式不变\n\n-重新解读（按目标编码类型的规则解读）\n\n-会有意外的副作用：数值被 + 或 -$2^w$\n\n-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数\n```\n\n加法:\t无/有符号数的加法：正常加法后再截断，位级的运算相同\n\n​\t\t无符号数：加后对$2^w$求模\n\n##### 符号位扩展\n\n```\n-无符号数：填充0\n\n-有符号位：符号扩展\n\n\t\t\teg：-15213    二进制：11000100 10010011  ---> 11111111 11111111 11000100 10010011\n\n-结果都是明确的预期值\n```\n\n##### 截断\n\n```\n-无论有无符号数，多出的位数都被截断\n\n-结果重新解读\n\n-无符号数: 相当于求模运算\n\n-有符号数：和求模运算相似\n```\n\n​\t-对于小整数，结果是明确的预期值\n\n##### 检测无符号数加法中的溢出：\n\n​\ts =x+y,当且仅当s < x(或等价的s < y)时发生了溢出\n\n​\t无符号数逆元（求反）：x=0时：-x=0\n\n​\t\t\t\t   x > 0时: -x = $2^w$\n\n##### 补码加法：\n\n对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有\n$$\n\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w& 2^{w-1}\\le{x+y} & 正溢出\\\\x+y & -2^{w-1}\\le{x+y}<2^{w-1} & 正常\\\\x+y+2^w & x+y<-2^{w-1} & 负溢出\\end{cases}\\end{equation}\n$$\n​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x > 0,y > 0但s$\\le$0时发生了正溢出；当且仅当x < 0,y < 0但s$\\geq$0时发生了正溢出  \n\n##### 补码的非                                                                                    \n\n对满足$TMin_w\\le x\\le TMax_w$\t的$x$，其补码的非$-^t_wx$由下式给出：\n$$\n\\begin{equation}-^t_wx=\\begin{cases}TMin_w& x = TMin_w\\\\-x & x>TMin_w\\end{cases}\\end{equation}\n$$\n也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆\n\n##### 补码非的位级表示\n\n​\t方法一：对每一位求补，再对结果加1\n\n​\t方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反\n\n#### 浮点数\n\n- IEEE标准：\n\n![浮点数标准分类](/img/深入理解计算机系统/浮点数标准分类.PNG)\n\n- 浮点数规格化的值（frac、exp）\n\n![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG)\n\n- 对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 ![浮点数规格化的值](/img/深入理解计算机系统/浮点数规格化的值.PNG) \n\n- 舍入\n\n![浮点数舍入](/img/深入理解计算机系统/浮点数舍入.PNG)\n\n​\t将float或double转化成int，值将向零舍入                    \n\n### 程序的机器级表示\n\n#### 数据格式\n\nc数据类型的宽度\n\n| c数据类型   | 32位 | 64位 | x86-64 |\n| ----------- | ---- | ---- | ------ |\n| char        | 1    | 1    | 1      |\n| short       | 2    | 2    | 2      |\n| int         | 4    | 4    | 4      |\n| long        | 4    | 8    | 8      |\n| float       | 4    | 4    | 4      |\n| double      | 8    | 8    | 8      |\n| long double | -    | -    | 10/16  |\n| pointer     | 4    | 8    | 8      |\n\n\n#### 访问信息\n\n- 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；\n\n- MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。\n\n​\tMOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；\n\n​\tMOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax\n\n#### 算术和逻辑操作\n\n![算术和逻辑操作指令](/img/深入理解计算机系统/算术和逻辑操作指令.PNG)\n\n（1）leap指令目的操作数必须是寄存器\n\n（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0\n\n（3）特殊的算术操作\n\n![特殊的操作指令](/img/深入理解计算机系统/特殊的操作指令.PNG)\n\n有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx\n\ncqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位\n\n#### 控制\n\n（1）leaq指令不改变条件码\n\n（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and\n\n（3）条件码通常不会直接读取，常用使用方法：\n\n​\ta、根据条件码的某种组合将一个字节设置为0或1（即set指令）\n\n​\tb、条件跳转到程序的某个其他部分\n\n​\tc、有条件的传送数据\n\n（4）set指令：\n\n![set指令](/img/深入理解计算机系统/set指令.PNG)\n\n#### 过程\n\n （1）传递控制、传递数据、分配和释放内存\n\n![栈结构](/img/深入理解计算机系统/栈结构.PNG)\n\n（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数\n\n（3）栈上的局部变量（局部数据必须用主存的情况)\n\n​\t1）寄存器不足够存放所有的本地数据\n\n​\t2）对一个局部变量使用取址符&，因此必须为其产生一个地址\n\n​\t3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。\n\n注：寄存器是唯一被所有过程共享的资源\n\n#### 对抗缓冲区溢出\n\n方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域\n\n#### 过程中的浮点代码\n\n- XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。\n\n- 函数使用寄存器%xmm0来返回浮点值。\n\n- 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器\n  中任意一个。\n\n  | 单精度 | 双精度 | 效果   | 描述                    |\n  | ------ | ------ | ------ | ----------------------- |\n  | vxorps | vorpd  | D<-x*y | 位级异或（EXCLUSIVE-OR) |\n  | vandps | andpd  | D<-x&y | 位级与（AND）           |\n\n| 指令        | 基于 | 描述         |\n| ----------- | ---- | ------------ |\n| ucomiss x,y | y-x  | 比较单精度值 |\n| ucomisd x,y | y-x  | 比较双精度值 |\n\n### 处理器体系结构\n\n1、程序计数器PC保存当前正在执行指令的地址\n\n2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址\n\n3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。\n\n4、指令集的一个重要性质就是每个字节编码必须有唯一的解释\n\n5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字\n\n6、指令处理：\n\n取指、译码、执行、访存、写回、更新PC\n\n7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。\n\n8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。\n\n9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。\n\n### 优化程序性能\n\n- 程序性能标准：每元素的周期数CPE\n\n- 优化方法：\n\n  1、消除循环低效率：代码移动：\n\n  2、减少过程调用\n\n  3、消除不必要的内存引用\n\n  4、循环展开：减少迭代次数\n\n  5、提高并行性：多个累计变量并行求、重新结合变换\n\n- 课本总结：\n\n  1）高级设计：算法和数据结构\n\n  2）基本编码原则：\n\n  - 消除连续的函数调用：将计算移动到循环外\n\n  - 消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量\n\n  3）低级优化：\n\n  - 展开循环，降低开销，并且使进一步优化成为可能\n\n  - 通过使用例如多个累积变量和重新结合等技术，提高指令集并行\n\n  - 用功能性的风格重写条件操作，使得编译采用条件数据传送\n\n- 限制因素：\n\n  1、寄存器溢出\n\n  2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码\n\n### 存储器层次结构\n\n#### 存储技术\n\n#####  随机访问存储器\n\n随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM\n\n（1）静态（SRAM）\n\nSRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一\n\n（2）动态（DRAM）\n\nDRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复\n\n对比：\n\n![SRAM和DRAM对比](/img/深入理解计算机系统/SRAM和DRAM对比.PNG)\n\n（3）传统的DRAM\n\nDRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。\n\n每个超单元存储一个字节\n\n(4)内存模块\n\n--DRAM芯片封装在内存模块中，插到主板的扩展槽上\n\n--内存地址A取值过程：\n\n![6.1.1内存地址取值](/img/深入理解计算机系统/6.1.1内存地址取值.PNG)\n\n\n\n（5）增强的DRAM\n\n快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM\n\n（6）非易失性存储器\n\nROM\n\n（7）访问主存\n\n总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线\n\n##### 磁盘存储\n\n磁盘读取时间计算：\n\n![磁盘读取时间计算](/img/深入理解计算机系统/磁盘读取时间计算.PNG)\n\n#### 局部性\n\n   (1)重复引用相同局部变量的程序具有良好的时间局部性\n\n（2）步长越小，空间局部性越好\n\n（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好\n\n#### 存储器层次结构\n\n存储器层次结构\n\n![存储器层次结构](/img/深入理解计算机系统/存储器层次结构.PNG)\n\n\n\n#### 高速缓存存储器\n\n缓存不命中：\n\n- 冷不命中（强制性不命中）：\n\n  k层缓存有空行，程序最开始运行时均为冷不命中\n\n- 冲突不命中\n\n  k层中没有空行 \n\n- 容量不命中\n\n组相连高速缓存、组相连高速缓存、全相连高速缓存\n\n#### 编写高速缓存存储器\n\n写命中：\n\n直写：高速缓存中更新的数据立即写回到低一层中\n\n写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中\n\n写不命中：\n\n写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块\n\n非写分配：避开高速缓存，直接把这个字写到低一层中\n\n**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的\n\n#### 综合：高速缓存对程序性能的影响\n\n如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中\n\n### 异常控制流\n\n#### 异常\n\n（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现\n\n（2）事件处理：\n\n![8.1事件处理](/img/深入理解计算机系统/8.1事件处理.PNG)\n\n（3）异常分类\n\n![异常分类](/img/深入理解计算机系统/异常分类.PNG)\n\n![异常分类2](/img/深入理解计算机系统/异常分类2.PNG)\n\n#### 进程\n\n进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成\n\n进程提供的关键抽象：\n\n一个独立的逻辑控制流、一个私有的地址空间\n\n- 并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。\n\n- 如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行\n\n- 进程地址空间\n\n  ![进程地址空间](/img/深入理解计算机系统/进程地址空间.PNG)\n\n- 用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常\n\n- 上下文切换：\n\n  1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程\n\n#### 进程控制\n\n- 进程的三种状态：\n\n运行：进程要么被执行，要么等待被执行且被内核调度\n\n停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号\n\n终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数\n\n- 父进程和子进程最大的区别是PID不同。\n\nfork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；\n\n- 子进程和父进程：\n\n  1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件\n\n- pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1\n\n- unsigned int sleep(unsigned int secs)：返回还要休眠的秒数\n\n- int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号\n\n- execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。\n\n#### 编写信号处理程序\n\n1、安全的信号处理\n\n（1）处理程序要尽可能的简单\n\n（2）在处理程序中只调用异步信号安全的函数\n\n（3）保存和恢复errno\n\n（4）阻塞所有信号，保护对共享数据结构的访问\n\n（5）用volatile声明全局变量\n\n（6）用sig_atomic_t声明标志\n\n2、正确的信号处理：未处理的信号不排队\n\n3、可移植的信号处理\n\n\n\n由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦-----\n\n","slug":"深入理解计算机系统","published":1,"updated":"2019-03-05T07:05:26.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjswg915l0004qcu3kqje48gn","content":"<ul>\n<li><p>计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小</p>\n</li>\n<li><p>ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件</p>\n</li>\n<li><p>核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。</p>\n</li>\n<li><p>存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存</p>\n</li>\n<li><p>操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 </p>\n</li>\n</ul>\n<h3 id=\"信息的表示和处理\"><a href=\"#信息的表示和处理\" class=\"headerlink\" title=\"信息的表示和处理\"></a>信息的表示和处理</h3><h4 id=\"信息存储\"><a href=\"#信息存储\" class=\"headerlink\" title=\"信息存储\"></a>信息存储</h4><ul>\n<li>信息：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数值：值   小数点  符号（三要素）</span><br><span class=\"line\"></span><br><span class=\"line\">非数值：文字 图像 视频 语言</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>软件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统软件：（用来管理整个计算机系统）</span><br><span class=\"line\"></span><br><span class=\"line\">语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计算机系统的层次结构：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>高级语言</th>\n<th>虚拟机器M3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>汇编语言</td>\n<td>虚拟机器M2</td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>虚拟机器</td>\n</tr>\n<tr>\n<td>机器语言</td>\n<td>实际机器M1</td>\n</tr>\n<tr>\n<td>微指令语言（时间)</td>\n<td>微程序机器M0</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>机器数（码）：原码 反码 移码  补码</p>\n</li>\n<li><p>数的逻辑：逻辑   算术（+ - * /） c语言中的数</p>\n</li>\n<li><p>逻辑运算符&amp;&amp;和||与对应的位级运算符&amp;和|第二个区别：</p>\n<p>如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&amp;&amp;5/a不会造成被零除，p&amp;&amp;*p++不会导致间接引用空指针 </p>\n</li>\n<li><p>集合的表示与运算</p>\n<ul>\n<li>表示：位向量表示有限集合</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：<span class=\"number\">10100110</span>   从右到左表示 该集合=&#123;<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">5</span>，<span class=\"number\">7</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>运算：&amp; 交集     |  并集    ^  对称差集    ~  补集                  </p>\n</li>\n<li><p>左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x&gt;&gt;k表示x算术右移k个位置，x&gt;&gt;&gt;k表示逻辑右移</p>\n</li>\n</ul>\n<h4 id=\"整数表示\"><a href=\"#整数表示\" class=\"headerlink\" title=\"整数表示\"></a>整数表示</h4><h5 id=\"整数编码\"><a href=\"#整数编码\" class=\"headerlink\" title=\"整数编码\"></a>整数编码</h5><p>有符号数：补码</p>\n<p>B2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$</p>\n<p>例：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>10进制</th>\n<th>16进制</th>\n<th>2进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>15213</td>\n<td>3B 6D</td>\n<td>0011011 01101101</td>\n</tr>\n<tr>\n<td>Y</td>\n<td>-15213</td>\n<td>C4 93</td>\n<td>1100100 10010011(最高位1表示负数)</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>原码</th>\n<th>反码</th>\n<th>补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n</tr>\n<tr>\n<td>-11</td>\n<td>1000  1011</td>\n<td>1111 0100</td>\n<td>1111 0101</td>\n</tr>\n</tbody>\n</table>\n<p>注:负数的补码为反码加1,  正数的 原码、反码、补码都相同</p>\n<h5 id=\"知识细节\"><a href=\"#知识细节\" class=\"headerlink\" title=\"知识细节\"></a>知识细节</h5><ul>\n<li><p>有符号数同一表示形式下，负数的表示范围 比正数的范围大1  </p>\n<p>同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                                  同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​                </p>\n</li>\n<li><p>对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变</p>\n</li>\n</ul>\n<p>​    eg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同</p>\n<p>​    无符号数和有符号数之间的转换规则：T–&gt;U:补码转化为无符号数       U–&gt;T:无符号数转化为补码</p>\n<p>​    参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​                                                      </p>\n<ul>\n<li><p>扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​                                                        </p>\n</li>\n<li><p>截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​                                                    </p>\n</li>\n</ul>\n<h4 id=\"整数运算\"><a href=\"#整数运算\" class=\"headerlink\" title=\"整数运算\"></a>整数运算</h4><h5 id=\"有符号数和无符号数转换的基本原则：\"><a href=\"#有符号数和无符号数转换的基本原则：\" class=\"headerlink\" title=\"有符号数和无符号数转换的基本原则：\"></a>有符号数和无符号数转换的基本原则：</h5><figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">位模式不变</span></span><br><span class=\"line\"><span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\">-重新解读（按目标编码类型的规则解读）</span></span><br><span class=\"line\"><span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\">-会有意外的副作用：数值被 + 或 -$2^w$</span></span><br><span class=\"line\"><span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\">-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数</span></span><br></pre></td></tr></table></figure>\n<p>加法:    无/有符号数的加法：正常加法后再截断，位级的运算相同</p>\n<p>​        无符号数：加后对$2^w$求模</p>\n<h5 id=\"符号位扩展\"><a href=\"#符号位扩展\" class=\"headerlink\" title=\"符号位扩展\"></a>符号位扩展</h5><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-无符号数：填充<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">-有符号位：符号扩展</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\teg：<span class=\"number\">-15213</span>    二进制：<span class=\"number\">11000100</span> <span class=\"number\">10010011</span>  ---&gt; <span class=\"number\">11111111</span> <span class=\"number\">11111111</span> <span class=\"number\">11000100</span> <span class=\"number\">10010011</span></span><br><span class=\"line\"></span><br><span class=\"line\">-结果都是明确的预期值</span><br></pre></td></tr></table></figure>\n<h5 id=\"截断\"><a href=\"#截断\" class=\"headerlink\" title=\"截断\"></a>截断</h5><figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-无论有无符号数，多出的位数都被截断</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-结果重新解读</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-无符号数: 相当于求模运算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-有符号数：和求模运算相似</span></span><br></pre></td></tr></table></figure>\n<p>​    -对于小整数，结果是明确的预期值</p>\n<h5 id=\"检测无符号数加法中的溢出：\"><a href=\"#检测无符号数加法中的溢出：\" class=\"headerlink\" title=\"检测无符号数加法中的溢出：\"></a>检测无符号数加法中的溢出：</h5><p>​    s =x+y,当且仅当s &lt; x(或等价的s &lt; y)时发生了溢出</p>\n<p>​    无符号数逆元（求反）：x=0时：-x=0</p>\n<p>​                   x &gt; 0时: -x = $2^w$</p>\n<h5 id=\"补码加法：\"><a href=\"#补码加法：\" class=\"headerlink\" title=\"补码加法：\"></a>补码加法：</h5><p>对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有<br>$$<br>\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w&amp; 2^{w-1}\\le{x+y} &amp; 正溢出\\x+y &amp; -2^{w-1}\\le{x+y}&lt;2^{w-1} &amp; 正常\\x+y+2^w &amp; x+y&lt;-2^{w-1} &amp; 负溢出\\end{cases}\\end{equation}<br>$$<br>​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x &gt; 0,y &gt; 0但s$\\le$0时发生了正溢出；当且仅当x &lt; 0,y &lt; 0但s$\\geq$0时发生了正溢出  </p>\n<h5 id=\"补码的非\"><a href=\"#补码的非\" class=\"headerlink\" title=\"补码的非\"></a>补码的非</h5><p>对满足$TMin_w\\le x\\le TMax_w$    的$x$，其补码的非$-^t_wx$由下式给出：<br>$$<br>\\begin{equation}-^t_wx=\\begin{cases}TMin_w&amp; x = TMin_w\\-x &amp; x&gt;TMin_w\\end{cases}\\end{equation}<br>$$<br>也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆</p>\n<h5 id=\"补码非的位级表示\"><a href=\"#补码非的位级表示\" class=\"headerlink\" title=\"补码非的位级表示\"></a>补码非的位级表示</h5><p>​    方法一：对每一位求补，再对结果加1</p>\n<p>​    方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反</p>\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><ul>\n<li>IEEE标准：</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数标准分类.PNG\" alt=\"浮点数标准分类\"></p>\n<ul>\n<li>浮点数规格化的值（frac、exp）</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"></p>\n<ul>\n<li><p>对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 <img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"> </p>\n</li>\n<li><p>舍入</p>\n</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数舍入.PNG\" alt=\"浮点数舍入\"></p>\n<p>​    将float或double转化成int，值将向零舍入                    </p>\n<h3 id=\"程序的机器级表示\"><a href=\"#程序的机器级表示\" class=\"headerlink\" title=\"程序的机器级表示\"></a>程序的机器级表示</h3><h4 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h4><p>c数据类型的宽度</p>\n<table>\n<thead>\n<tr>\n<th>c数据类型</th>\n<th>32位</th>\n<th>64位</th>\n<th>x86-64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>long</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>-</td>\n<td>-</td>\n<td>10/16</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"访问信息\"><a href=\"#访问信息\" class=\"headerlink\" title=\"访问信息\"></a>访问信息</h4><ul>\n<li><p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；</p>\n</li>\n<li><p>MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。</p>\n</li>\n</ul>\n<p>​    MOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；</p>\n<p>​    MOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax</p>\n<h4 id=\"算术和逻辑操作\"><a href=\"#算术和逻辑操作\" class=\"headerlink\" title=\"算术和逻辑操作\"></a>算术和逻辑操作</h4><p><img src=\"/img/深入理解计算机系统/算术和逻辑操作指令.PNG\" alt=\"算术和逻辑操作指令\"></p>\n<p>（1）leap指令目的操作数必须是寄存器</p>\n<p>（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0</p>\n<p>（3）特殊的算术操作</p>\n<p><img src=\"/img/深入理解计算机系统/特殊的操作指令.PNG\" alt=\"特殊的操作指令\"></p>\n<p>有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx</p>\n<p>cqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位</p>\n<h4 id=\"控制\"><a href=\"#控制\" class=\"headerlink\" title=\"控制\"></a>控制</h4><p>（1）leaq指令不改变条件码</p>\n<p>（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and</p>\n<p>（3）条件码通常不会直接读取，常用使用方法：</p>\n<p>​    a、根据条件码的某种组合将一个字节设置为0或1（即set指令）</p>\n<p>​    b、条件跳转到程序的某个其他部分</p>\n<p>​    c、有条件的传送数据</p>\n<p>（4）set指令：</p>\n<p><img src=\"/img/深入理解计算机系统/set指令.PNG\" alt=\"set指令\"></p>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p> （1）传递控制、传递数据、分配和释放内存</p>\n<p><img src=\"/img/深入理解计算机系统/栈结构.PNG\" alt=\"栈结构\"></p>\n<p>（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数</p>\n<p>（3）栈上的局部变量（局部数据必须用主存的情况)</p>\n<p>​    1）寄存器不足够存放所有的本地数据</p>\n<p>​    2）对一个局部变量使用取址符&amp;，因此必须为其产生一个地址</p>\n<p>​    3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。</p>\n<p>注：寄存器是唯一被所有过程共享的资源</p>\n<h4 id=\"对抗缓冲区溢出\"><a href=\"#对抗缓冲区溢出\" class=\"headerlink\" title=\"对抗缓冲区溢出\"></a>对抗缓冲区溢出</h4><p>方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域</p>\n<h4 id=\"过程中的浮点代码\"><a href=\"#过程中的浮点代码\" class=\"headerlink\" title=\"过程中的浮点代码\"></a>过程中的浮点代码</h4><ul>\n<li><p>XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</p>\n</li>\n<li><p>函数使用寄存器%xmm0来返回浮点值。</p>\n</li>\n<li><p>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器<br>中任意一个。</p>\n<p>| 单精度 | 双精度 | 效果   | 描述                    |<br>| —— | —— | —— | ———————– |<br>| vxorps | vorpd  | D&lt;-x*y | 位级异或（EXCLUSIVE-OR) |<br>| vandps | andpd  | D&lt;-x&amp;y | 位级与（AND）           |</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>基于</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ucomiss x,y</td>\n<td>y-x</td>\n<td>比较单精度值</td>\n</tr>\n<tr>\n<td>ucomisd x,y</td>\n<td>y-x</td>\n<td>比较双精度值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"处理器体系结构\"><a href=\"#处理器体系结构\" class=\"headerlink\" title=\"处理器体系结构\"></a>处理器体系结构</h3><p>1、程序计数器PC保存当前正在执行指令的地址</p>\n<p>2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址</p>\n<p>3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。</p>\n<p>4、指令集的一个重要性质就是每个字节编码必须有唯一的解释</p>\n<p>5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字</p>\n<p>6、指令处理：</p>\n<p>取指、译码、执行、访存、写回、更新PC</p>\n<p>7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。</p>\n<p>8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p>\n<p>9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。</p>\n<h3 id=\"优化程序性能\"><a href=\"#优化程序性能\" class=\"headerlink\" title=\"优化程序性能\"></a>优化程序性能</h3><ul>\n<li><p>程序性能标准：每元素的周期数CPE</p>\n</li>\n<li><p>优化方法：</p>\n<p>1、消除循环低效率：代码移动：</p>\n<p>2、减少过程调用</p>\n<p>3、消除不必要的内存引用</p>\n<p>4、循环展开：减少迭代次数</p>\n<p>5、提高并行性：多个累计变量并行求、重新结合变换</p>\n</li>\n<li><p>课本总结：</p>\n<p>1）高级设计：算法和数据结构</p>\n<p>2）基本编码原则：</p>\n<ul>\n<li><p>消除连续的函数调用：将计算移动到循环外</p>\n</li>\n<li><p>消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量</p>\n</li>\n</ul>\n<p>3）低级优化：</p>\n<ul>\n<li><p>展开循环，降低开销，并且使进一步优化成为可能</p>\n</li>\n<li><p>通过使用例如多个累积变量和重新结合等技术，提高指令集并行</p>\n</li>\n<li><p>用功能性的风格重写条件操作，使得编译采用条件数据传送</p>\n</li>\n</ul>\n</li>\n<li><p>限制因素：</p>\n<p>1、寄存器溢出</p>\n<p>2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码</p>\n</li>\n</ul>\n<h3 id=\"存储器层次结构\"><a href=\"#存储器层次结构\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h3><h4 id=\"存储技术\"><a href=\"#存储技术\" class=\"headerlink\" title=\"存储技术\"></a>存储技术</h4><h5 id=\"随机访问存储器\"><a href=\"#随机访问存储器\" class=\"headerlink\" title=\"随机访问存储器\"></a>随机访问存储器</h5><p>随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM</p>\n<p>（1）静态（SRAM）</p>\n<p>SRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一</p>\n<p>（2）动态（DRAM）</p>\n<p>DRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复</p>\n<p>对比：</p>\n<p><img src=\"/img/深入理解计算机系统/SRAM和DRAM对比.PNG\" alt=\"SRAM和DRAM对比\"></p>\n<p>（3）传统的DRAM</p>\n<p>DRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。</p>\n<p>每个超单元存储一个字节</p>\n<p>(4)内存模块</p>\n<p>–DRAM芯片封装在内存模块中，插到主板的扩展槽上</p>\n<p>–内存地址A取值过程：</p>\n<p><img src=\"/img/深入理解计算机系统/6.1.1内存地址取值.PNG\" alt=\"6.1.1内存地址取值\"></p>\n<p>（5）增强的DRAM</p>\n<p>快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM</p>\n<p>（6）非易失性存储器</p>\n<p>ROM</p>\n<p>（7）访问主存</p>\n<p>总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线</p>\n<h5 id=\"磁盘存储\"><a href=\"#磁盘存储\" class=\"headerlink\" title=\"磁盘存储\"></a>磁盘存储</h5><p>磁盘读取时间计算：</p>\n<p><img src=\"/img/深入理解计算机系统/磁盘读取时间计算.PNG\" alt=\"磁盘读取时间计算\"></p>\n<h4 id=\"局部性\"><a href=\"#局部性\" class=\"headerlink\" title=\"局部性\"></a>局部性</h4><p>   (1)重复引用相同局部变量的程序具有良好的时间局部性</p>\n<p>（2）步长越小，空间局部性越好</p>\n<p>（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好</p>\n<h4 id=\"存储器层次结构-1\"><a href=\"#存储器层次结构-1\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h4><p>存储器层次结构</p>\n<p><img src=\"/img/深入理解计算机系统/存储器层次结构.PNG\" alt=\"存储器层次结构\"></p>\n<h4 id=\"高速缓存存储器\"><a href=\"#高速缓存存储器\" class=\"headerlink\" title=\"高速缓存存储器\"></a>高速缓存存储器</h4><p>缓存不命中：</p>\n<ul>\n<li><p>冷不命中（强制性不命中）：</p>\n<p>k层缓存有空行，程序最开始运行时均为冷不命中</p>\n</li>\n<li><p>冲突不命中</p>\n<p>k层中没有空行 </p>\n</li>\n<li><p>容量不命中</p>\n</li>\n</ul>\n<p>组相连高速缓存、组相连高速缓存、全相连高速缓存</p>\n<h4 id=\"编写高速缓存存储器\"><a href=\"#编写高速缓存存储器\" class=\"headerlink\" title=\"编写高速缓存存储器\"></a>编写高速缓存存储器</h4><p>写命中：</p>\n<p>直写：高速缓存中更新的数据立即写回到低一层中</p>\n<p>写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中</p>\n<p>写不命中：</p>\n<p>写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块</p>\n<p>非写分配：避开高速缓存，直接把这个字写到低一层中</p>\n<p>**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的</p>\n<h4 id=\"综合：高速缓存对程序性能的影响\"><a href=\"#综合：高速缓存对程序性能的影响\" class=\"headerlink\" title=\"综合：高速缓存对程序性能的影响\"></a>综合：高速缓存对程序性能的影响</h4><p>如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中</p>\n<h3 id=\"异常控制流\"><a href=\"#异常控制流\" class=\"headerlink\" title=\"异常控制流\"></a>异常控制流</h3><h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现</p>\n<p>（2）事件处理：</p>\n<p><img src=\"/img/深入理解计算机系统/8.1事件处理.PNG\" alt=\"8.1事件处理\"></p>\n<p>（3）异常分类</p>\n<p><img src=\"/img/深入理解计算机系统/异常分类.PNG\" alt=\"异常分类\"></p>\n<p><img src=\"/img/深入理解计算机系统/异常分类2.PNG\" alt=\"异常分类2\"></p>\n<h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><p>进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成</p>\n<p>进程提供的关键抽象：</p>\n<p>一个独立的逻辑控制流、一个私有的地址空间</p>\n<ul>\n<li><p>并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。</p>\n</li>\n<li><p>如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行</p>\n</li>\n<li><p>进程地址空间</p>\n<p><img src=\"/img/深入理解计算机系统/进程地址空间.PNG\" alt=\"进程地址空间\"></p>\n</li>\n<li><p>用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常</p>\n</li>\n<li><p>上下文切换：</p>\n<p>1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程</p>\n</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><ul>\n<li>进程的三种状态：</li>\n</ul>\n<p>运行：进程要么被执行，要么等待被执行且被内核调度</p>\n<p>停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号</p>\n<p>终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数</p>\n<ul>\n<li>父进程和子进程最大的区别是PID不同。</li>\n</ul>\n<p>fork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；</p>\n<ul>\n<li><p>子进程和父进程：</p>\n<p>1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件</p>\n</li>\n<li><p>pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1</p>\n</li>\n<li><p>unsigned int sleep(unsigned int secs)：返回还要休眠的秒数</p>\n</li>\n<li><p>int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号</p>\n</li>\n<li><p>execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。</p>\n</li>\n</ul>\n<h4 id=\"编写信号处理程序\"><a href=\"#编写信号处理程序\" class=\"headerlink\" title=\"编写信号处理程序\"></a>编写信号处理程序</h4><p>1、安全的信号处理</p>\n<p>（1）处理程序要尽可能的简单</p>\n<p>（2）在处理程序中只调用异步信号安全的函数</p>\n<p>（3）保存和恢复errno</p>\n<p>（4）阻塞所有信号，保护对共享数据结构的访问</p>\n<p>（5）用volatile声明全局变量</p>\n<p>（6）用sig_atomic_t声明标志</p>\n<p>2、正确的信号处理：未处理的信号不排队</p>\n<p>3、可移植的信号处理</p>\n<p>由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦—–</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>计算机的字长，是指针数据的位长，表明了虚拟地址空间的大小</p>\n</li>\n<li><p>ASCII字符构成的文件成为文本文件，其他所有文件都称为二进制文件</p>\n</li>\n<li><p>核心PC模型由指令集架构决定，操作围绕主存、寄存器文件、算术/逻辑单元ALU进行，进行加载、存储、操作、跳转等操作。</p>\n</li>\n<li><p>存储器层次结构的基本思想：上一层的存储器作为第一层存储器的高速缓存</p>\n</li>\n<li><p>操作系统的基本功能：1：防止硬件被失控 的应用程序滥用；2：向应用程序提供简单一致的机制来控制复杂而通常大而不同的低级硬件设备。 </p>\n</li>\n</ul>\n<h3 id=\"信息的表示和处理\"><a href=\"#信息的表示和处理\" class=\"headerlink\" title=\"信息的表示和处理\"></a>信息的表示和处理</h3><h4 id=\"信息存储\"><a href=\"#信息存储\" class=\"headerlink\" title=\"信息存储\"></a>信息存储</h4><ul>\n<li>信息：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数值：值   小数点  符号（三要素）</span><br><span class=\"line\"></span><br><span class=\"line\">非数值：文字 图像 视频 语言</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>软件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">系统软件：（用来管理整个计算机系统）</span><br><span class=\"line\"></span><br><span class=\"line\">语言处理程序  操作系统  服务型程序 数据\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t库管理系统 网络软件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计算机系统的层次结构：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>高级语言</th>\n<th>虚拟机器M3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>汇编语言</td>\n<td>虚拟机器M2</td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>虚拟机器</td>\n</tr>\n<tr>\n<td>机器语言</td>\n<td>实际机器M1</td>\n</tr>\n<tr>\n<td>微指令语言（时间)</td>\n<td>微程序机器M0</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>机器数（码）：原码 反码 移码  补码</p>\n</li>\n<li><p>数的逻辑：逻辑   算术（+ - * /） c语言中的数</p>\n</li>\n<li><p>逻辑运算符&amp;&amp;和||与对应的位级运算符&amp;和|第二个区别：</p>\n<p>如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：a&amp;&amp;5/a不会造成被零除，p&amp;&amp;*p++不会导致间接引用空指针 </p>\n</li>\n<li><p>集合的表示与运算</p>\n<ul>\n<li>表示：位向量表示有限集合</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg：<span class=\"number\">10100110</span>   从右到左表示 该集合=&#123;<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">5</span>，<span class=\"number\">7</span>&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>运算：&amp; 交集     |  并集    ^  对称差集    ~  补集                  </p>\n</li>\n<li><p>左移补0，但右移分为逻辑右移和算术右移，逻辑右移左端补0，算术右移左端补最高有效位的值。c语言对此没有区分，但大多数编译器对有符号数使用算术右移；无符号数右移必须是逻辑的 。Java对右移有明确的规定，x&gt;&gt;k表示x算术右移k个位置，x&gt;&gt;&gt;k表示逻辑右移</p>\n</li>\n</ul>\n<h4 id=\"整数表示\"><a href=\"#整数表示\" class=\"headerlink\" title=\"整数表示\"></a>整数表示</h4><h5 id=\"整数编码\"><a href=\"#整数编码\" class=\"headerlink\" title=\"整数编码\"></a>整数编码</h5><p>有符号数：补码</p>\n<p>B2T(X) = $-X_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}X_i2_i$</p>\n<p>例：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>10进制</th>\n<th>16进制</th>\n<th>2进制</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td>15213</td>\n<td>3B 6D</td>\n<td>0011011 01101101</td>\n</tr>\n<tr>\n<td>Y</td>\n<td>-15213</td>\n<td>C4 93</td>\n<td>1100100 10010011(最高位1表示负数)</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>原码</th>\n<th>反码</th>\n<th>补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n<td>0000 1011</td>\n</tr>\n<tr>\n<td>-11</td>\n<td>1000  1011</td>\n<td>1111 0100</td>\n<td>1111 0101</td>\n</tr>\n</tbody>\n</table>\n<p>注:负数的补码为反码加1,  正数的 原码、反码、补码都相同</p>\n<h5 id=\"知识细节\"><a href=\"#知识细节\" class=\"headerlink\" title=\"知识细节\"></a>知识细节</h5><ul>\n<li><p>有符号数同一表示形式下，负数的表示范围 比正数的范围大1  </p>\n<p>同一位数：补码的范围不对称，|TMin|=|TMax|+1；                                                                                                                                  同一位数：最大的无符号数比有符号数的两倍多1，即：UMax = 2TMax + 1​                </p>\n</li>\n<li><p>对于大多数C语言，处理同样字长的有符号数和无符号数规则：数值可能改变，但位模式不变</p>\n</li>\n</ul>\n<p>​    eg：short v = -12345;    unsigned short  uv = (unsigned short) v;     uv=53191  这里-12345的16位补码和53191的16位编码相同</p>\n<p>​    无符号数和有符号数之间的转换规则：T–&gt;U:补码转化为无符号数       U–&gt;T:无符号数转化为补码</p>\n<p>​    参与运算时，如果有无符号数出现在同一表达式，则有符号数强制转化为无符号数​                                                      </p>\n<ul>\n<li><p>扩展一个数字的位表示：无符号数零扩展，补码数(有符号数)符号扩展​                                                        </p>\n</li>\n<li><p>截断无符号数：丢弃高位取地位；  截断有符号数：截断后将最高位转化为符号位​                                                    </p>\n</li>\n</ul>\n<h4 id=\"整数运算\"><a href=\"#整数运算\" class=\"headerlink\" title=\"整数运算\"></a>整数运算</h4><h5 id=\"有符号数和无符号数转换的基本原则：\"><a href=\"#有符号数和无符号数转换的基本原则：\" class=\"headerlink\" title=\"有符号数和无符号数转换的基本原则：\"></a>有符号数和无符号数转换的基本原则：</h5><figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-<span class=\"ruby\">位模式不变</span></span><br><span class=\"line\"><span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\">-重新解读（按目标编码类型的规则解读）</span></span><br><span class=\"line\"><span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\">-会有意外的副作用：数值被 + 或 -$2^w$</span></span><br><span class=\"line\"><span class=\"ruby\"></span></span><br><span class=\"line\"><span class=\"ruby\">-当表达式中有符号数和无符号数混合时，有符号数转化为无符号数</span></span><br></pre></td></tr></table></figure>\n<p>加法:    无/有符号数的加法：正常加法后再截断，位级的运算相同</p>\n<p>​        无符号数：加后对$2^w$求模</p>\n<h5 id=\"符号位扩展\"><a href=\"#符号位扩展\" class=\"headerlink\" title=\"符号位扩展\"></a>符号位扩展</h5><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-无符号数：填充<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">-有符号位：符号扩展</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\teg：<span class=\"number\">-15213</span>    二进制：<span class=\"number\">11000100</span> <span class=\"number\">10010011</span>  ---&gt; <span class=\"number\">11111111</span> <span class=\"number\">11111111</span> <span class=\"number\">11000100</span> <span class=\"number\">10010011</span></span><br><span class=\"line\"></span><br><span class=\"line\">-结果都是明确的预期值</span><br></pre></td></tr></table></figure>\n<h5 id=\"截断\"><a href=\"#截断\" class=\"headerlink\" title=\"截断\"></a>截断</h5><figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-无论有无符号数，多出的位数都被截断</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-结果重新解读</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-无符号数: 相当于求模运算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-有符号数：和求模运算相似</span></span><br></pre></td></tr></table></figure>\n<p>​    -对于小整数，结果是明确的预期值</p>\n<h5 id=\"检测无符号数加法中的溢出：\"><a href=\"#检测无符号数加法中的溢出：\" class=\"headerlink\" title=\"检测无符号数加法中的溢出：\"></a>检测无符号数加法中的溢出：</h5><p>​    s =x+y,当且仅当s &lt; x(或等价的s &lt; y)时发生了溢出</p>\n<p>​    无符号数逆元（求反）：x=0时：-x=0</p>\n<p>​                   x &gt; 0时: -x = $2^w$</p>\n<h5 id=\"补码加法：\"><a href=\"#补码加法：\" class=\"headerlink\" title=\"补码加法：\"></a>补码加法：</h5><p>对于-$2^{w-1}\\le,y\\le2^{w-1}$-1的整数x和y，有<br>$$<br>\\begin{equation}x+^t_wy=\\begin{cases}x+y-2^w&amp; 2^{w-1}\\le{x+y} &amp; 正溢出\\x+y &amp; -2^{w-1}\\le{x+y}&lt;2^{w-1} &amp; 正常\\x+y+2^w &amp; x+y&lt;-2^{w-1} &amp; 负溢出\\end{cases}\\end{equation}<br>$$<br>​     对于满足TMi$n_w\\le$x,y$\\le$TMax$_w$的和y，令s=x+y,当且仅当x &gt; 0,y &gt; 0但s$\\le$0时发生了正溢出；当且仅当x &lt; 0,y &lt; 0但s$\\geq$0时发生了正溢出  </p>\n<h5 id=\"补码的非\"><a href=\"#补码的非\" class=\"headerlink\" title=\"补码的非\"></a>补码的非</h5><p>对满足$TMin_w\\le x\\le TMax_w$    的$x$，其补码的非$-^t_wx$由下式给出：<br>$$<br>\\begin{equation}-^t_wx=\\begin{cases}TMin_w&amp; x = TMin_w\\-x &amp; x&gt;TMin_w\\end{cases}\\end{equation}<br>$$<br>也就是说，对w位的补码加法来说，$TMin_w$是自己的加法的逆，而对其他的都有$-x$作为其加法的逆</p>\n<h5 id=\"补码非的位级表示\"><a href=\"#补码非的位级表示\" class=\"headerlink\" title=\"补码非的位级表示\"></a>补码非的位级表示</h5><p>​    方法一：对每一位求补，再对结果加1</p>\n<p>​    方法二：找到最右边的第一个1的位置，然后将该位置左边的所有为取反</p>\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><ul>\n<li>IEEE标准：</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数标准分类.PNG\" alt=\"浮点数标准分类\"></p>\n<ul>\n<li>浮点数规格化的值（frac、exp）</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"></p>\n<ul>\n<li><p>对于非规格化值：E=1-Bisas，M=f，不包括隐含的开头的1 <img src=\"/img/深入理解计算机系统/浮点数规格化的值.PNG\" alt=\"浮点数规格化的值\"> </p>\n</li>\n<li><p>舍入</p>\n</li>\n</ul>\n<p><img src=\"/img/深入理解计算机系统/浮点数舍入.PNG\" alt=\"浮点数舍入\"></p>\n<p>​    将float或double转化成int，值将向零舍入                    </p>\n<h3 id=\"程序的机器级表示\"><a href=\"#程序的机器级表示\" class=\"headerlink\" title=\"程序的机器级表示\"></a>程序的机器级表示</h3><h4 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h4><p>c数据类型的宽度</p>\n<table>\n<thead>\n<tr>\n<th>c数据类型</th>\n<th>32位</th>\n<th>64位</th>\n<th>x86-64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>long</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>-</td>\n<td>-</td>\n<td>10/16</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>4</td>\n<td>8</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"访问信息\"><a href=\"#访问信息\" class=\"headerlink\" title=\"访问信息\"></a>访问信息</h4><ul>\n<li><p>常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展到64位的值放大目的位置；</p>\n</li>\n<li><p>MOVZ类中的指令把目的中剩余的字节填充为0，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。</p>\n</li>\n</ul>\n<p>​    MOVZ类（零扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；</p>\n<p>​    MOVS类（符号扩展）的指令：以寄存器或地址内存作为源，以寄存器作为目的；cltq指令无操作数：只作用于%eax和%rax</p>\n<h4 id=\"算术和逻辑操作\"><a href=\"#算术和逻辑操作\" class=\"headerlink\" title=\"算术和逻辑操作\"></a>算术和逻辑操作</h4><p><img src=\"/img/深入理解计算机系统/算术和逻辑操作指令.PNG\" alt=\"算术和逻辑操作指令\"></p>\n<p>（1）leap指令目的操作数必须是寄存器</p>\n<p>（2）左移指令有两个：SAL和SHL，两者效果一样，都是右边补0；右移指令不同，SAR执行算术移位，补充符号位，而SHR执行逻辑移位，补充0</p>\n<p>（3）特殊的算术操作</p>\n<p><img src=\"/img/深入理解计算机系统/特殊的操作指令.PNG\" alt=\"特殊的操作指令\"></p>\n<p>有符号除法指令 idivl 将%rdx高64位和%rax低64位中的128位作为被除数，而除数作为指令的操作数给出。指令将商存储在%rax，余数存储在%rdx</p>\n<p>cqto指令可以不需要操作数，隐含读出%rax的符号位并将其复制到%rdx的每一位</p>\n<h4 id=\"控制\"><a href=\"#控制\" class=\"headerlink\" title=\"控制\"></a>控制</h4><p>（1）leaq指令不改变条件码</p>\n<p>（2）CMP指令和TEST指令只改变条件码，前者基于sub，后者基于and</p>\n<p>（3）条件码通常不会直接读取，常用使用方法：</p>\n<p>​    a、根据条件码的某种组合将一个字节设置为0或1（即set指令）</p>\n<p>​    b、条件跳转到程序的某个其他部分</p>\n<p>​    c、有条件的传送数据</p>\n<p>（4）set指令：</p>\n<p><img src=\"/img/深入理解计算机系统/set指令.PNG\" alt=\"set指令\"></p>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><p> （1）传递控制、传递数据、分配和释放内存</p>\n<p><img src=\"/img/深入理解计算机系统/栈结构.PNG\" alt=\"栈结构\"></p>\n<p>（2）调用函数前，把所有的参数都先存储，包括形参，存储完毕才开始调用函数</p>\n<p>（3）栈上的局部变量（局部数据必须用主存的情况)</p>\n<p>​    1）寄存器不足够存放所有的本地数据</p>\n<p>​    2）对一个局部变量使用取址符&amp;，因此必须为其产生一个地址</p>\n<p>​    3）某些局部变量是数组或结构，因此必须通过数组或结构引用访问到。</p>\n<p>注：寄存器是唯一被所有过程共享的资源</p>\n<h4 id=\"对抗缓冲区溢出\"><a href=\"#对抗缓冲区溢出\" class=\"headerlink\" title=\"对抗缓冲区溢出\"></a>对抗缓冲区溢出</h4><p>方法：1、栈随机化 ；2、栈破坏检测 ；3、限制可执行代码区域</p>\n<h4 id=\"过程中的浮点代码\"><a href=\"#过程中的浮点代码\" class=\"headerlink\" title=\"过程中的浮点代码\"></a>过程中的浮点代码</h4><ul>\n<li><p>XMM寄存器8xmn0~ 8xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。</p>\n</li>\n<li><p>函数使用寄存器%xmm0来返回浮点值。</p>\n</li>\n<li><p>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器<br>中任意一个。</p>\n<p>| 单精度 | 双精度 | 效果   | 描述                    |<br>| —— | —— | —— | ———————– |<br>| vxorps | vorpd  | D&lt;-x*y | 位级异或（EXCLUSIVE-OR) |<br>| vandps | andpd  | D&lt;-x&amp;y | 位级与（AND）           |</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>基于</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ucomiss x,y</td>\n<td>y-x</td>\n<td>比较单精度值</td>\n</tr>\n<tr>\n<td>ucomisd x,y</td>\n<td>y-x</td>\n<td>比较双精度值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"处理器体系结构\"><a href=\"#处理器体系结构\" class=\"headerlink\" title=\"处理器体系结构\"></a>处理器体系结构</h3><p>1、程序计数器PC保存当前正在执行指令的地址</p>\n<p>2、内存从概念上来说就是一个很大的字节数组，保存着程序和数据。Y86-64程序用虚拟地址来引用内存位置。硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址</p>\n<p>3、Y86-64每条指令需要1~10个字节不等，每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高四位是代码部分，低四位是指令部分。功能值只有在一组相关指令共用一个代码时才有用。</p>\n<p>4、指令集的一个重要性质就是每个字节编码必须有唯一的解释</p>\n<p>5、时钟寄存器：存储单个字：PC、条件代码和程序状态Stat                                                                                                                  随机访问存储器：存储多个字</p>\n<p>6、指令处理：</p>\n<p>取指、译码、执行、访存、写回、更新PC</p>\n<p>7、SEQ的实现包括组合逻辑和两种存储设备：时钟寄存器和随机访问寄存器。四个硬件单元对时序控制：程序计数器、条件码寄存器、数据内存和寄存器文件，通过时钟信号控制。</p>\n<p>8、组织原则：从不读回，即处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p>\n<p>9、每个周期开始前，状态单元（PC、条件码、数据内存、寄存器文件）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。</p>\n<h3 id=\"优化程序性能\"><a href=\"#优化程序性能\" class=\"headerlink\" title=\"优化程序性能\"></a>优化程序性能</h3><ul>\n<li><p>程序性能标准：每元素的周期数CPE</p>\n</li>\n<li><p>优化方法：</p>\n<p>1、消除循环低效率：代码移动：</p>\n<p>2、减少过程调用</p>\n<p>3、消除不必要的内存引用</p>\n<p>4、循环展开：减少迭代次数</p>\n<p>5、提高并行性：多个累计变量并行求、重新结合变换</p>\n</li>\n<li><p>课本总结：</p>\n<p>1）高级设计：算法和数据结构</p>\n<p>2）基本编码原则：</p>\n<ul>\n<li><p>消除连续的函数调用：将计算移动到循环外</p>\n</li>\n<li><p>消除不必要的内存引用：引用临时变量保存中间结果，最后结果得出才放入数组或全局变量</p>\n</li>\n</ul>\n<p>3）低级优化：</p>\n<ul>\n<li><p>展开循环，降低开销，并且使进一步优化成为可能</p>\n</li>\n<li><p>通过使用例如多个累积变量和重新结合等技术，提高指令集并行</p>\n</li>\n<li><p>用功能性的风格重写条件操作，使得编译采用条件数据传送</p>\n</li>\n</ul>\n</li>\n<li><p>限制因素：</p>\n<p>1、寄存器溢出</p>\n<p>2、分支预测错误和预测错误处罚：不过分关心可预测的分支、书写适合条件传送的代码</p>\n</li>\n</ul>\n<h3 id=\"存储器层次结构\"><a href=\"#存储器层次结构\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h3><h4 id=\"存储技术\"><a href=\"#存储技术\" class=\"headerlink\" title=\"存储技术\"></a>存储技术</h4><h5 id=\"随机访问存储器\"><a href=\"#随机访问存储器\" class=\"headerlink\" title=\"随机访问存储器\"></a>随机访问存储器</h5><p>随机访问存储器分（RAM）为两类：静态SRAM（更快）和动态DRAM</p>\n<p>（1）静态（SRAM）</p>\n<p>SRAM将每个位存储在一个双稳态的存储器单元，每个单元由一个六晶体管电路实现，可无限期保持在两个不同的电压配置或状态之一</p>\n<p>（2）动态（DRAM）</p>\n<p>DRAM将每个位存储为对一个电容的充电，对干扰敏感且不能恢复</p>\n<p>对比：</p>\n<p><img src=\"/img/深入理解计算机系统/SRAM和DRAM对比.PNG\" alt=\"SRAM和DRAM对比\"></p>\n<p>（3）传统的DRAM</p>\n<p>DRAM芯片中的单元（位）被分成d个超单元，每个超单元由w个DRAM单元组成，一个d*w的DRAM存储了dw位信息。超单元被组织成r行c列的矩阵，rc=d。</p>\n<p>每个超单元存储一个字节</p>\n<p>(4)内存模块</p>\n<p>–DRAM芯片封装在内存模块中，插到主板的扩展槽上</p>\n<p>–内存地址A取值过程：</p>\n<p><img src=\"/img/深入理解计算机系统/6.1.1内存地址取值.PNG\" alt=\"6.1.1内存地址取值\"></p>\n<p>（5）增强的DRAM</p>\n<p>快页模式DRAM、扩展数据输出DRAM、同步DRAM、双倍数据速率同步DRAM、视频RAM</p>\n<p>（6）非易失性存储器</p>\n<p>ROM</p>\n<p>（7）访问主存</p>\n<p>总线：能够携带地址、数据和控制信号，分为：系统总线和内存总线</p>\n<h5 id=\"磁盘存储\"><a href=\"#磁盘存储\" class=\"headerlink\" title=\"磁盘存储\"></a>磁盘存储</h5><p>磁盘读取时间计算：</p>\n<p><img src=\"/img/深入理解计算机系统/磁盘读取时间计算.PNG\" alt=\"磁盘读取时间计算\"></p>\n<h4 id=\"局部性\"><a href=\"#局部性\" class=\"headerlink\" title=\"局部性\"></a>局部性</h4><p>   (1)重复引用相同局部变量的程序具有良好的时间局部性</p>\n<p>（2）步长越小，空间局部性越好</p>\n<p>（3）对于取值指令，循环具有良好的时间和空间局部性，循环体越小，循环迭代次数越多，局部性越好</p>\n<h4 id=\"存储器层次结构-1\"><a href=\"#存储器层次结构-1\" class=\"headerlink\" title=\"存储器层次结构\"></a>存储器层次结构</h4><p>存储器层次结构</p>\n<p><img src=\"/img/深入理解计算机系统/存储器层次结构.PNG\" alt=\"存储器层次结构\"></p>\n<h4 id=\"高速缓存存储器\"><a href=\"#高速缓存存储器\" class=\"headerlink\" title=\"高速缓存存储器\"></a>高速缓存存储器</h4><p>缓存不命中：</p>\n<ul>\n<li><p>冷不命中（强制性不命中）：</p>\n<p>k层缓存有空行，程序最开始运行时均为冷不命中</p>\n</li>\n<li><p>冲突不命中</p>\n<p>k层中没有空行 </p>\n</li>\n<li><p>容量不命中</p>\n</li>\n</ul>\n<p>组相连高速缓存、组相连高速缓存、全相连高速缓存</p>\n<h4 id=\"编写高速缓存存储器\"><a href=\"#编写高速缓存存储器\" class=\"headerlink\" title=\"编写高速缓存存储器\"></a>编写高速缓存存储器</h4><p>写命中：</p>\n<p>直写：高速缓存中更新的数据立即写回到低一层中</p>\n<p>写回：尽可能推迟更新，当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中</p>\n<p>写不命中：</p>\n<p>写分配：加载相应的低一层的块到高速缓存中，然后更新这个高速缓存块</p>\n<p>非写分配：避开高速缓存，直接把这个字写到低一层中</p>\n<p>**直写高速缓存通常时写分配的，写回高速缓存通常是非写分配的</p>\n<h4 id=\"综合：高速缓存对程序性能的影响\"><a href=\"#综合：高速缓存对程序性能的影响\" class=\"headerlink\" title=\"综合：高速缓存对程序性能的影响\"></a>综合：高速缓存对程序性能的影响</h4><p>如果一个高速缓存的块大小为B字节，那么一个步长为k（字）的引用模式平均每次循环迭代会有min（1，（wordsize*k)/k））次缓存不命中</p>\n<h3 id=\"异常控制流\"><a href=\"#异常控制流\" class=\"headerlink\" title=\"异常控制流\"></a>异常控制流</h3><h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><p>（1）异常是控制流中的突变，用来响应处理器状态中的变化。是异常控制流的一种形式，一部分由硬件实现，一部分由操作系统实现</p>\n<p>（2）事件处理：</p>\n<p><img src=\"/img/深入理解计算机系统/8.1事件处理.PNG\" alt=\"8.1事件处理\"></p>\n<p>（3）异常分类</p>\n<p><img src=\"/img/深入理解计算机系统/异常分类.PNG\" alt=\"异常分类\"></p>\n<p><img src=\"/img/深入理解计算机系统/异常分类2.PNG\" alt=\"异常分类2\"></p>\n<h4 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h4><p>进程：一个执行中程序的实例。系统中每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成</p>\n<p>进程提供的关键抽象：</p>\n<p>一个独立的逻辑控制流、一个私有的地址空间</p>\n<ul>\n<li><p>并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流被称为并发的运行。多个流并发地执行一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此，多任务也叫时间分片。</p>\n</li>\n<li><p>如果两个流并发的运行在不同的处理器核或计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行</p>\n</li>\n<li><p>进程地址空间</p>\n<p><img src=\"/img/深入理解计算机系统/进程地址空间.PNG\" alt=\"进程地址空间\"></p>\n</li>\n<li><p>用户模式和内核模式：进程从用户模式切换到内核模式的唯一方式是异常</p>\n</li>\n<li><p>上下文切换：</p>\n<p>1）保存当前进程的上下文；  2）恢复某个先前被抢占的进程被保存的上下文； 3）将控制传递给这个新恢复的进程</p>\n</li>\n</ul>\n<h4 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h4><ul>\n<li>进程的三种状态：</li>\n</ul>\n<p>运行：进程要么被执行，要么等待被执行且被内核调度</p>\n<p>停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP 、SIGTSTP、SIGTTIN、SIGTOUT信号时，进程停止，并且保持到收到SIGCOUT信号</p>\n<p>终止：1）收到一个信号，该信号的默认行为是终止；2）从主程序返回；3）调用exit函数</p>\n<ul>\n<li>父进程和子进程最大的区别是PID不同。</li>\n</ul>\n<p>fork被调用一次，返回两次。一次是在父进程中，fork返回子进程的PID，一次是在新建的子进程中，返回0；</p>\n<ul>\n<li><p>子进程和父进程：</p>\n<p>1）fork函数调用一次，返回两次；2）子进程和父进程并发运行；3）相同但是独立的地址空间；4）共享文件</p>\n</li>\n<li><p>pid_t wait_pid(int *statusp) : 如果成功，返回子进程的PID；如果WNOHANG，返回0；如果其他错误，返回-1</p>\n</li>\n<li><p>unsigned int sleep(unsigned int secs)：返回还要休眠的秒数</p>\n</li>\n<li><p>int pause(void)：总是返回-1，让函数休眠，直到该进程接收到另一个信号</p>\n</li>\n<li><p>execve:在当前进程的上下文中加载并运行一个新程序，从不返回，（如果找不到filename，才会返回到调用程序）。</p>\n</li>\n</ul>\n<h4 id=\"编写信号处理程序\"><a href=\"#编写信号处理程序\" class=\"headerlink\" title=\"编写信号处理程序\"></a>编写信号处理程序</h4><p>1、安全的信号处理</p>\n<p>（1）处理程序要尽可能的简单</p>\n<p>（2）在处理程序中只调用异步信号安全的函数</p>\n<p>（3）保存和恢复errno</p>\n<p>（4）阻塞所有信号，保护对共享数据结构的访问</p>\n<p>（5）用volatile声明全局变量</p>\n<p>（6）用sig_atomic_t声明标志</p>\n<p>2、正确的信号处理：未处理的信号不排队</p>\n<p>3、可移植的信号处理</p>\n<p>由于本人有一丢丢懒~，漏掉的一些内容懒得更新，排版也只是凑合，还请大家原谅啦啦—–</p>\n"},{"title":"哈尔滨工业大学数据结构2018年秋期末复习","urlname":"hit_data_structure_review","mathjax":true,"description":"这里尽可能详细的记录了数据结构的知识点，如果能完全掌握这些知识点，期末考试基本哦了\\(^o^)/~","abbrlink":22353,"date":"2019-03-05T06:00:00.000Z","_content":"\n#### 绪论\n\n##### 抽象数据类型\n\n- 抽象数据类型:(Abstract Date Type)\n\n\t-定义：一个数学模型和该模型上定义的操作集合的总称\n\t\n\t*ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象\n\t\n\t*同一数学模型上定义的不同操作集，则他们代表不同的ADT\n\t\n\t-表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作\n\n- 逻辑结构：\n\n  集合——没关系\n\n  线性表——1:1前后\n\n  树——1：m层次\n\n  图——网状\n\n- 存储结构：\n\n  ​\t顺序——连续空间 \t\t $\\Rightarrow$索引\n\n  ​\t链式——不连续空间      \t+散列\n\n##### 算法及算法分析\n\n- 算法的相关概念\n\n\t-算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列\n\t\n\t-五大特性：输入   输出   有穷性   确定性\n\n- 时间复杂度（time  xomplexity)\n\n\t算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度\n\n- 常见时间复杂度的比较\n\n0(1)< <0(logn) <<0(n)< < 0(nlogn) << 0(n2) << 0(n3) <<0(2n) << 0(n!)\n\n- 常见设计方法：\n\n穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)\n\n$\\alpha -\\beta$裁剪和分支界限法、并行算法\n\n- 时空资源的折中原理\n\n同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质\n\n##### 逐步求精的程序设计方法\n\n​\t模型化-确定算法-逐步求精\t\n\n#### 线性表\n\n##### 线性表的抽象数据类型\n\n​\t 顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素\n\n##### 线性表的实现\n\n存储结构的三种方式：\n\n ① 连续的存储空间（数组） →  静态存储\n\n ② 非连续存储空间——指针（链表） →  动态存储\n\n ③ 游标（连续存储空间+动态管理思想）→  静态链表\n\n###### 线性表的数组实现：\n\n随机存储结构，查找快   o(1)\n\n插入和删除慢  o(n)\n\n空间固定\n\n###### 链表\n\n非随机存储结构\n\neg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2\n\n​\t求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走\n\n- 插入元素\n\n  a、保存后继指针\n\n  b、申请一个内存空间\n\n  c、插入：先链接后部分，再衔接前部分\n\n###### 游标\n\n元素是结构体数组，多个线性表公用一个存储池\n\n单链表逆置：\n\n```c\n//方法一：\n//设表头为L,算法如下: \np=L->next->next; q=p->next; L->next->next=NULL; while(p!=null) {\n    p->next=L->next;\n    L->next=p;\n    p=q;\n    q=q->next; \n}\n//方法二：\n//线性表由q来表示 \np=null; w=q; while(w!=null) { \n    w=w->next; \n    q->next=p;\n    p=q; q=w; \n}\n```\n\n###### 双向链表\n\n双向单链表插入与删除：\n\n![双向单链表](/img/ds/双向单链表.PNG)\n\n\n\n###### 环形链表\n\n- 数组求模可以成环\n\n- 判断链表是否成环：两个指针，速度分别为1和2,\n\n- 确定环入口：\n\n- 两个链表是否相交:判断两个列表最后一个元素是否相同//散列\n\n- 单项循环链表插入与删除：\n\n![双循环1](/img/ds/双循环1.PNG)\n\n\n\n![双循环2](/img/ds/双循环2.PNG)\n\n##### 栈\n\n- 多项式的代数运算\n\n<img src=\"/img/ds/中缀转后缀表达式.PNG\" height=400px>\n\n- 后缀表达式求值：\n\n  对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。\n\n##### 队列\n\n优先队列：\n\n问题：如何解决循环队列中队空与队满状态相同？\n方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；\n\n 方法二：另设一个标志位用以区别队空与队满两种状态；\n结论：两种方法的代价是相同的。\n\n##### 串（String）\n\nKMP算法：\n\n一、如何求next函数:\n\n- 当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 \n\n-  当j>1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。\n-   当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较\n\n下面给出求next函数的伪码：\n\n```c\nvoid get_next(SString T, int &next[]) {\n\n //求模式串T的next函数并存入next数组\n\n int i = 1; next[1] = 0; int j = 0;\n\n while (i < T[0]) //T[0]中存放数组长度 {\n\n if( j==0||T[i]==T[j]) { ++i; ++j;  next[i]=j; } \n\nelse j= next[j]; }\n\n }//get_next\n```\n\n二、KMP算法实现步骤：\n\n   1.在串S和串T中分别设比较的起始下标i和j；\n2. 循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕 \n   2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则 \n   2.2将j向右滑动到next[j]位置，即j=next[j]； \n   2.3 如果j=0，则将i和j分别加1，准备下一趟比较；\n3. 如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；\n\n##### 广义表\n\n例如：\n\n A = （a，（b，a，b），（），c，（（（2））））； \n\nB = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；\n\n长度：广义表LS中的直接元素的个数；\n深度：广义表LS中括号的最大嵌套层数。\n表头：广义表LS非空时，称第一个元素为LS的表头；\n表尾：广义表LS中除表头外其余元素组成的广义表。\n\n#### 树与二叉树\n\n##### 二叉树\n\n###### 性质：\n\n在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关\n\n###### 建立\n\n建立：\n\n![建立1](/img/ds/建立1.PNG)\n\n先序建立：\n\n![先序建立](/img/ds/先序建立.PNG)\n\n非递归建立：\n\n![建立非](/img/ds/建立非.PNG)\n\n###### 遍历\n\n- 先序递归：\n\n![先序](/img/ds/先序.PNG)\n\n- 先序非递归：\n\n1.栈s初始化； \n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 输出root->data;\n \t\t2.1.2 将指针root的值保存到栈中；\n​\t\t2.1.3 继续遍历root的左子树 \n​\t2.2 如果栈s不空，则\n​\t\t2.2.1 将栈顶元素弹出至root；\n​\t\t2.2.2 准备遍历root的右子树；\n\n- 中序非递归：\n\n1.栈s初始化； \n\n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 将指针root的值保存到栈中；\n \t\t2.1.2 继续遍历root的左子树 \n \t2.2 如果栈s不空，则\n \t\t2.2.1 将栈顶元素弹出至root；\n \t\t2.2.2 输出root->data; \n​\t\t2.2.3 准备遍历root的右子树\n\n- 后序非递归：\n\n1. 栈s初始化； \n2. 循环直到root为空且栈s为空 \n\t2.1 当root非空时循环\n\t​\t2.1.1 将root连同标志flag=1 入栈； \n\t​\t2.1.2 继续遍历root的左子树；\n\t2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点; \n\t2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；\n\n<img src=\"/img/ds/二叉树先序遍历.PNG\" height=400px>\n\n- 层序遍历：\n\n1. 队列Q初始化；\n2. 如果二叉树非空，将根指针入队；\n3. 循环直到队列Q为空\n   3.1 q=队列Q的队头元素出队；\n   3.2 访问结点q的数据域； \n   3.3 若结点q存在左孩子，则将左孩子指针入队； \n   3.4 若结点q存在右孩子，则将右孩子指针入队；\n\n###### 应用\n\n- 1、已知先序中序确定二叉树：\n\n遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，\n​\t如果栈为空，将下标 j 入栈；\n​\t否则，栈不为空：\n​\t\t如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈\n\n<img src=\"/img/ds/已知先序中序构二叉树.PNG\" height=450px>\n\n- 2、求二叉树任意两节点公共祖先：\n\n```c\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root) \n        return NULL;//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个\n    if (root == p || root == q) \n        return root;//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个\n    TreeNode *L = lowestCommonAncestor(root->left, p, q);//左子树中是否能最先找到p,q中的一个节点\n    TreeNode *R = lowestCommonAncestor(root->right, p, q);\n    if (L && R) \n        return root;  //如果当前节点左右节点都各找到一个，那么返回当前节点\n    return L ? L : R; //只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面\n    }\n```\n\n\n\n- 3、求二叉树宽度：\n\n```c\nint  front=-1,rear=-1,count=0,max=0,right\nif (T!=NULL) \n\tq[++rear]=T;max=1;right=rear; \nwhile(front!=rear) {\n\tT=q[++front];\n\tif(T->lc!=NULL)q[++rear]=T->lc; count++;\n\tif(T->rc!=NULL q[++rear]=T->rc; count++; \n\tif(front==right) { \n\t\tif(max<count)max=count; count=0;right=rear;}\n }\n```\n\n- 4、线索树：\n\n1）在中序线索二叉树中求一个结点p的中序后继p：\n\n​\t当p->rtag==False时，p->rchild 即为所求(线索)。\n\n \t当p->rtag==True时，p为p 的右子树的最左结点\n\n2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树\n\n```\nvoid ThInOrder(ThTree HEAD) {  \nThTree   tmp ; tmp = HEAD ; \n  do { \n  \ttmp = InNext ( tmp ) ; \n if ( tmp != HEAD ) visit ( tmp -> data ) ;\n} while ( tmp != HEAD ) ; }\n```\n\n  3）求中序线索二叉树中结点p 的先序顺序后继结点p* \n\n(1) p 的左子树不空时，p 的左儿子p->lchild 即为 p*；\n(2) p 的左子树空但右子树不空时，p 的p->rchild 为p*；\n(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.\n\n```\nTHTREE PreNext( ThTree p) {   \n\tThTree Q ;\n\tif (p->ltag = = True ) Q=p->lchild ; \n\telse{\n\t\tQ = p;\n\t\twhile(Q->rtag = = False) Q = Q->rchild ; \n\t\tQ = Q->rchild ;\n\t}  return ( Q ) ; \n```\n\n- 相似二叉树:具有相同结构的二叉树为相似二叉树。 \n\n- 相似且对应结点包含相同信息的二叉树称为等价二叉树。 \n\n##### 堆\n\n最大堆：\n\n如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆\n\n- 大根堆插入：\n\nvoid Insert ( Heap &heap，Elementtype x)//大根堆插入一个元素 { \n​\tint i; \n​\tif ( ! HeapFull ( heap ) ) { \n​\t\ti=heap.n+1; \n​\t\twhile ( (i!=1)&&(x >heap.ele [i/2] ) ) {  \n​\t\t\theap.ele [i]=heap.ele [i/2]; i=i/2;\n \t} heap.ele [i] = x;\n\n- 大根堆删除：\n\n\n\n```c\nvoid DeleteMax (Heap & heap )//大根堆删除 {  \n\tint parent=1, child=2;  Elementtype  ele,  tmp;\n\tif (! HeapEmpty(heap)) { \n\t\tele=heap.ele [1]; tmp=heap.ele [heap.n--];\n \t\twhile (child<= heap.n){\n\t\t\tif(child<heap.n)&&(heap.ele [child]<heap.ele [child+1])) \t\t\t\t\t\t\t\tchild++;\n\t\t\tif (tmp>=heap.ele [child])  break;\n\t\t\theap.ele [parent]=heap.ele [child]; \n\t\t\tparent=child; child*=2;\n\t\t}//while\n \t\theap.ele [parent]=tmp; return ele; \n\t}//if\n}\n```\n\n\n\n##### 选择树\n\n​\t胜者树、败者树\n\n##### 树\n\n存储结构：\n\n双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））\n\n|          | 树         | 二叉树       |\n| -------- | ---------- | ------------ |\n| 节点关系 | 兄弟关系   | 双亲和右孩子 |\n|          | 双亲和长子 | 双亲和左孩子 |\n\n##### 森林与二叉树的相互转换\n\n- 森林转化成二叉树：\n\n1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）\n\n 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 \n\n3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）\n\n- 二叉树转化成森林（树）\n\n连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；\n\n 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; \n\n旋转： 按逆时针旋转45度角（即把结点按层次排列）\n\n- 将一株树转换为二叉树，二叉树一定没有右子树\n-  一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；\n-  任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；\n\n- 森林(树)转换成二叉树的递归算法：\n\n F ={T1,T2, …,Tn}   \n二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则 \n B(F)的根就是root（T1）；\n B(F)的左子树是F的第一棵树T1的子树森林；\n B(F)的右子树F的其余子树森林。 \n\n- 二叉树转换成森林(树) 的递归算法 ：\n\n若B 为空，则F 为空；若B 不空，则\n F中的第一株树T1 的根对应二叉树B 的根； \n T1中根结点的子树森林F1是由B的左子树转换来的；\n F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。\n\n##### 树的应用\n\n- 堆的复杂度：O(n)\n\n- 败者树的复杂度：O(2n-1)\n\n###### 用树结构表示集合：\n\n等价分类算法： \n1. 令S中的每一个元素自身构成一个等价类，S1,S2,…S7 \n\n2. 重复读入等价对（i,  j） \n   2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性） \n   2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。\n\n```c\nvoid Equivalence (MFSET S)   //等价分类算法 { \n   int i ,j , k ,m; \n   for(i=1; i<=n+1;i++) Initial(i,S);  //使集合S只包含元素i\n   cin>>i>>j;        // 读入等价对\n   while(!(i==0&&j==0){ // 等价对未读完\n       k=Find(i,S);           //求i的根 \n       m=Find(j,S);        // 求j的根\n       if(k!=m)          //if k==m,i,j已在一个树中，不需合并 \n           Union(i,j,S);     //合并 \n       cin<<i<<j;            }  }\n```\n\n###### 判定树\n\n判定树的特点：\n\n 一个判定树是一个算法的描述； \n每个内部结点对应一个部分解； 每个叶子对应一个解； \n每个内部结点连接与一个获得新信息的测试；\n 从每个结点出发的分支标记着不同的测试结果；\n 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合\n\n判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$\n\n###### 哈夫曼树：\n\n- 内外路径：\n\n![内外路径](/img/ds/内外路径.PNG)\n\n- 哈夫曼树性质：\n\n没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。\n\n![哈夫曼树性质1](/img/ds/哈夫曼树性质1.PNG)\n\n- 码长计算：\n\n![码长计算](/img/ds/码长计算.PNG)\n\n- 哈夫曼编码一定具有前缀性；\n  哈夫曼编码是最小冗余码; \n  哈夫曼编码方法，使出现概率大的字符对应的码长较短；\n  哈夫曼编码不唯一，可以用于加密；\n  哈夫曼编码译码简单唯一，没有二义性.\n\n###### 表达式求值\n\n把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值\n\n 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。\n\n#### 图\n\n简单路径：若路径上各顶点 v1,v2,...,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。\n\n 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。\n\n##### 图的存储结构\n\n|          | 空间性能 | 时间性能 | 唯一性 |适用范围|\n| -------- | -------- | -------- | ------ |-----|\n| 邻接矩阵 | O(n^2)   | O(n^2)   |           唯一   |稠密图|\n| 邻接表   | O(n+e)   | O(n+e)   |          不唯一 |稀疏图|\n\n十字链表、邻接多重表\n\n##### 图的搜索\n\n- 深度优先搜索\n\n从一个顶点出发的一次深度优先遍历算法：\n实现步骤： \n1. 访问顶点v; visited[v]=1; \n2. w=顶点v的第一个邻接点； \n3.  while (w存在) \n    3.1 if (w未被访问) 从顶点w出发递归执行该算法; \n    3.2 w=顶点v的下一个邻接点;\n\n邻接矩阵：空间：O(n^2)       时间： O(n^2)\n\n邻接表：O(n)  O(V+E)\n\n\n\n- 广度优先搜索\n\n1 . 初始化队列Q;\n2. 访问顶点v; visited [v]=1; 顶点v入队Q;\n3. while (队列Q非空) \n    3.1 v=队列Q的队头元素出队;\n    3.2 w=顶点v的第一个邻接点;\n    3.3 while (w存在) \n       3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n       3.3.2 w=顶点v的下一个邻接点；\n\n##### 图与树、最小生成树\n\n###### 先深和先广生成森林\n\n- 先深搜索对边的分类 \n  两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;  \n  结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然\n- 先广搜索对边的分类 \n  两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.\n  结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然\n\n###### 无向图与开放树\n\n连通而无环路的无向图称作开放树（Free  Tree）\n\n（1）具有n≥1个顶点的开放树包含n-1条边； \n\n（2）如果在开放树中任意加上一条边，便得到一条回路\n\n###### 最小生成树算法\n\n- 普里姆Prim算法：\n\n基本思想 \n① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ } \n② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U \n③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树\n\n如何找到连接U和V-U的最短边 ：\n利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。\n\n1. 初始化两个辅助数组LOWCOST和CLOSEST；\n\n2. 输出顶点v0，将顶点v0加入集合U中；\n\n3. 重复执行下列操作n-1次\n   3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；\n   3.2 输出顶点k和对应的权值； \n   3.3 将顶点k加入集合U中； \n   3.4 调整数组LOWCOST和CLOSEST；\n\n   LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]} \n   CLOSEST[j]=k\n\n时间复杂度：O(n^2)\n\n- 克鲁斯卡尔（Kruskal）算法\n\n注：边值各不相同时生成树唯一\n\n基本思想：\n设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }， \n然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。 \n若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，\n如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。\n\n1. 初始化：U=V； TE={ }； \n2. 循环直到T中的连通分量个数为1  \n    2.1 在E中选择最短边(u，v); \n    2.2 如果顶点u、v位于T的两个不同连通分量，则 \n    ​\t2.2.1 将边(u，v)并入TE； \n    ​\t2.2.2 将这两个连通分量合为一个；\n    2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取\n\n时间复杂度：O(eloge)\n\n##### 无向图的双连通性\n\n若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。\n\n1、没有关节点的连通图称为双连通图。\n2、双连通的无向图是连通的，但连通的无向图未必双连通。\n3、一个连通的无向图是双连通的，当且仅当它没有关节点。  \n4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。 \n5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。\n\n- 由先深生成树可得出两类关节点的特性：\n\n 1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 \n\n2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来\n\n算法要点：\n 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。\n 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：\n (1)  dfn[v]；\n (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；\n (3)  low[y]，对v的任何儿子y。\n 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。\n\n```c\n//求双连通分量的算法 \nvoid main() { \ncount = 1; for (all v ∈ V)  mark v “new”; searchB( v0 );}\n\n//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)\nvoid searchB(v) { \nmark v “old”;\ndfn[v] = count;count++; \nlow[v]=dfn[v]; \n for (each w ∈ L[v])\n     if (w is marked “new”) { \n         father [w]=v；searchB (w); \n         low [v]= min { low [v], low [w] }; \n        if (low[w]>=dfn[v]) //表明W及子孙均无指向V的祖先的回退边，v是关节点                   \t\t\tcout<<“a biconnected component”; } \n    else if (w != father [v]) //(v ,w)是回退边   \n          low [v]= min { low [v],  dfn [w] };\n```\n\n\n\n##### 拓扑排序\n\n是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） \n\n实质：广度优先搜索算法\n\nAOV网（有向图）\n\n- 利用队列算法：\n  1.建立入度为零的顶点排队 \n  2.扫描顶点表，将入度为0的顶点入队；\n  3.while（排队不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入队 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n- 利用栈算法：\n  1.建立入度为零的顶点栈 \n  2.扫描顶点表，将入度为0的顶点栈；\n  3.while（栈不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入栈 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。\n\n- 说明：\n  与先广搜索的差别：\n  ​      搜索起点是入度为0的顶点；\n  ​      需判断是否有环路；\n  ​      需对访问并输出的顶点计数（引入计数器nodes）。\n  ​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。\n  也可以采用栈数据结构进行广度优先拓扑排序。 \n  亦可采用无后继顶点优先的拓扑排序算法\n  也可以利用DFS遍历进行拓扑排序\n- 基于DFS的拓扑排序\n\n```c\nvoid topodfs ( v ) {   \n    Push( v ,S ) ; \n    mark[v]=True; \n    for ( L[v] 中的每一个顶点w) \n        if ( mark[w] = False ) topodfs ( w ) ; \n    printf ( Top( S ) ) ; \n    Pop ( S ) ; \n}\n\nvoid  dfs-topo ( GRAPH  L ) {  \n    MakeNull( S ); \n    for( u=1;u<=n; u++) \n        mark[u]=False; \n    for( u=1;u<=n;u++) \n        if ( !mark[u] ) \n            topodfs( u ) ; \n```\n\n思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。\n\n##### 关键路径\n\nAOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）\n\n最大长度的路径称为关键路径。 \n一个AOE中，关键路径可能不只一条。\n关键活动：关键路径上的活动称为关键活动。\n\n关键路径算法步骤：\n\n（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}\n其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）\n\n（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }\n其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S\n\n（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 \n\n（４）若某条边满足E( i ) = L( i )，则它是关键活动。\n\n注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。\n\n##### 最短路径\n\n- 边上权值非负情形的单源最短路径问题 — Dijkstra算法 \n\nDijkstra算法实现步骤：\n1. 将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。\n2. 从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。\n3. 调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 \n4. 重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。\n\n```c\ncosttype MinCost (D, S) { \ntemp = INFINITY ; w = 2 ;\nfor ( i=2 ; i<=n ; i++ )\n\tif (!S[i]&&D[i]<temp)  {\n  \t\ttemp = D[i] ; w = i ; } \nreturn  w ; }\n\nvoid  Dijkstra(GRAPH  C, costtype D[n+1] ，int P[n+1]，bool S[n+1]) { \nfor ( i=2 ; i<=n; i++ ) {  \n\tD[i]=C[1】[i】 ; S[i]=False ;P[i]=1;}\nS [1]= True ; \nfor( i=1; i<=n-1; i++) {  \n\tw=MinCost ( D, S ) ; S[w]=True ; \n\tfor ( v=2 ; v<= n ; n++ ) \n\t\tif ( S[v]!=True ) {  \n        \t        sum=D[w] + C[w】[v】 ;\n \t\t\tif (sum < D[v】 ){D[v】 = sum ; P[v]=w;}\n\t\t} } }//   时间复杂度：O（n^2）\n```\n\n\n\n- 所有顶点之间的最短路径问题 — Floyd算法 \n\n基本思想：动态规划\n\n求解过程：\n\n设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i ---> j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞\n\n 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] \n\n2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。\n\n```c\nvoid Floyd( costtype A[][], costtype C[][], int P[][], int n) {   \nfor ( i = 0; i < n; i++ )\n\tfor ( j = 0; j< n; j++ ) {\n\t\tA[i][j] = C[i][j];  P[i][j] = -1； }\nfor ( k = 0; k < n; k++ ) \n\tfor ( i = 0; i < n; i++ ) \n\t\tfor ( j = 0; j < n; j++ )\n\t\t\tif ( A[i][k] + A[k][j] < A[i][j] ) \t\t\t\t{ A[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;} \n} /* 时间复杂度：O(n3) */\nWarshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]) ; 可以判定有向图任意两点间是否存在有向 路。\n```\n\n#### 查找\n\n##### 线性查找\n\n插入和删除：从后往前\n\n第0个元素做为伪记录或哨兵 \n\n##### 折半查找\n\n折半查找只适合于静态查找\n\n- 数组：时间复杂度O(logn)\n\n- 判定树:\n\n高度： (n+1)/nlog2(n+1)-1\n\n当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近\n\n##### 分块查找\n\n基本思想：均匀分块，块间有序，块内无序\n\n索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.\n\n块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j \n\n所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。\n\n##### BST-二叉查找树\n\n- 插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. \n\n- 删除：\n\n1. 若结点p是叶子，则直接删除结点p； \n2. 若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； \n3. 若结点p的左右子树均不空，则 \n    3.1 查找结点p的右子树上的最左下结点s及其双亲结点par； \n    3.2 将结点s数据域替换到被删结点p的数据域； \n    3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上； \n    3.4 删除结点s；\n\n- 性能：\n\n二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。\n\n 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。\n\n 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) \n\n就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。\n\n##### AVL树\n\nAVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。 \n令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。\n因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）\nFh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1 \n所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2 \n因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)\n\n##### B-树和B+树\n\n- B-树\n\n树中可容纳结点数量最大值，关键字个数最多：m^h-1\n\n树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；\n\n 除根结点和失败结点外，所有结点至少有 m/2 棵子树； \n\n所有的终端结点和叶子结点（失败结点）都位于同一层。\n\nh 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)\n\n关键字个数N：N +1 = 位于第 h+1 层的结点数 >= 2 *(m / 2)^ (h -1)\n\nN+1>= 2 *(m / 2)^ (h -1)  ;    h-1 <= log(m / 2)(( N + 1 ) / 2 ) \n\n- B+树\n\n(1) 有k个子结点的结点必然有k个关键字；\n\n (2)所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。\n3阶B+树\n（3）所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。\n通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。\n\n（4）可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。\n\n##### 散列\n\n不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词\n\n散列函数的构造的原则： 计算简单、分布均匀\n\n- 构造方法：\n  直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、\n\n- 冲突处理：\n\n1、开放定址法：\n--线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               --线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…） \n--二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2） \n--随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） \n\n2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高\n\n3、拉链法\\链地址法：\n\n#### 内部排序\n\n##### 气泡排序\n\n最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； \n\n最坏情况（反序）： 比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2         时间复杂度： O(n^2)\n\n平均情况：时间复杂度为O(n^2)  \n\n空间复杂度： O(1)\n\n##### 快速排序\n\n对气泡排序的改进\n\n最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)\n\n最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)\n\n平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)\n\n##### 直接选择排序\n\n移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次\n\n比较次数：n(n-1)/2\n\n时间复杂度为O(n^2)\n\n 空间复杂度为O(1)\n\n##### 堆排序\n\n对直接选择排序的改进\n\n首先将待排序的记录序列用完全二叉树表示；\n然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；\n最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。\n\n堆排序：令i = n, n-1 ,…, 2 \n\n1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])； \n2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)； \n3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(1)\n\n##### （直接）插入排序\n\n最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)\n\n最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)\n\n最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)\n\n##### 希尔排序\n\n对直接插入排序的改进\n\n时间性能：在O(n^2)和O(nlog2n)之间。\n\n当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) \n\n##### (二路)归并排序\n\n基本思想：自底向上的非递归算法\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(n)\n\n##### 基数排序--多关键字排序\n\n次序：从最低位排序，使用了队列\n\n改进：桶----链式排队\n\n时间复杂度：O(d(n+r))    （n---记录数，d----关键字(分量)个数，r----基数）\n\n空间复杂度：O((n+r)) \n\n##### 计数排序\n\n数组记录对应关键字出现的最后一个位置\n\n##### 总结：\n\n| 排序方法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性举例 |\n| --------- | -------- | -------- | -------- | -------- | ---------- |\n| 冒泡     | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 快排     | O(nlog2n) | O(nlog2n) | O(n^2) | O(log2n)~O(n) | 否/2,2,1 |\n| 直接选择 | O(n^2) | O(n^2) | O(n^2) | O(1) | 否/2,2,1 |\n| 堆排序   | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(1) | 否/1,2,2(最小堆) |\n| 直接插入 | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 希尔排序 | O(nlog2n) | O(n^1.3) | O(n^2) | O(1) | 否/3,2,2(d=2/1) |\n| 二路归并 | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(n) | 是 |\n| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(n+r) | 是 |\n\n最坏：\n\n 气泡排序：比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2  \n\n选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   \n\n插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)\n\n#### 七、外排序\n\n#####  磁盘文件的归并排序\n\n方法：多路归并 、 I/O并行处理  、生成初始归并段\n\n- 磁盘文件的归并排序\n\n第一阶段：初始归并段形成 \n\n第二阶段：多路归并 \n\n- 多路归并-减少归并遍数\n\n一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。\n\n在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）*(K-1)*[logkm]=（n-1）*(K-1) *[log2(m/log2K)]\n\n- K 路平衡归并与选择树\n\n第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) \n\n而后每次重新建造选择树所需时间为： O( log2k ) \n\nn 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间：                                    O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 \n\n归并遍数为 logkm，总时间为：                                                                                             O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )\n\n- 并行操作的缓冲区处理\n\n  ​\t\t\t\t\t-------使输入、输出和CPU处理尽可能重叠\n\n对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作\n\n- 生成初始归并段（使用选择树法）：多路平衡归并\n\n假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：\n(1) 从FI输入P个记录到缓冲区W;\n(2)从W中选择出关键字最小的记录MIN；\n(3)将MIN记录输出到FO中去；\n(4)若FI不空，则从FI输入下一个记录到W; \n(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN; \n(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中\n(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段\n\n生成的初始归并段的平均长度是缓冲区长度的两倍\n\n最佳归并树：使外存读写次数最少，是一棵正则树\n\n对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1\n\n\n\n加入细节点：\n\n- 已知前序和后序不能确定唯一二叉树\n- //判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号\n- 树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树\n\n- 解决冲突的方法：线性再散列、内散列表、外散列表\n\n- 左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针\n\n- 折半查找树高度： (n+1)/nlog2(n+1)-1","source":"_posts/数据结构与算法.md","raw":"---\ntitle: 哈尔滨工业大学数据结构2018年秋期末复习\nurlname: hit_data_structure_review\nmathjax: true\ntags:\n  - 数据结构\n  - 期末复习\ndescription: 这里尽可能详细的记录了数据结构的知识点，如果能完全掌握这些知识点，期末考试基本哦了\\(^o^)/~\nabbrlink: 22353\ndate: 2019-03-05 14:00:00\n---\n\n#### 绪论\n\n##### 抽象数据类型\n\n- 抽象数据类型:(Abstract Date Type)\n\n\t-定义：一个数学模型和该模型上定义的操作集合的总称\n\t\n\t*ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象\n\t\n\t*同一数学模型上定义的不同操作集，则他们代表不同的ADT\n\t\n\t-表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作\n\n- 逻辑结构：\n\n  集合——没关系\n\n  线性表——1:1前后\n\n  树——1：m层次\n\n  图——网状\n\n- 存储结构：\n\n  ​\t顺序——连续空间 \t\t $\\Rightarrow$索引\n\n  ​\t链式——不连续空间      \t+散列\n\n##### 算法及算法分析\n\n- 算法的相关概念\n\n\t-算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列\n\t\n\t-五大特性：输入   输出   有穷性   确定性\n\n- 时间复杂度（time  xomplexity)\n\n\t算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度\n\n- 常见时间复杂度的比较\n\n0(1)< <0(logn) <<0(n)< < 0(nlogn) << 0(n2) << 0(n3) <<0(2n) << 0(n!)\n\n- 常见设计方法：\n\n穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)\n\n$\\alpha -\\beta$裁剪和分支界限法、并行算法\n\n- 时空资源的折中原理\n\n同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质\n\n##### 逐步求精的程序设计方法\n\n​\t模型化-确定算法-逐步求精\t\n\n#### 线性表\n\n##### 线性表的抽象数据类型\n\n​\t 顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素\n\n##### 线性表的实现\n\n存储结构的三种方式：\n\n ① 连续的存储空间（数组） →  静态存储\n\n ② 非连续存储空间——指针（链表） →  动态存储\n\n ③ 游标（连续存储空间+动态管理思想）→  静态链表\n\n###### 线性表的数组实现：\n\n随机存储结构，查找快   o(1)\n\n插入和删除慢  o(n)\n\n空间固定\n\n###### 链表\n\n非随机存储结构\n\neg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2\n\n​\t求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走\n\n- 插入元素\n\n  a、保存后继指针\n\n  b、申请一个内存空间\n\n  c、插入：先链接后部分，再衔接前部分\n\n###### 游标\n\n元素是结构体数组，多个线性表公用一个存储池\n\n单链表逆置：\n\n```c\n//方法一：\n//设表头为L,算法如下: \np=L->next->next; q=p->next; L->next->next=NULL; while(p!=null) {\n    p->next=L->next;\n    L->next=p;\n    p=q;\n    q=q->next; \n}\n//方法二：\n//线性表由q来表示 \np=null; w=q; while(w!=null) { \n    w=w->next; \n    q->next=p;\n    p=q; q=w; \n}\n```\n\n###### 双向链表\n\n双向单链表插入与删除：\n\n![双向单链表](/img/ds/双向单链表.PNG)\n\n\n\n###### 环形链表\n\n- 数组求模可以成环\n\n- 判断链表是否成环：两个指针，速度分别为1和2,\n\n- 确定环入口：\n\n- 两个链表是否相交:判断两个列表最后一个元素是否相同//散列\n\n- 单项循环链表插入与删除：\n\n![双循环1](/img/ds/双循环1.PNG)\n\n\n\n![双循环2](/img/ds/双循环2.PNG)\n\n##### 栈\n\n- 多项式的代数运算\n\n<img src=\"/img/ds/中缀转后缀表达式.PNG\" height=400px>\n\n- 后缀表达式求值：\n\n  对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。\n\n##### 队列\n\n优先队列：\n\n问题：如何解决循环队列中队空与队满状态相同？\n方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；\n\n 方法二：另设一个标志位用以区别队空与队满两种状态；\n结论：两种方法的代价是相同的。\n\n##### 串（String）\n\nKMP算法：\n\n一、如何求next函数:\n\n- 当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 \n\n-  当j>1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。\n-   当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较\n\n下面给出求next函数的伪码：\n\n```c\nvoid get_next(SString T, int &next[]) {\n\n //求模式串T的next函数并存入next数组\n\n int i = 1; next[1] = 0; int j = 0;\n\n while (i < T[0]) //T[0]中存放数组长度 {\n\n if( j==0||T[i]==T[j]) { ++i; ++j;  next[i]=j; } \n\nelse j= next[j]; }\n\n }//get_next\n```\n\n二、KMP算法实现步骤：\n\n   1.在串S和串T中分别设比较的起始下标i和j；\n2. 循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕 \n   2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则 \n   2.2将j向右滑动到next[j]位置，即j=next[j]； \n   2.3 如果j=0，则将i和j分别加1，准备下一趟比较；\n3. 如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；\n\n##### 广义表\n\n例如：\n\n A = （a，（b，a，b），（），c，（（（2））））； \n\nB = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；\n\n长度：广义表LS中的直接元素的个数；\n深度：广义表LS中括号的最大嵌套层数。\n表头：广义表LS非空时，称第一个元素为LS的表头；\n表尾：广义表LS中除表头外其余元素组成的广义表。\n\n#### 树与二叉树\n\n##### 二叉树\n\n###### 性质：\n\n在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关\n\n###### 建立\n\n建立：\n\n![建立1](/img/ds/建立1.PNG)\n\n先序建立：\n\n![先序建立](/img/ds/先序建立.PNG)\n\n非递归建立：\n\n![建立非](/img/ds/建立非.PNG)\n\n###### 遍历\n\n- 先序递归：\n\n![先序](/img/ds/先序.PNG)\n\n- 先序非递归：\n\n1.栈s初始化； \n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 输出root->data;\n \t\t2.1.2 将指针root的值保存到栈中；\n​\t\t2.1.3 继续遍历root的左子树 \n​\t2.2 如果栈s不空，则\n​\t\t2.2.1 将栈顶元素弹出至root；\n​\t\t2.2.2 准备遍历root的右子树；\n\n- 中序非递归：\n\n1.栈s初始化； \n\n2.循环直到root为空且栈s为空 \n​\t2.1 当root不空时循环 \n​\t\t2.1.1 将指针root的值保存到栈中；\n \t\t2.1.2 继续遍历root的左子树 \n \t2.2 如果栈s不空，则\n \t\t2.2.1 将栈顶元素弹出至root；\n \t\t2.2.2 输出root->data; \n​\t\t2.2.3 准备遍历root的右子树\n\n- 后序非递归：\n\n1. 栈s初始化； \n2. 循环直到root为空且栈s为空 \n\t2.1 当root非空时循环\n\t​\t2.1.1 将root连同标志flag=1 入栈； \n\t​\t2.1.2 继续遍历root的左子树；\n\t2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点; \n\t2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；\n\n<img src=\"/img/ds/二叉树先序遍历.PNG\" height=400px>\n\n- 层序遍历：\n\n1. 队列Q初始化；\n2. 如果二叉树非空，将根指针入队；\n3. 循环直到队列Q为空\n   3.1 q=队列Q的队头元素出队；\n   3.2 访问结点q的数据域； \n   3.3 若结点q存在左孩子，则将左孩子指针入队； \n   3.4 若结点q存在右孩子，则将右孩子指针入队；\n\n###### 应用\n\n- 1、已知先序中序确定二叉树：\n\n遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，\n​\t如果栈为空，将下标 j 入栈；\n​\t否则，栈不为空：\n​\t\t如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈\n\n<img src=\"/img/ds/已知先序中序构二叉树.PNG\" height=450px>\n\n- 2、求二叉树任意两节点公共祖先：\n\n```c\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root) \n        return NULL;//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个\n    if (root == p || root == q) \n        return root;//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个\n    TreeNode *L = lowestCommonAncestor(root->left, p, q);//左子树中是否能最先找到p,q中的一个节点\n    TreeNode *R = lowestCommonAncestor(root->right, p, q);\n    if (L && R) \n        return root;  //如果当前节点左右节点都各找到一个，那么返回当前节点\n    return L ? L : R; //只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面\n    }\n```\n\n\n\n- 3、求二叉树宽度：\n\n```c\nint  front=-1,rear=-1,count=0,max=0,right\nif (T!=NULL) \n\tq[++rear]=T;max=1;right=rear; \nwhile(front!=rear) {\n\tT=q[++front];\n\tif(T->lc!=NULL)q[++rear]=T->lc; count++;\n\tif(T->rc!=NULL q[++rear]=T->rc; count++; \n\tif(front==right) { \n\t\tif(max<count)max=count; count=0;right=rear;}\n }\n```\n\n- 4、线索树：\n\n1）在中序线索二叉树中求一个结点p的中序后继p：\n\n​\t当p->rtag==False时，p->rchild 即为所求(线索)。\n\n \t当p->rtag==True时，p为p 的右子树的最左结点\n\n2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树\n\n```\nvoid ThInOrder(ThTree HEAD) {  \nThTree   tmp ; tmp = HEAD ; \n  do { \n  \ttmp = InNext ( tmp ) ; \n if ( tmp != HEAD ) visit ( tmp -> data ) ;\n} while ( tmp != HEAD ) ; }\n```\n\n  3）求中序线索二叉树中结点p 的先序顺序后继结点p* \n\n(1) p 的左子树不空时，p 的左儿子p->lchild 即为 p*；\n(2) p 的左子树空但右子树不空时，p 的p->rchild 为p*；\n(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.\n\n```\nTHTREE PreNext( ThTree p) {   \n\tThTree Q ;\n\tif (p->ltag = = True ) Q=p->lchild ; \n\telse{\n\t\tQ = p;\n\t\twhile(Q->rtag = = False) Q = Q->rchild ; \n\t\tQ = Q->rchild ;\n\t}  return ( Q ) ; \n```\n\n- 相似二叉树:具有相同结构的二叉树为相似二叉树。 \n\n- 相似且对应结点包含相同信息的二叉树称为等价二叉树。 \n\n##### 堆\n\n最大堆：\n\n如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆\n\n- 大根堆插入：\n\nvoid Insert ( Heap &heap，Elementtype x)//大根堆插入一个元素 { \n​\tint i; \n​\tif ( ! HeapFull ( heap ) ) { \n​\t\ti=heap.n+1; \n​\t\twhile ( (i!=1)&&(x >heap.ele [i/2] ) ) {  \n​\t\t\theap.ele [i]=heap.ele [i/2]; i=i/2;\n \t} heap.ele [i] = x;\n\n- 大根堆删除：\n\n\n\n```c\nvoid DeleteMax (Heap & heap )//大根堆删除 {  \n\tint parent=1, child=2;  Elementtype  ele,  tmp;\n\tif (! HeapEmpty(heap)) { \n\t\tele=heap.ele [1]; tmp=heap.ele [heap.n--];\n \t\twhile (child<= heap.n){\n\t\t\tif(child<heap.n)&&(heap.ele [child]<heap.ele [child+1])) \t\t\t\t\t\t\t\tchild++;\n\t\t\tif (tmp>=heap.ele [child])  break;\n\t\t\theap.ele [parent]=heap.ele [child]; \n\t\t\tparent=child; child*=2;\n\t\t}//while\n \t\theap.ele [parent]=tmp; return ele; \n\t}//if\n}\n```\n\n\n\n##### 选择树\n\n​\t胜者树、败者树\n\n##### 树\n\n存储结构：\n\n双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））\n\n|          | 树         | 二叉树       |\n| -------- | ---------- | ------------ |\n| 节点关系 | 兄弟关系   | 双亲和右孩子 |\n|          | 双亲和长子 | 双亲和左孩子 |\n\n##### 森林与二叉树的相互转换\n\n- 森林转化成二叉树：\n\n1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）\n\n 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 \n\n3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）\n\n- 二叉树转化成森林（树）\n\n连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；\n\n 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; \n\n旋转： 按逆时针旋转45度角（即把结点按层次排列）\n\n- 将一株树转换为二叉树，二叉树一定没有右子树\n-  一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；\n-  任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；\n\n- 森林(树)转换成二叉树的递归算法：\n\n F ={T1,T2, …,Tn}   \n二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则 \n B(F)的根就是root（T1）；\n B(F)的左子树是F的第一棵树T1的子树森林；\n B(F)的右子树F的其余子树森林。 \n\n- 二叉树转换成森林(树) 的递归算法 ：\n\n若B 为空，则F 为空；若B 不空，则\n F中的第一株树T1 的根对应二叉树B 的根； \n T1中根结点的子树森林F1是由B的左子树转换来的；\n F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。\n\n##### 树的应用\n\n- 堆的复杂度：O(n)\n\n- 败者树的复杂度：O(2n-1)\n\n###### 用树结构表示集合：\n\n等价分类算法： \n1. 令S中的每一个元素自身构成一个等价类，S1,S2,…S7 \n\n2. 重复读入等价对（i,  j） \n   2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性） \n   2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。\n\n```c\nvoid Equivalence (MFSET S)   //等价分类算法 { \n   int i ,j , k ,m; \n   for(i=1; i<=n+1;i++) Initial(i,S);  //使集合S只包含元素i\n   cin>>i>>j;        // 读入等价对\n   while(!(i==0&&j==0){ // 等价对未读完\n       k=Find(i,S);           //求i的根 \n       m=Find(j,S);        // 求j的根\n       if(k!=m)          //if k==m,i,j已在一个树中，不需合并 \n           Union(i,j,S);     //合并 \n       cin<<i<<j;            }  }\n```\n\n###### 判定树\n\n判定树的特点：\n\n 一个判定树是一个算法的描述； \n每个内部结点对应一个部分解； 每个叶子对应一个解； \n每个内部结点连接与一个获得新信息的测试；\n 从每个结点出发的分支标记着不同的测试结果；\n 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合\n\n判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$\n\n###### 哈夫曼树：\n\n- 内外路径：\n\n![内外路径](/img/ds/内外路径.PNG)\n\n- 哈夫曼树性质：\n\n没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。\n\n![哈夫曼树性质1](/img/ds/哈夫曼树性质1.PNG)\n\n- 码长计算：\n\n![码长计算](/img/ds/码长计算.PNG)\n\n- 哈夫曼编码一定具有前缀性；\n  哈夫曼编码是最小冗余码; \n  哈夫曼编码方法，使出现概率大的字符对应的码长较短；\n  哈夫曼编码不唯一，可以用于加密；\n  哈夫曼编码译码简单唯一，没有二义性.\n\n###### 表达式求值\n\n把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值\n\n 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。\n\n#### 图\n\n简单路径：若路径上各顶点 v1,v2,...,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。\n\n 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。\n\n##### 图的存储结构\n\n|          | 空间性能 | 时间性能 | 唯一性 |适用范围|\n| -------- | -------- | -------- | ------ |-----|\n| 邻接矩阵 | O(n^2)   | O(n^2)   |           唯一   |稠密图|\n| 邻接表   | O(n+e)   | O(n+e)   |          不唯一 |稀疏图|\n\n十字链表、邻接多重表\n\n##### 图的搜索\n\n- 深度优先搜索\n\n从一个顶点出发的一次深度优先遍历算法：\n实现步骤： \n1. 访问顶点v; visited[v]=1; \n2. w=顶点v的第一个邻接点； \n3.  while (w存在) \n    3.1 if (w未被访问) 从顶点w出发递归执行该算法; \n    3.2 w=顶点v的下一个邻接点;\n\n邻接矩阵：空间：O(n^2)       时间： O(n^2)\n\n邻接表：O(n)  O(V+E)\n\n\n\n- 广度优先搜索\n\n1 . 初始化队列Q;\n2. 访问顶点v; visited [v]=1; 顶点v入队Q;\n3. while (队列Q非空) \n    3.1 v=队列Q的队头元素出队;\n    3.2 w=顶点v的第一个邻接点;\n    3.3 while (w存在) \n       3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n       3.3.2 w=顶点v的下一个邻接点；\n\n##### 图与树、最小生成树\n\n###### 先深和先广生成森林\n\n- 先深搜索对边的分类 \n  两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;  \n  结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然\n- 先广搜索对边的分类 \n  两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.\n  结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然\n\n###### 无向图与开放树\n\n连通而无环路的无向图称作开放树（Free  Tree）\n\n（1）具有n≥1个顶点的开放树包含n-1条边； \n\n（2）如果在开放树中任意加上一条边，便得到一条回路\n\n###### 最小生成树算法\n\n- 普里姆Prim算法：\n\n基本思想 \n① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ } \n② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U \n③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树\n\n如何找到连接U和V-U的最短边 ：\n利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。\n\n1. 初始化两个辅助数组LOWCOST和CLOSEST；\n\n2. 输出顶点v0，将顶点v0加入集合U中；\n\n3. 重复执行下列操作n-1次\n   3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；\n   3.2 输出顶点k和对应的权值； \n   3.3 将顶点k加入集合U中； \n   3.4 调整数组LOWCOST和CLOSEST；\n\n   LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]} \n   CLOSEST[j]=k\n\n时间复杂度：O(n^2)\n\n- 克鲁斯卡尔（Kruskal）算法\n\n注：边值各不相同时生成树唯一\n\n基本思想：\n设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }， \n然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。 \n若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，\n如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。\n\n1. 初始化：U=V； TE={ }； \n2. 循环直到T中的连通分量个数为1  \n    2.1 在E中选择最短边(u，v); \n    2.2 如果顶点u、v位于T的两个不同连通分量，则 \n    ​\t2.2.1 将边(u，v)并入TE； \n    ​\t2.2.2 将这两个连通分量合为一个；\n    2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取\n\n时间复杂度：O(eloge)\n\n##### 无向图的双连通性\n\n若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。\n\n1、没有关节点的连通图称为双连通图。\n2、双连通的无向图是连通的，但连通的无向图未必双连通。\n3、一个连通的无向图是双连通的，当且仅当它没有关节点。  \n4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。 \n5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。\n\n- 由先深生成树可得出两类关节点的特性：\n\n 1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 \n\n2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来\n\n算法要点：\n 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。\n 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：\n (1)  dfn[v]；\n (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；\n (3)  low[y]，对v的任何儿子y。\n 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。\n\n```c\n//求双连通分量的算法 \nvoid main() { \ncount = 1; for (all v ∈ V)  mark v “new”; searchB( v0 );}\n\n//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)\nvoid searchB(v) { \nmark v “old”;\ndfn[v] = count;count++; \nlow[v]=dfn[v]; \n for (each w ∈ L[v])\n     if (w is marked “new”) { \n         father [w]=v；searchB (w); \n         low [v]= min { low [v], low [w] }; \n        if (low[w]>=dfn[v]) //表明W及子孙均无指向V的祖先的回退边，v是关节点                   \t\t\tcout<<“a biconnected component”; } \n    else if (w != father [v]) //(v ,w)是回退边   \n          low [v]= min { low [v],  dfn [w] };\n```\n\n\n\n##### 拓扑排序\n\n是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） \n\n实质：广度优先搜索算法\n\nAOV网（有向图）\n\n- 利用队列算法：\n  1.建立入度为零的顶点排队 \n  2.扫描顶点表，将入度为0的顶点入队；\n  3.while（排队不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入队 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n- 利用栈算法：\n  1.建立入度为零的顶点栈 \n  2.扫描顶点表，将入度为0的顶点栈；\n  3.while（栈不空）{ \n  输出队头结点； 记下输出结点的数目； \n  删去与之关联的出边； 若有入度为0的结点，入栈 }\n  4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。\n\n注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。\n\n- 说明：\n  与先广搜索的差别：\n  ​      搜索起点是入度为0的顶点；\n  ​      需判断是否有环路；\n  ​      需对访问并输出的顶点计数（引入计数器nodes）。\n  ​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。\n  也可以采用栈数据结构进行广度优先拓扑排序。 \n  亦可采用无后继顶点优先的拓扑排序算法\n  也可以利用DFS遍历进行拓扑排序\n- 基于DFS的拓扑排序\n\n```c\nvoid topodfs ( v ) {   \n    Push( v ,S ) ; \n    mark[v]=True; \n    for ( L[v] 中的每一个顶点w) \n        if ( mark[w] = False ) topodfs ( w ) ; \n    printf ( Top( S ) ) ; \n    Pop ( S ) ; \n}\n\nvoid  dfs-topo ( GRAPH  L ) {  \n    MakeNull( S ); \n    for( u=1;u<=n; u++) \n        mark[u]=False; \n    for( u=1;u<=n;u++) \n        if ( !mark[u] ) \n            topodfs( u ) ; \n```\n\n思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。\n\n##### 关键路径\n\nAOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）\n\n最大长度的路径称为关键路径。 \n一个AOE中，关键路径可能不只一条。\n关键活动：关键路径上的活动称为关键活动。\n\n关键路径算法步骤：\n\n（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}\n其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）\n\n（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }\n其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S\n\n（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 \n\n（４）若某条边满足E( i ) = L( i )，则它是关键活动。\n\n注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。\n\n##### 最短路径\n\n- 边上权值非负情形的单源最短路径问题 — Dijkstra算法 \n\nDijkstra算法实现步骤：\n1. 将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。\n2. 从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。\n3. 调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 \n4. 重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。\n\n```c\ncosttype MinCost (D, S) { \ntemp = INFINITY ; w = 2 ;\nfor ( i=2 ; i<=n ; i++ )\n\tif (!S[i]&&D[i]<temp)  {\n  \t\ttemp = D[i] ; w = i ; } \nreturn  w ; }\n\nvoid  Dijkstra(GRAPH  C, costtype D[n+1] ，int P[n+1]，bool S[n+1]) { \nfor ( i=2 ; i<=n; i++ ) {  \n\tD[i]=C[1】[i】 ; S[i]=False ;P[i]=1;}\nS [1]= True ; \nfor( i=1; i<=n-1; i++) {  \n\tw=MinCost ( D, S ) ; S[w]=True ; \n\tfor ( v=2 ; v<= n ; n++ ) \n\t\tif ( S[v]!=True ) {  \n        \t        sum=D[w] + C[w】[v】 ;\n \t\t\tif (sum < D[v】 ){D[v】 = sum ; P[v]=w;}\n\t\t} } }//   时间复杂度：O（n^2）\n```\n\n\n\n- 所有顶点之间的最短路径问题 — Floyd算法 \n\n基本思想：动态规划\n\n求解过程：\n\n设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i ---> j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞\n\n 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] \n\n2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。\n\n```c\nvoid Floyd( costtype A[][], costtype C[][], int P[][], int n) {   \nfor ( i = 0; i < n; i++ )\n\tfor ( j = 0; j< n; j++ ) {\n\t\tA[i][j] = C[i][j];  P[i][j] = -1； }\nfor ( k = 0; k < n; k++ ) \n\tfor ( i = 0; i < n; i++ ) \n\t\tfor ( j = 0; j < n; j++ )\n\t\t\tif ( A[i][k] + A[k][j] < A[i][j] ) \t\t\t\t{ A[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;} \n} /* 时间复杂度：O(n3) */\nWarshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]) ; 可以判定有向图任意两点间是否存在有向 路。\n```\n\n#### 查找\n\n##### 线性查找\n\n插入和删除：从后往前\n\n第0个元素做为伪记录或哨兵 \n\n##### 折半查找\n\n折半查找只适合于静态查找\n\n- 数组：时间复杂度O(logn)\n\n- 判定树:\n\n高度： (n+1)/nlog2(n+1)-1\n\n当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近\n\n##### 分块查找\n\n基本思想：均匀分块，块间有序，块内无序\n\n索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.\n\n块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j \n\n所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。\n\n##### BST-二叉查找树\n\n- 插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. \n\n- 删除：\n\n1. 若结点p是叶子，则直接删除结点p； \n2. 若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； \n3. 若结点p的左右子树均不空，则 \n    3.1 查找结点p的右子树上的最左下结点s及其双亲结点par； \n    3.2 将结点s数据域替换到被删结点p的数据域； \n    3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上； \n    3.4 删除结点s；\n\n- 性能：\n\n二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。\n\n 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。\n\n 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) \n\n就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。\n\n##### AVL树\n\nAVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。 \n令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。\n因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）\nFh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1 \n所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2 \n因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)\n\n##### B-树和B+树\n\n- B-树\n\n树中可容纳结点数量最大值，关键字个数最多：m^h-1\n\n树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；\n\n 除根结点和失败结点外，所有结点至少有 m/2 棵子树； \n\n所有的终端结点和叶子结点（失败结点）都位于同一层。\n\nh 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)\n\n关键字个数N：N +1 = 位于第 h+1 层的结点数 >= 2 *(m / 2)^ (h -1)\n\nN+1>= 2 *(m / 2)^ (h -1)  ;    h-1 <= log(m / 2)(( N + 1 ) / 2 ) \n\n- B+树\n\n(1) 有k个子结点的结点必然有k个关键字；\n\n (2)所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。\n3阶B+树\n（3）所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。\n通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。\n\n（4）可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。\n\n##### 散列\n\n不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词\n\n散列函数的构造的原则： 计算简单、分布均匀\n\n- 构造方法：\n  直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、\n\n- 冲突处理：\n\n1、开放定址法：\n--线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               --线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…） \n--二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2） \n--随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） \n\n2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高\n\n3、拉链法\\链地址法：\n\n#### 内部排序\n\n##### 气泡排序\n\n最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； \n\n最坏情况（反序）： 比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2         时间复杂度： O(n^2)\n\n平均情况：时间复杂度为O(n^2)  \n\n空间复杂度： O(1)\n\n##### 快速排序\n\n对气泡排序的改进\n\n最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)\n\n最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)\n\n平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)\n\n##### 直接选择排序\n\n移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次\n\n比较次数：n(n-1)/2\n\n时间复杂度为O(n^2)\n\n 空间复杂度为O(1)\n\n##### 堆排序\n\n对直接选择排序的改进\n\n首先将待排序的记录序列用完全二叉树表示；\n然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；\n最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。\n\n堆排序：令i = n, n-1 ,…, 2 \n\n1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])； \n2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)； \n3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(1)\n\n##### （直接）插入排序\n\n最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)\n\n最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)\n\n最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)\n\n##### 希尔排序\n\n对直接插入排序的改进\n\n时间性能：在O(n^2)和O(nlog2n)之间。\n\n当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) \n\n##### (二路)归并排序\n\n基本思想：自底向上的非递归算法\n\n时间复杂度：O(nlog2n)\n\n空间复杂度：O(n)\n\n##### 基数排序--多关键字排序\n\n次序：从最低位排序，使用了队列\n\n改进：桶----链式排队\n\n时间复杂度：O(d(n+r))    （n---记录数，d----关键字(分量)个数，r----基数）\n\n空间复杂度：O((n+r)) \n\n##### 计数排序\n\n数组记录对应关键字出现的最后一个位置\n\n##### 总结：\n\n| 排序方法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性举例 |\n| --------- | -------- | -------- | -------- | -------- | ---------- |\n| 冒泡     | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 快排     | O(nlog2n) | O(nlog2n) | O(n^2) | O(log2n)~O(n) | 否/2,2,1 |\n| 直接选择 | O(n^2) | O(n^2) | O(n^2) | O(1) | 否/2,2,1 |\n| 堆排序   | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(1) | 否/1,2,2(最小堆) |\n| 直接插入 | O(n^2) | O(n) | O(n^2) | O(1) | 是 |\n| 希尔排序 | O(nlog2n) | O(n^1.3) | O(n^2) | O(1) | 否/3,2,2(d=2/1) |\n| 二路归并 | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(n) | 是 |\n| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(n+r) | 是 |\n\n最坏：\n\n 气泡排序：比较次数：n*(n-1)/2           移动次数：3n*(n-1)/2  \n\n选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   \n\n插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)\n\n#### 七、外排序\n\n#####  磁盘文件的归并排序\n\n方法：多路归并 、 I/O并行处理  、生成初始归并段\n\n- 磁盘文件的归并排序\n\n第一阶段：初始归并段形成 \n\n第二阶段：多路归并 \n\n- 多路归并-减少归并遍数\n\n一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。\n\n在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）*(K-1)*[logkm]=（n-1）*(K-1) *[log2(m/log2K)]\n\n- K 路平衡归并与选择树\n\n第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) \n\n而后每次重新建造选择树所需时间为： O( log2k ) \n\nn 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间：                                    O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 \n\n归并遍数为 logkm，总时间为：                                                                                             O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )\n\n- 并行操作的缓冲区处理\n\n  ​\t\t\t\t\t-------使输入、输出和CPU处理尽可能重叠\n\n对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作\n\n- 生成初始归并段（使用选择树法）：多路平衡归并\n\n假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：\n(1) 从FI输入P个记录到缓冲区W;\n(2)从W中选择出关键字最小的记录MIN；\n(3)将MIN记录输出到FO中去；\n(4)若FI不空，则从FI输入下一个记录到W; \n(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN; \n(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中\n(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段\n\n生成的初始归并段的平均长度是缓冲区长度的两倍\n\n最佳归并树：使外存读写次数最少，是一棵正则树\n\n对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1\n\n\n\n加入细节点：\n\n- 已知前序和后序不能确定唯一二叉树\n- //判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号\n- 树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树\n\n- 解决冲突的方法：线性再散列、内散列表、外散列表\n\n- 左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针\n\n- 折半查找树高度： (n+1)/nlog2(n+1)-1","slug":"数据结构与算法","published":1,"updated":"2019-03-05T23:54:24.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjswg919w0009qcu3uvdkywyv","content":"<h4 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h4><h5 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h5><ul>\n<li><p>抽象数据类型:(Abstract Date Type)</p>\n<p>  -定义：一个数学模型和该模型上定义的操作集合的总称</p>\n<p>  *ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象</p>\n<p>  *同一数学模型上定义的不同操作集，则他们代表不同的ADT</p>\n<p>  -表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作</p>\n</li>\n<li><p>逻辑结构：</p>\n<p>集合——没关系</p>\n<p>线性表——1:1前后</p>\n<p>树——1：m层次</p>\n<p>图——网状</p>\n</li>\n<li><p>存储结构：</p>\n<p>​    顺序——连续空间          $\\Rightarrow$索引</p>\n<p>​    链式——不连续空间          +散列</p>\n</li>\n</ul>\n<h5 id=\"算法及算法分析\"><a href=\"#算法及算法分析\" class=\"headerlink\" title=\"算法及算法分析\"></a>算法及算法分析</h5><ul>\n<li><p>算法的相关概念</p>\n<p>  -算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列</p>\n<p>  -五大特性：输入   输出   有穷性   确定性</p>\n</li>\n<li><p>时间复杂度（time  xomplexity)</p>\n<p>  算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度</p>\n</li>\n<li><p>常见时间复杂度的比较</p>\n</li>\n</ul>\n<p>0(1)&lt; &lt;0(logn) &lt;&lt;0(n)&lt; &lt; 0(nlogn) &lt;&lt; 0(n2) &lt;&lt; 0(n3) &lt;&lt;0(2n) &lt;&lt; 0(n!)</p>\n<ul>\n<li>常见设计方法：</li>\n</ul>\n<p>穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)</p>\n<p>$\\alpha -\\beta$裁剪和分支界限法、并行算法</p>\n<ul>\n<li>时空资源的折中原理</li>\n</ul>\n<p>同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质</p>\n<h5 id=\"逐步求精的程序设计方法\"><a href=\"#逐步求精的程序设计方法\" class=\"headerlink\" title=\"逐步求精的程序设计方法\"></a>逐步求精的程序设计方法</h5><p>​    模型化-确定算法-逐步求精    </p>\n<h4 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h4><h5 id=\"线性表的抽象数据类型\"><a href=\"#线性表的抽象数据类型\" class=\"headerlink\" title=\"线性表的抽象数据类型\"></a>线性表的抽象数据类型</h5><p>​     顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素</p>\n<h5 id=\"线性表的实现\"><a href=\"#线性表的实现\" class=\"headerlink\" title=\"线性表的实现\"></a>线性表的实现</h5><p>存储结构的三种方式：</p>\n<p> ① 连续的存储空间（数组） →  静态存储</p>\n<p> ② 非连续存储空间——指针（链表） →  动态存储</p>\n<p> ③ 游标（连续存储空间+动态管理思想）→  静态链表</p>\n<h6 id=\"线性表的数组实现：\"><a href=\"#线性表的数组实现：\" class=\"headerlink\" title=\"线性表的数组实现：\"></a>线性表的数组实现：</h6><p>随机存储结构，查找快   o(1)</p>\n<p>插入和删除慢  o(n)</p>\n<p>空间固定</p>\n<h6 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h6><p>非随机存储结构</p>\n<p>eg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2</p>\n<p>​    求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走</p>\n<ul>\n<li><p>插入元素</p>\n<p>a、保存后继指针</p>\n<p>b、申请一个内存空间</p>\n<p>c、插入：先链接后部分，再衔接前部分</p>\n</li>\n</ul>\n<h6 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h6><p>元素是结构体数组，多个线性表公用一个存储池</p>\n<p>单链表逆置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一：</span></span><br><span class=\"line\"><span class=\"comment\">//设表头为L,算法如下: </span></span><br><span class=\"line\">p=L-&gt;next-&gt;next; q=p-&gt;next; L-&gt;next-&gt;next=<span class=\"literal\">NULL</span>; <span class=\"keyword\">while</span>(p!=null) &#123;</span><br><span class=\"line\">    p-&gt;next=L-&gt;next;</span><br><span class=\"line\">    L-&gt;next=p;</span><br><span class=\"line\">    p=q;</span><br><span class=\"line\">    q=q-&gt;next; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法二：</span></span><br><span class=\"line\"><span class=\"comment\">//线性表由q来表示 </span></span><br><span class=\"line\">p=null; w=q; <span class=\"keyword\">while</span>(w!=null) &#123; </span><br><span class=\"line\">    w=w-&gt;next; </span><br><span class=\"line\">    q-&gt;next=p;</span><br><span class=\"line\">    p=q; q=w; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>双向单链表插入与删除：</p>\n<p><img src=\"/img/ds/双向单链表.PNG\" alt=\"双向单链表\"></p>\n<h6 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h6><ul>\n<li><p>数组求模可以成环</p>\n</li>\n<li><p>判断链表是否成环：两个指针，速度分别为1和2,</p>\n</li>\n<li><p>确定环入口：</p>\n</li>\n<li><p>两个链表是否相交:判断两个列表最后一个元素是否相同//散列</p>\n</li>\n<li><p>单项循环链表插入与删除：</p>\n</li>\n</ul>\n<p><img src=\"/img/ds/双循环1.PNG\" alt=\"双循环1\"></p>\n<p><img src=\"/img/ds/双循环2.PNG\" alt=\"双循环2\"></p>\n<h5 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h5><ul>\n<li>多项式的代数运算</li>\n</ul>\n<p><img src=\"/img/ds/中缀转后缀表达式.PNG\" height=\"400px\"></p>\n<ul>\n<li><p>后缀表达式求值：</p>\n<p>对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。</p>\n</li>\n</ul>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>优先队列：</p>\n<p>问题：如何解决循环队列中队空与队满状态相同？<br>方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；</p>\n<p> 方法二：另设一个标志位用以区别队空与队满两种状态；<br>结论：两种方法的代价是相同的。</p>\n<h5 id=\"串（String）\"><a href=\"#串（String）\" class=\"headerlink\" title=\"串（String）\"></a>串（String）</h5><p>KMP算法：</p>\n<p>一、如何求next函数:</p>\n<ul>\n<li><p>当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 </p>\n</li>\n<li><p>当j&gt;1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。</p>\n</li>\n<li>当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较</li>\n</ul>\n<p>下面给出求next函数的伪码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"keyword\">int</span> &amp;next[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//求模式串T的next函数并存入next数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">while</span> (i &lt; T[<span class=\"number\">0</span>]) <span class=\"comment\">//T[0]中存放数组长度 &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>( j==<span class=\"number\">0</span>||T[i]==T[j]) &#123; ++i; ++j;  next[i]=j; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span> j= next[j]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;<span class=\"comment\">//get_next</span></span><br></pre></td></tr></table></figure>\n<p>二、KMP算法实现步骤：</p>\n<p>   1.在串S和串T中分别设比较的起始下标i和j；</p>\n<ol start=\"2\">\n<li>循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕<br>2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则<br>2.2将j向右滑动到next[j]位置，即j=next[j]；<br>2.3 如果j=0，则将i和j分别加1，准备下一趟比较；</li>\n<li>如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；</li>\n</ol>\n<h5 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h5><p>例如：</p>\n<p> A = （a，（b，a，b），（），c，（（（2））））； </p>\n<p>B = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；</p>\n<p>长度：广义表LS中的直接元素的个数；<br>深度：广义表LS中括号的最大嵌套层数。<br>表头：广义表LS非空时，称第一个元素为LS的表头；<br>表尾：广义表LS中除表头外其余元素组成的广义表。</p>\n<h4 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h4><h5 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h5><h6 id=\"性质：\"><a href=\"#性质：\" class=\"headerlink\" title=\"性质：\"></a>性质：</h6><p>在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关</p>\n<h6 id=\"建立\"><a href=\"#建立\" class=\"headerlink\" title=\"建立\"></a>建立</h6><p>建立：</p>\n<p><img src=\"/img/ds/建立1.PNG\" alt=\"建立1\"></p>\n<p>先序建立：</p>\n<p><img src=\"/img/ds/先序建立.PNG\" alt=\"先序建立\"></p>\n<p>非递归建立：</p>\n<p><img src=\"/img/ds/建立非.PNG\" alt=\"建立非\"></p>\n<h6 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h6><ul>\n<li>先序递归：</li>\n</ul>\n<p><img src=\"/img/ds/先序.PNG\" alt=\"先序\"></p>\n<ul>\n<li>先序非递归：</li>\n</ul>\n<p>1.栈s初始化；<br>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 输出root-&gt;data;<br>         2.1.2 将指针root的值保存到栈中；<br>​        2.1.3 继续遍历root的左子树<br>​    2.2 如果栈s不空，则<br>​        2.2.1 将栈顶元素弹出至root；<br>​        2.2.2 准备遍历root的右子树；</p>\n<ul>\n<li>中序非递归：</li>\n</ul>\n<p>1.栈s初始化； </p>\n<p>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 将指针root的值保存到栈中；<br>         2.1.2 继续遍历root的左子树<br>     2.2 如果栈s不空，则<br>         2.2.1 将栈顶元素弹出至root；<br>         2.2.2 输出root-&gt;data;<br>​        2.2.3 准备遍历root的右子树</p>\n<ul>\n<li>后序非递归：</li>\n</ul>\n<ol>\n<li>栈s初始化； </li>\n<li>循环直到root为空且栈s为空<br> 2.1 当root非空时循环<br> ​    2.1.1 将root连同标志flag=1 入栈；<br> ​    2.1.2 继续遍历root的左子树；<br> 2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点;<br> 2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；</li>\n</ol>\n<p><img src=\"/img/ds/二叉树先序遍历.PNG\" height=\"400px\"></p>\n<ul>\n<li>层序遍历：</li>\n</ul>\n<ol>\n<li>队列Q初始化；</li>\n<li>如果二叉树非空，将根指针入队；</li>\n<li>循环直到队列Q为空<br>3.1 q=队列Q的队头元素出队；<br>3.2 访问结点q的数据域；<br>3.3 若结点q存在左孩子，则将左孩子指针入队；<br>3.4 若结点q存在右孩子，则将右孩子指针入队；</li>\n</ol>\n<h6 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h6><ul>\n<li>1、已知先序中序确定二叉树：</li>\n</ul>\n<p>遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，<br>​    如果栈为空，将下标 j 入栈；<br>​    否则，栈不为空：<br>​        如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈</p>\n<p><img src=\"/img/ds/已知先序中序构二叉树.PNG\" height=\"450px\"></p>\n<ul>\n<li>2、求二叉树任意两节点公共祖先：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == p || root == q) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;<span class=\"comment\">//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个</span></span><br><span class=\"line\">    TreeNode *L = lowestCommonAncestor(root-&gt;left, p, q);<span class=\"comment\">//左子树中是否能最先找到p,q中的一个节点</span></span><br><span class=\"line\">    TreeNode *R = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L &amp;&amp; R) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;  <span class=\"comment\">//如果当前节点左右节点都各找到一个，那么返回当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> L ? L : R; <span class=\"comment\">//只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3、求二叉树宽度：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>  front=<span class=\"number\">-1</span>,rear=<span class=\"number\">-1</span>,count=<span class=\"number\">0</span>,max=<span class=\"number\">0</span>,right</span><br><span class=\"line\"><span class=\"keyword\">if</span> (T!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">\tq[++rear]=T;max=<span class=\"number\">1</span>;right=rear; </span><br><span class=\"line\"><span class=\"keyword\">while</span>(front!=rear) &#123;</span><br><span class=\"line\">\tT=q[++front];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;lc!=<span class=\"literal\">NULL</span>)q[++rear]=T-&gt;lc; count++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;rc!=<span class=\"literal\">NULL</span> q[++rear]=T-&gt;rc; count++; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(front==right) &#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(max&lt;count)max=count; count=<span class=\"number\">0</span>;right=rear;&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>4、线索树：</li>\n</ul>\n<p>1）在中序线索二叉树中求一个结点p的中序后继p：</p>\n<p>​    当p-&gt;rtag==False时，p-&gt;rchild 即为所求(线索)。</p>\n<pre><code>当p-&gt;rtag==True时，p为p 的右子树的最左结点\n</code></pre><p>2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> ThInOrder(ThTree HEAD) &#123;  </span><br><span class=\"line\"><span class=\"attribute\">ThTree</span>   tmp ; <span class=\"attribute\">tmp</span> = HEAD ; </span><br><span class=\"line\">  <span class=\"section\">do</span> &#123; </span><br><span class=\"line\">  \t<span class=\"attribute\">tmp</span> = InNext ( tmp ) ; </span><br><span class=\"line\"> <span class=\"attribute\">if</span> ( tmp != HEAD ) visit ( tmp -&gt; data ) ;</span><br><span class=\"line\">&#125; <span class=\"attribute\">while</span> ( tmp != HEAD ) ; &#125;</span><br></pre></td></tr></table></figure>\n<p>  3）求中序线索二叉树中结点p 的先序顺序后继结点p* </p>\n<p>(1) p 的左子树不空时，p 的左儿子p-&gt;lchild 即为 p<em>；<br>(2) p 的左子树空但右子树不空时，p 的p-&gt;rchild 为p</em>；<br>(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THTREE PreNext( ThTree p) &#123;   </span><br><span class=\"line\">\tThTree Q ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p-&gt;ltag = = <span class=\"keyword\">True</span> ) Q=p-&gt;lchild ; </span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tQ = p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(Q-&gt;rtag = = <span class=\"keyword\">False</span>) Q = Q-&gt;rchild ; </span><br><span class=\"line\">\t\tQ = Q-&gt;rchild ;</span><br><span class=\"line\">\t&#125;  <span class=\"keyword\">return</span> ( Q ) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>相似二叉树:具有相同结构的二叉树为相似二叉树。 </p>\n</li>\n<li><p>相似且对应结点包含相同信息的二叉树称为等价二叉树。 </p>\n</li>\n</ul>\n<h5 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h5><p>最大堆：</p>\n<p>如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆</p>\n<ul>\n<li>大根堆插入：</li>\n</ul>\n<p>void Insert ( Heap &amp;heap，Elementtype x)//大根堆插入一个元素 {<br>​    int i;<br>​    if ( ! HeapFull ( heap ) ) {<br>​        i=heap.n+1;<br>​        while ( (i!=1)&amp;&amp;(x &gt;heap.ele [i/2] ) ) {<br>​            heap.ele [i]=heap.ele [i/2]; i=i/2;<br>     } heap.ele [i] = x;</p>\n<ul>\n<li>大根堆删除：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMax</span> <span class=\"params\">(Heap &amp; heap )</span><span class=\"comment\">//大根堆删除 &#123;  </span></span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"keyword\">int</span> parent</span>=<span class=\"number\">1</span>, child=<span class=\"number\">2</span>;  Elementtype  ele,  tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (! HeapEmpty(heap)) &#123; </span><br><span class=\"line\">\t\tele=heap.ele [<span class=\"number\">1</span>]; tmp=heap.ele [heap.n--];</span><br><span class=\"line\"> \t\t<span class=\"keyword\">while</span> (child&lt;= heap.n)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(child&lt;heap.n)&amp;&amp;(heap.ele [child]&lt;heap.ele [child+<span class=\"number\">1</span>])) \t\t\t\t\t\t\t\tchild++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&gt;=heap.ele [child])  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\theap.ele [parent]=heap.ele [child]; </span><br><span class=\"line\">\t\t\tparent=child; child*=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"comment\">//while</span></span><br><span class=\"line\"> \t\theap.ele [parent]=tmp; <span class=\"keyword\">return</span> ele; </span><br><span class=\"line\">\t&#125;<span class=\"comment\">//if</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"选择树\"><a href=\"#选择树\" class=\"headerlink\" title=\"选择树\"></a>选择树</h5><p>​    胜者树、败者树</p>\n<h5 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h5><p>存储结构：</p>\n<p>双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>树</th>\n<th>二叉树</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>节点关系</td>\n<td>兄弟关系</td>\n<td>双亲和右孩子</td>\n</tr>\n<tr>\n<td></td>\n<td>双亲和长子</td>\n<td>双亲和左孩子</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"森林与二叉树的相互转换\"><a href=\"#森林与二叉树的相互转换\" class=\"headerlink\" title=\"森林与二叉树的相互转换\"></a>森林与二叉树的相互转换</h5><ul>\n<li>森林转化成二叉树：</li>\n</ul>\n<p>1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）</p>\n<p> 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 </p>\n<p>3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）</p>\n<ul>\n<li>二叉树转化成森林（树）</li>\n</ul>\n<p>连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；</p>\n<p> 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; </p>\n<p>旋转： 按逆时针旋转45度角（即把结点按层次排列）</p>\n<ul>\n<li>将一株树转换为二叉树，二叉树一定没有右子树</li>\n<li>一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；</li>\n<li><p>任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；</p>\n</li>\n<li><p>森林(树)转换成二叉树的递归算法：</p>\n<p>F ={T1,T2, …,Tn}<br>二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则<br>B(F)的根就是root（T1）；<br>B(F)的左子树是F的第一棵树T1的子树森林；<br>B(F)的右子树F的其余子树森林。 </p>\n</li>\n<li><p>二叉树转换成森林(树) 的递归算法 ：</p>\n</li>\n</ul>\n<p>若B 为空，则F 为空；若B 不空，则<br> F中的第一株树T1 的根对应二叉树B 的根；<br> T1中根结点的子树森林F1是由B的左子树转换来的；<br> F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。</p>\n<h5 id=\"树的应用\"><a href=\"#树的应用\" class=\"headerlink\" title=\"树的应用\"></a>树的应用</h5><ul>\n<li><p>堆的复杂度：O(n)</p>\n</li>\n<li><p>败者树的复杂度：O(2n-1)</p>\n</li>\n</ul>\n<h6 id=\"用树结构表示集合：\"><a href=\"#用树结构表示集合：\" class=\"headerlink\" title=\"用树结构表示集合：\"></a>用树结构表示集合：</h6><p>等价分类算法： </p>\n<ol>\n<li><p>令S中的每一个元素自身构成一个等价类，S1,S2,…S7 </p>\n</li>\n<li><p>重复读入等价对（i,  j）<br>2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性）<br>2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Equivalence</span> <span class=\"params\">(MFSET S)</span>   <span class=\"comment\">//等价分类算法 &#123; </span></span></span><br><span class=\"line\">   int i ,j , k ,m; </span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n+<span class=\"number\">1</span>;i++) Initial(i,S);  <span class=\"comment\">//使集合S只包含元素i</span></span><br><span class=\"line\">   <span class=\"built_in\">cin</span>&gt;&gt;i&gt;&gt;j;        <span class=\"comment\">// 读入等价对</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(!(i==<span class=\"number\">0</span>&amp;&amp;j==<span class=\"number\">0</span>)&#123; <span class=\"comment\">// 等价对未读完</span></span><br><span class=\"line\">       k=Find(i,S);           <span class=\"comment\">//求i的根 </span></span><br><span class=\"line\">       m=Find(j,S);        <span class=\"comment\">// 求j的根</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(k!=m)          <span class=\"comment\">//if k==m,i,j已在一个树中，不需合并 </span></span><br><span class=\"line\">           Union(i,j,S);     <span class=\"comment\">//合并 </span></span><br><span class=\"line\">       <span class=\"built_in\">cin</span>&lt;&lt;i&lt;&lt;j;            &#125;  &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"判定树\"><a href=\"#判定树\" class=\"headerlink\" title=\"判定树\"></a>判定树</h6><p>判定树的特点：</p>\n<p> 一个判定树是一个算法的描述；<br>每个内部结点对应一个部分解； 每个叶子对应一个解；<br>每个内部结点连接与一个获得新信息的测试；<br> 从每个结点出发的分支标记着不同的测试结果；<br> 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合</p>\n<p>判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$</p>\n<h6 id=\"哈夫曼树：\"><a href=\"#哈夫曼树：\" class=\"headerlink\" title=\"哈夫曼树：\"></a>哈夫曼树：</h6><ul>\n<li>内外路径：</li>\n</ul>\n<p><img src=\"/img/ds/内外路径.PNG\" alt=\"内外路径\"></p>\n<ul>\n<li>哈夫曼树性质：</li>\n</ul>\n<p>没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。</p>\n<p><img src=\"/img/ds/哈夫曼树性质1.PNG\" alt=\"哈夫曼树性质1\"></p>\n<ul>\n<li>码长计算：</li>\n</ul>\n<p><img src=\"/img/ds/码长计算.PNG\" alt=\"码长计算\"></p>\n<ul>\n<li>哈夫曼编码一定具有前缀性；<br>哈夫曼编码是最小冗余码;<br>哈夫曼编码方法，使出现概率大的字符对应的码长较短；<br>哈夫曼编码不唯一，可以用于加密；<br>哈夫曼编码译码简单唯一，没有二义性.</li>\n</ul>\n<h6 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h6><p>把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值</p>\n<p> 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。</p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><p>简单路径：若路径上各顶点 v1,v2,…,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。</p>\n<p> 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。</p>\n<h5 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>空间性能</th>\n<th>时间性能</th>\n<th>唯一性</th>\n<th>适用范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>邻接矩阵</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>唯一</td>\n<td>稠密图</td>\n</tr>\n<tr>\n<td>邻接表</td>\n<td>O(n+e)</td>\n<td>O(n+e)</td>\n<td>不唯一</td>\n<td>稀疏图</td>\n</tr>\n</tbody>\n</table>\n<p>十字链表、邻接多重表</p>\n<h5 id=\"图的搜索\"><a href=\"#图的搜索\" class=\"headerlink\" title=\"图的搜索\"></a>图的搜索</h5><ul>\n<li>深度优先搜索</li>\n</ul>\n<p>从一个顶点出发的一次深度优先遍历算法：<br>实现步骤： </p>\n<ol>\n<li>访问顶点v; visited[v]=1; </li>\n<li>w=顶点v的第一个邻接点； </li>\n<li>while (w存在)<br>3.1 if (w未被访问) 从顶点w出发递归执行该算法;<br>3.2 w=顶点v的下一个邻接点;</li>\n</ol>\n<p>邻接矩阵：空间：O(n^2)       时间： O(n^2)</p>\n<p>邻接表：O(n)  O(V+E)</p>\n<ul>\n<li>广度优先搜索</li>\n</ul>\n<p>1 . 初始化队列Q;</p>\n<ol start=\"2\">\n<li>访问顶点v; visited [v]=1; 顶点v入队Q;</li>\n<li>while (队列Q非空)<br> 3.1 v=队列Q的队头元素出队;<br> 3.2 w=顶点v的第一个邻接点;<br> 3.3 while (w存在) <pre><code>3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n3.3.2 w=顶点v的下一个邻接点；\n</code></pre></li>\n</ol>\n<h5 id=\"图与树、最小生成树\"><a href=\"#图与树、最小生成树\" class=\"headerlink\" title=\"图与树、最小生成树\"></a>图与树、最小生成树</h5><h6 id=\"先深和先广生成森林\"><a href=\"#先深和先广生成森林\" class=\"headerlink\" title=\"先深和先广生成森林\"></a>先深和先广生成森林</h6><ul>\n<li>先深搜索对边的分类<br>两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;<br>结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然</li>\n<li>先广搜索对边的分类<br>两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.<br>结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然</li>\n</ul>\n<h6 id=\"无向图与开放树\"><a href=\"#无向图与开放树\" class=\"headerlink\" title=\"无向图与开放树\"></a>无向图与开放树</h6><p>连通而无环路的无向图称作开放树（Free  Tree）</p>\n<p>（1）具有n≥1个顶点的开放树包含n-1条边； </p>\n<p>（2）如果在开放树中任意加上一条边，便得到一条回路</p>\n<h6 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h6><ul>\n<li>普里姆Prim算法：</li>\n</ul>\n<p>基本思想<br>① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ }<br>② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U<br>③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树</p>\n<p>如何找到连接U和V-U的最短边 ：<br>利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。</p>\n<ol>\n<li><p>初始化两个辅助数组LOWCOST和CLOSEST；</p>\n</li>\n<li><p>输出顶点v0，将顶点v0加入集合U中；</p>\n</li>\n<li><p>重复执行下列操作n-1次<br>3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；<br>3.2 输出顶点k和对应的权值；<br>3.3 将顶点k加入集合U中；<br>3.4 调整数组LOWCOST和CLOSEST；</p>\n<p>LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]}<br>CLOSEST[j]=k</p>\n</li>\n</ol>\n<p>时间复杂度：O(n^2)</p>\n<ul>\n<li>克鲁斯卡尔（Kruskal）算法</li>\n</ul>\n<p>注：边值各不相同时生成树唯一</p>\n<p>基本思想：<br>设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }，<br>然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。<br>若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，<br>如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。</p>\n<ol>\n<li>初始化：U=V； TE={ }； </li>\n<li>循环直到T中的连通分量个数为1<br> 2.1 在E中选择最短边(u，v);<br> 2.2 如果顶点u、v位于T的两个不同连通分量，则<br> ​    2.2.1 将边(u，v)并入TE；<br> ​    2.2.2 将这两个连通分量合为一个；<br> 2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取</li>\n</ol>\n<p>时间复杂度：O(eloge)</p>\n<h5 id=\"无向图的双连通性\"><a href=\"#无向图的双连通性\" class=\"headerlink\" title=\"无向图的双连通性\"></a>无向图的双连通性</h5><p>若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。</p>\n<p>1、没有关节点的连通图称为双连通图。<br>2、双连通的无向图是连通的，但连通的无向图未必双连通。<br>3、一个连通的无向图是双连通的，当且仅当它没有关节点。<br>4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。<br>5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。</p>\n<ul>\n<li><p>由先深生成树可得出两类关节点的特性：</p>\n<p>1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 </p>\n</li>\n</ul>\n<p>2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来</p>\n<p>算法要点：<br> 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。<br> 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：<br> (1)  dfn[v]；<br> (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；<br> (3)  low[y]，对v的任何儿子y。<br> 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求双连通分量的算法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">count = <span class=\"number\">1</span>; <span class=\"keyword\">for</span> (all v ∈ V)  mark v “<span class=\"keyword\">new</span>”; searchB( v0 );&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">searchB</span><span class=\"params\">(v)</span> </span>&#123; </span><br><span class=\"line\">mark v “old”;</span><br><span class=\"line\">dfn[v] = count;count++; </span><br><span class=\"line\">low[v]=dfn[v]; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (each w ∈ L[v])</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (w is marked “<span class=\"keyword\">new</span>”) &#123; </span><br><span class=\"line\">         father [w]=v；searchB (w); </span><br><span class=\"line\">         low [v]= min &#123; low [v], low [w] &#125;; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (low[w]&gt;=dfn[v]) <span class=\"comment\">//表明W及子孙均无指向V的祖先的回退边，v是关节点                   \t\t\tcout&lt;&lt;“a biconnected component”; &#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (w != father [v]) <span class=\"comment\">//(v ,w)是回退边   </span></span><br><span class=\"line\">          low [v]= min &#123; low [v],  dfn [w] &#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h5><p>是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） </p>\n<p>实质：广度优先搜索算法</p>\n<p>AOV网（有向图）</p>\n<ul>\n<li><p>利用队列算法：<br>1.建立入度为零的顶点排队<br>2.扫描顶点表，将入度为0的顶点入队；<br>3.while（排队不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入队 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n<li><p>利用栈算法：<br>1.建立入度为零的顶点栈<br>2.扫描顶点表，将入度为0的顶点栈；<br>3.while（栈不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入栈 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n</ul>\n<p>注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。</p>\n<ul>\n<li>说明：<br>与先广搜索的差别：<br>​      搜索起点是入度为0的顶点；<br>​      需判断是否有环路；<br>​      需对访问并输出的顶点计数（引入计数器nodes）。<br>​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。<br>也可以采用栈数据结构进行广度优先拓扑排序。<br>亦可采用无后继顶点优先的拓扑排序算法<br>也可以利用DFS遍历进行拓扑排序</li>\n<li>基于DFS的拓扑排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topodfs</span> <span class=\"params\">( v )</span> </span>&#123;   </span><br><span class=\"line\">    Push( v ,S ) ; </span><br><span class=\"line\">    mark[v]=True; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( L[v] 中的每一个顶点w) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( mark[w] = False ) topodfs ( w ) ; </span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( Top( S ) ) ; </span><br><span class=\"line\">    Pop ( S ) ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span>  dfs-topo ( GRAPH  L ) &#123;  </span><br><span class=\"line\">    MakeNull( S ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n; u++) </span><br><span class=\"line\">        mark[u]=False; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n;u++) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !mark[u] ) </span><br><span class=\"line\">            topodfs( u ) ;</span><br></pre></td></tr></table></figure>\n<p>思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。</p>\n<h5 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h5><p>AOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）</p>\n<p>最大长度的路径称为关键路径。<br>一个AOE中，关键路径可能不只一条。<br>关键活动：关键路径上的活动称为关键活动。</p>\n<p>关键路径算法步骤：</p>\n<p>（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}<br>其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）</p>\n<p>（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }<br>其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S</p>\n<p>（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 </p>\n<p>（４）若某条边满足E( i ) = L( i )，则它是关键活动。</p>\n<p>注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。</p>\n<h5 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h5><ul>\n<li>边上权值非负情形的单源最短路径问题 — Dijkstra算法 </li>\n</ul>\n<p>Dijkstra算法实现步骤：</p>\n<ol>\n<li>将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。</li>\n<li>从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。</li>\n<li>调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 </li>\n<li>重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">costtype <span class=\"title\">MinCost</span> <span class=\"params\">(D, S)</span> </span>&#123; </span><br><span class=\"line\">temp = INFINITY ; w = <span class=\"number\">2</span> ;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n ; i++ )</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!S[i]&amp;&amp;D[i]&lt;temp)  &#123;</span><br><span class=\"line\">  \t\ttemp = D[i] ; w = i ; &#125; </span><br><span class=\"line\"><span class=\"keyword\">return</span>  w ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">Dijkstra</span><span class=\"params\">(GRAPH  C, costtype D[n+<span class=\"number\">1</span>] ，<span class=\"keyword\">int</span> P[n+<span class=\"number\">1</span>]，<span class=\"keyword\">bool</span> S[n+<span class=\"number\">1</span>])</span> </span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n; i++ ) &#123;  </span><br><span class=\"line\">\tD[i]=C[<span class=\"number\">1</span>】[i】 ; S[i]=False ;P[i]=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">S [<span class=\"number\">1</span>]= True ; </span><br><span class=\"line\"><span class=\"keyword\">for</span>( i=<span class=\"number\">1</span>; i&lt;=n<span class=\"number\">-1</span>; i++) &#123;  </span><br><span class=\"line\">\tw=MinCost ( D, S ) ; S[w]=True ; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( v=<span class=\"number\">2</span> ; v&lt;= n ; n++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( S[v]!=True ) &#123;  </span><br><span class=\"line\">        \t        sum=D[w] + C[w】[v】 ;</span><br><span class=\"line\"> \t\t\t<span class=\"keyword\">if</span> (sum &lt; D[v】 )&#123;D[v】 = sum ; P[v]=w;&#125;</span><br><span class=\"line\">\t\t&#125; &#125; &#125;<span class=\"comment\">//   时间复杂度：O（n^2）</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有顶点之间的最短路径问题 — Floyd算法 </li>\n</ul>\n<p>基本思想：动态规划</p>\n<p>求解过程：</p>\n<p>设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i —&gt; j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞</p>\n<p> 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] </p>\n<p>2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Floyd</span><span class=\"params\">( costtype A[][], costtype C[][], <span class=\"keyword\">int</span> P[][], <span class=\"keyword\">int</span> n)</span> </span>&#123;   </span><br><span class=\"line\"><span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ )</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j&lt; n; j++ ) &#123;</span><br><span class=\"line\">\t\tA[i][j] = C[i][j];  P[i][j] = <span class=\"number\">-1</span>； &#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( k = <span class=\"number\">0</span>; k &lt; n; k++ ) </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; n; j++ )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( A[i][k] + A[k][j] &lt; A[i][j] ) \t\t\t\t&#123; A[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;&#125; </span><br><span class=\"line\">&#125; <span class=\"comment\">/* 时间复杂度：O(n3) */</span></span><br><span class=\"line\">Warshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]) ; 可以判定有向图任意两点间是否存在有向 路。</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><h5 id=\"线性查找\"><a href=\"#线性查找\" class=\"headerlink\" title=\"线性查找\"></a>线性查找</h5><p>插入和删除：从后往前</p>\n<p>第0个元素做为伪记录或哨兵 </p>\n<h5 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h5><p>折半查找只适合于静态查找</p>\n<ul>\n<li><p>数组：时间复杂度O(logn)</p>\n</li>\n<li><p>判定树:</p>\n</li>\n</ul>\n<p>高度： (n+1)/nlog2(n+1)-1</p>\n<p>当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近</p>\n<h5 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h5><p>基本思想：均匀分块，块间有序，块内无序</p>\n<p>索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.</p>\n<p>块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j </p>\n<p>所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。</p>\n<h5 id=\"BST-二叉查找树\"><a href=\"#BST-二叉查找树\" class=\"headerlink\" title=\"BST-二叉查找树\"></a>BST-二叉查找树</h5><ul>\n<li><p>插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. </p>\n</li>\n<li><p>删除：</p>\n</li>\n</ul>\n<ol>\n<li>若结点p是叶子，则直接删除结点p； </li>\n<li>若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； </li>\n<li>若结点p的左右子树均不空，则<br> 3.1 查找结点p的右子树上的最左下结点s及其双亲结点par；<br> 3.2 将结点s数据域替换到被删结点p的数据域；<br> 3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上；<br> 3.4 删除结点s；</li>\n</ol>\n<ul>\n<li>性能：</li>\n</ul>\n<p>二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。</p>\n<p> 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。</p>\n<p> 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) </p>\n<p>就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。</p>\n<h5 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h5><p>AVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。<br>令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。<br>因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）<br>Fh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1<br>所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2<br>因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)</p>\n<h5 id=\"B-树和B-树\"><a href=\"#B-树和B-树\" class=\"headerlink\" title=\"B-树和B+树\"></a>B-树和B+树</h5><ul>\n<li>B-树</li>\n</ul>\n<p>树中可容纳结点数量最大值，关键字个数最多：m^h-1</p>\n<p>树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；</p>\n<p> 除根结点和失败结点外，所有结点至少有 m/2 棵子树； </p>\n<p>所有的终端结点和叶子结点（失败结点）都位于同一层。</p>\n<p>h 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)</p>\n<p>关键字个数N：N +1 = 位于第 h+1 层的结点数 &gt;= 2 *(m / 2)^ (h -1)</p>\n<p>N+1&gt;= 2 *(m / 2)^ (h -1)  ;    h-1 &lt;= log(m / 2)(( N + 1 ) / 2 ) </p>\n<ul>\n<li>B+树</li>\n</ul>\n<p>(1) 有k个子结点的结点必然有k个关键字；</p>\n<p> (2)所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。<br>3阶B+树<br>（3）所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。<br>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>\n<p>（4）可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。</p>\n<h5 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h5><p>不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词</p>\n<p>散列函数的构造的原则： 计算简单、分布均匀</p>\n<ul>\n<li><p>构造方法：<br>直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、</p>\n</li>\n<li><p>冲突处理：</p>\n</li>\n</ul>\n<p>1、开放定址法：<br>–线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               –线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…）<br>–二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2）<br>–随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） </p>\n<p>2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高</p>\n<p>3、拉链法\\链地址法：</p>\n<h4 id=\"内部排序\"><a href=\"#内部排序\" class=\"headerlink\" title=\"内部排序\"></a>内部排序</h4><h5 id=\"气泡排序\"><a href=\"#气泡排序\" class=\"headerlink\" title=\"气泡排序\"></a>气泡排序</h5><p>最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； </p>\n<p>最坏情况（反序）： 比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2         时间复杂度： O(n^2)</p>\n<p>平均情况：时间复杂度为O(n^2)  </p>\n<p>空间复杂度： O(1)</p>\n<h5 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h5><p>对气泡排序的改进</p>\n<p>最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)</p>\n<p>最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)</p>\n<p>平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)</p>\n<h5 id=\"直接选择排序\"><a href=\"#直接选择排序\" class=\"headerlink\" title=\"直接选择排序\"></a>直接选择排序</h5><p>移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次</p>\n<p>比较次数：n(n-1)/2</p>\n<p>时间复杂度为O(n^2)</p>\n<p> 空间复杂度为O(1)</p>\n<h5 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h5><p>对直接选择排序的改进</p>\n<p>首先将待排序的记录序列用完全二叉树表示；<br>然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；<br>最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。</p>\n<p>堆排序：令i = n, n-1 ,…, 2 </p>\n<p>1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])；<br>2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)；<br>3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(1)</p>\n<h5 id=\"（直接）插入排序\"><a href=\"#（直接）插入排序\" class=\"headerlink\" title=\"（直接）插入排序\"></a>（直接）插入排序</h5><p>最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)</p>\n<p>最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)</p>\n<p>最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)</p>\n<h5 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h5><p>对直接插入排序的改进</p>\n<p>时间性能：在O(n^2)和O(nlog2n)之间。</p>\n<p>当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) </p>\n<h5 id=\"二路-归并排序\"><a href=\"#二路-归并排序\" class=\"headerlink\" title=\"(二路)归并排序\"></a>(二路)归并排序</h5><p>基本思想：自底向上的非递归算法</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(n)</p>\n<h5 id=\"基数排序–多关键字排序\"><a href=\"#基数排序–多关键字排序\" class=\"headerlink\" title=\"基数排序–多关键字排序\"></a>基数排序–多关键字排序</h5><p>次序：从最低位排序，使用了队列</p>\n<p>改进：桶—-链式排队</p>\n<p>时间复杂度：O(d(n+r))    （n—记录数，d—-关键字(分量)个数，r—-基数）</p>\n<p>空间复杂度：O((n+r)) </p>\n<h5 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h5><p>数组记录对应关键字出现的最后一个位置</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>快排</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n^2)</td>\n<td>O(log2n)~O(n)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>直接选择</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(1)</td>\n<td>否/1,2,2(最小堆)</td>\n</tr>\n<tr>\n<td>直接插入</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(nlog2n)</td>\n<td>O(n^1.3)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/3,2,2(d=2/1)</td>\n</tr>\n<tr>\n<td>二路归并</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(n+r)</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p>最坏：</p>\n<p> 气泡排序：比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2  </p>\n<p>选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   </p>\n<p>插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)</p>\n<h4 id=\"七、外排序\"><a href=\"#七、外排序\" class=\"headerlink\" title=\"七、外排序\"></a>七、外排序</h4><h5 id=\"磁盘文件的归并排序\"><a href=\"#磁盘文件的归并排序\" class=\"headerlink\" title=\"磁盘文件的归并排序\"></a>磁盘文件的归并排序</h5><p>方法：多路归并 、 I/O并行处理  、生成初始归并段</p>\n<ul>\n<li>磁盘文件的归并排序</li>\n</ul>\n<p>第一阶段：初始归并段形成 </p>\n<p>第二阶段：多路归并 </p>\n<ul>\n<li>多路归并-减少归并遍数</li>\n</ul>\n<p>一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。</p>\n<p>在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）<em>(K-1)</em>[logkm]=（n-1）<em>(K-1) </em>[log2(m/log2K)]</p>\n<ul>\n<li>K 路平衡归并与选择树</li>\n</ul>\n<p>第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) </p>\n<p>而后每次重新建造选择树所需时间为： O( log2k ) </p>\n<p>n 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间：                                    O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 </p>\n<p>归并遍数为 logkm，总时间为：                                                                                             O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )</p>\n<ul>\n<li><p>并行操作的缓冲区处理</p>\n<p>​                    ——-使输入、输出和CPU处理尽可能重叠</p>\n</li>\n</ul>\n<p>对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作</p>\n<ul>\n<li>生成初始归并段（使用选择树法）：多路平衡归并</li>\n</ul>\n<p>假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：<br>(1) 从FI输入P个记录到缓冲区W;<br>(2)从W中选择出关键字最小的记录MIN；<br>(3)将MIN记录输出到FO中去；<br>(4)若FI不空，则从FI输入下一个记录到W;<br>(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN;<br>(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中<br>(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段</p>\n<p>生成的初始归并段的平均长度是缓冲区长度的两倍</p>\n<p>最佳归并树：使外存读写次数最少，是一棵正则树</p>\n<p>对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1</p>\n<p>加入细节点：</p>\n<ul>\n<li>已知前序和后序不能确定唯一二叉树</li>\n<li>//判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号</li>\n<li><p>树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树</p>\n</li>\n<li><p>解决冲突的方法：线性再散列、内散列表、外散列表</p>\n</li>\n<li><p>左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针</p>\n</li>\n<li><p>折半查找树高度： (n+1)/nlog2(n+1)-1</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h4><h5 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h5><ul>\n<li><p>抽象数据类型:(Abstract Date Type)</p>\n<p>  -定义：一个数学模型和该模型上定义的操作集合的总称</p>\n<p>  *ADT是程序设计语言中数据类型概念的进一步推广和进一步抽象</p>\n<p>  *同一数学模型上定义的不同操作集，则他们代表不同的ADT</p>\n<p>  -表现：用适当的数据结构来表示ADT中的数学模型，并用一组函数(方法)来实现该模型上的各种操作</p>\n</li>\n<li><p>逻辑结构：</p>\n<p>集合——没关系</p>\n<p>线性表——1:1前后</p>\n<p>树——1：m层次</p>\n<p>图——网状</p>\n</li>\n<li><p>存储结构：</p>\n<p>​    顺序——连续空间          $\\Rightarrow$索引</p>\n<p>​    链式——不连续空间          +散列</p>\n</li>\n</ul>\n<h5 id=\"算法及算法分析\"><a href=\"#算法及算法分析\" class=\"headerlink\" title=\"算法及算法分析\"></a>算法及算法分析</h5><ul>\n<li><p>算法的相关概念</p>\n<p>  -算法(Algorithm):是对特定问题求解步骤的一种描述，是指令的有限序列</p>\n<p>  -五大特性：输入   输出   有穷性   确定性</p>\n</li>\n<li><p>时间复杂度（time  xomplexity)</p>\n<p>  算法的执行时间，是基本(操作)语句重复执行的次数，它是问题规模的一个函数，我们把这个函数的渐进阶成为该算法的时间复杂度</p>\n</li>\n<li><p>常见时间复杂度的比较</p>\n</li>\n</ul>\n<p>0(1)&lt; &lt;0(logn) &lt;&lt;0(n)&lt; &lt; 0(nlogn) &lt;&lt; 0(n2) &lt;&lt; 0(n3) &lt;&lt;0(2n) &lt;&lt; 0(n!)</p>\n<ul>\n<li>常见设计方法：</li>\n</ul>\n<p>穷举、贪心、递归/分治(二分检索、快排)、回溯(树、图的深度优先搜索)、动态规划(最佳二叉排序树)</p>\n<p>$\\alpha -\\beta$裁剪和分支界限法、并行算法</p>\n<ul>\n<li>时空资源的折中原理</li>\n</ul>\n<p>同一个问题求解，一般会存在多种算法，这些算法在时空开销上往往表现出“时空折中”（trade-off）的性质</p>\n<h5 id=\"逐步求精的程序设计方法\"><a href=\"#逐步求精的程序设计方法\" class=\"headerlink\" title=\"逐步求精的程序设计方法\"></a>逐步求精的程序设计方法</h5><p>​    模型化-确定算法-逐步求精    </p>\n<h4 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h4><h5 id=\"线性表的抽象数据类型\"><a href=\"#线性表的抽象数据类型\" class=\"headerlink\" title=\"线性表的抽象数据类型\"></a>线性表的抽象数据类型</h5><p>​     顺序表：指用一组地址连续的存储单元依次存储线性表的数据元素</p>\n<h5 id=\"线性表的实现\"><a href=\"#线性表的实现\" class=\"headerlink\" title=\"线性表的实现\"></a>线性表的实现</h5><p>存储结构的三种方式：</p>\n<p> ① 连续的存储空间（数组） →  静态存储</p>\n<p> ② 非连续存储空间——指针（链表） →  动态存储</p>\n<p> ③ 游标（连续存储空间+动态管理思想）→  静态链表</p>\n<h6 id=\"线性表的数组实现：\"><a href=\"#线性表的数组实现：\" class=\"headerlink\" title=\"线性表的数组实现：\"></a>线性表的数组实现：</h6><p>随机存储结构，查找快   o(1)</p>\n<p>插入和删除慢  o(n)</p>\n<p>空间固定</p>\n<h6 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h6><p>非随机存储结构</p>\n<p>eg:   求中点：定义两个指针方=放链表开头，一个速度为1，另一个指针速度为2</p>\n<p>​    求倒数第k个：定义两个指针，i放到开头，j放到第k位，同时速度为1向后走</p>\n<ul>\n<li><p>插入元素</p>\n<p>a、保存后继指针</p>\n<p>b、申请一个内存空间</p>\n<p>c、插入：先链接后部分，再衔接前部分</p>\n</li>\n</ul>\n<h6 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h6><p>元素是结构体数组，多个线性表公用一个存储池</p>\n<p>单链表逆置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一：</span></span><br><span class=\"line\"><span class=\"comment\">//设表头为L,算法如下: </span></span><br><span class=\"line\">p=L-&gt;next-&gt;next; q=p-&gt;next; L-&gt;next-&gt;next=<span class=\"literal\">NULL</span>; <span class=\"keyword\">while</span>(p!=null) &#123;</span><br><span class=\"line\">    p-&gt;next=L-&gt;next;</span><br><span class=\"line\">    L-&gt;next=p;</span><br><span class=\"line\">    p=q;</span><br><span class=\"line\">    q=q-&gt;next; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法二：</span></span><br><span class=\"line\"><span class=\"comment\">//线性表由q来表示 </span></span><br><span class=\"line\">p=null; w=q; <span class=\"keyword\">while</span>(w!=null) &#123; </span><br><span class=\"line\">    w=w-&gt;next; </span><br><span class=\"line\">    q-&gt;next=p;</span><br><span class=\"line\">    p=q; q=w; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h6><p>双向单链表插入与删除：</p>\n<p><img src=\"/img/ds/双向单链表.PNG\" alt=\"双向单链表\"></p>\n<h6 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h6><ul>\n<li><p>数组求模可以成环</p>\n</li>\n<li><p>判断链表是否成环：两个指针，速度分别为1和2,</p>\n</li>\n<li><p>确定环入口：</p>\n</li>\n<li><p>两个链表是否相交:判断两个列表最后一个元素是否相同//散列</p>\n</li>\n<li><p>单项循环链表插入与删除：</p>\n</li>\n</ul>\n<p><img src=\"/img/ds/双循环1.PNG\" alt=\"双循环1\"></p>\n<p><img src=\"/img/ds/双循环2.PNG\" alt=\"双循环2\"></p>\n<h5 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h5><ul>\n<li>多项式的代数运算</li>\n</ul>\n<p><img src=\"/img/ds/中缀转后缀表达式.PNG\" height=\"400px\"></p>\n<ul>\n<li><p>后缀表达式求值：</p>\n<p>对后缀表达式从左至右依次扫描，与Ⅰ相反，遇到操作数 时，将操作数进栈保留；当遇到操作符时，从栈中退出两个操 作数并作相应运算，将计算结果进栈保留；直到表达式结束， 栈中唯一元素即为表达式的值。                                    遇到“（”进栈，当遇到“）”时，退栈输出直到“）” 为止。</p>\n</li>\n</ul>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>优先队列：</p>\n<p>问题：如何解决循环队列中队空与队满状态相同？<br>方法一：约定队列头指针在队列尾指针的下一位置上(即空出一个位置）；</p>\n<p> 方法二：另设一个标志位用以区别队空与队满两种状态；<br>结论：两种方法的代价是相同的。</p>\n<h5 id=\"串（String）\"><a href=\"#串（String）\" class=\"headerlink\" title=\"串（String）\"></a>串（String）</h5><p>KMP算法：</p>\n<p>一、如何求next函数:</p>\n<ul>\n<li><p>当j=1时，next[j]=-1； //next[j]=-1表示根本不进行字符比较 </p>\n</li>\n<li><p>当j&gt;1时，next[j]的值为：模式串的位置从1到j-1构成的串 中所出现的首尾相同的子串的最大长度。</p>\n</li>\n<li>当无首尾相同的子串时next[j]的值为0。 //next[j]=0表示从模式串头部开始进行字符比较</li>\n</ul>\n<p>下面给出求next函数的伪码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"keyword\">int</span> &amp;next[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//求模式串T的next函数并存入next数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">while</span> (i &lt; T[<span class=\"number\">0</span>]) <span class=\"comment\">//T[0]中存放数组长度 &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span>( j==<span class=\"number\">0</span>||T[i]==T[j]) &#123; ++i; ++j;  next[i]=j; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span> j= next[j]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;<span class=\"comment\">//get_next</span></span><br></pre></td></tr></table></figure>\n<p>二、KMP算法实现步骤：</p>\n<p>   1.在串S和串T中分别设比较的起始下标i和j；</p>\n<ol start=\"2\">\n<li>循环直到S中所剩字符长度小于T的长度或T中所有字 符均比较完毕<br>2.1如果S[i]=T[j]，继续比较S和T的下一个字符；否则<br>2.2将j向右滑动到next[j]位置，即j=next[j]；<br>2.3 如果j=0，则将i和j分别加1，准备下一趟比较；</li>\n<li>如果T中所有字符均比较完毕，则返回匹配的起始下标； 否则返0；</li>\n</ol>\n<h5 id=\"广义表\"><a href=\"#广义表\" class=\"headerlink\" title=\"广义表\"></a>广义表</h5><p>例如：</p>\n<p> A = （a，（b，a，b），（），c，（（（2））））； </p>\n<p>B = （）； C = （e ）； D = （A，B，C ）； E = （a，E ）；</p>\n<p>长度：广义表LS中的直接元素的个数；<br>深度：广义表LS中括号的最大嵌套层数。<br>表头：广义表LS非空时，称第一个元素为LS的表头；<br>表尾：广义表LS中除表头外其余元素组成的广义表。</p>\n<h4 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h4><h5 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h5><h6 id=\"性质：\"><a href=\"#性质：\" class=\"headerlink\" title=\"性质：\"></a>性质：</h6><p>在非空二叉树中，如果叶子结点数为n0，出度为2的结点数为n2，则有: n0＝n2＋11，而与出度数为1的结点数n1无关</p>\n<h6 id=\"建立\"><a href=\"#建立\" class=\"headerlink\" title=\"建立\"></a>建立</h6><p>建立：</p>\n<p><img src=\"/img/ds/建立1.PNG\" alt=\"建立1\"></p>\n<p>先序建立：</p>\n<p><img src=\"/img/ds/先序建立.PNG\" alt=\"先序建立\"></p>\n<p>非递归建立：</p>\n<p><img src=\"/img/ds/建立非.PNG\" alt=\"建立非\"></p>\n<h6 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h6><ul>\n<li>先序递归：</li>\n</ul>\n<p><img src=\"/img/ds/先序.PNG\" alt=\"先序\"></p>\n<ul>\n<li>先序非递归：</li>\n</ul>\n<p>1.栈s初始化；<br>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 输出root-&gt;data;<br>         2.1.2 将指针root的值保存到栈中；<br>​        2.1.3 继续遍历root的左子树<br>​    2.2 如果栈s不空，则<br>​        2.2.1 将栈顶元素弹出至root；<br>​        2.2.2 准备遍历root的右子树；</p>\n<ul>\n<li>中序非递归：</li>\n</ul>\n<p>1.栈s初始化； </p>\n<p>2.循环直到root为空且栈s为空<br>​    2.1 当root不空时循环<br>​        2.1.1 将指针root的值保存到栈中；<br>         2.1.2 继续遍历root的左子树<br>     2.2 如果栈s不空，则<br>         2.2.1 将栈顶元素弹出至root；<br>         2.2.2 输出root-&gt;data;<br>​        2.2.3 准备遍历root的右子树</p>\n<ul>\n<li>后序非递归：</li>\n</ul>\n<ol>\n<li>栈s初始化； </li>\n<li>循环直到root为空且栈s为空<br> 2.1 当root非空时循环<br> ​    2.1.1 将root连同标志flag=1 入栈；<br> ​    2.1.2 继续遍历root的左子树；<br> 2.2 当栈s 非空且栈顶元素的标志为2 时，出栈并输出栈 顶结点;<br> 2.3 若栈非空，将栈顶元素的标志改为2，准备遍历栈顶结 点的右子树；</li>\n</ol>\n<p><img src=\"/img/ds/二叉树先序遍历.PNG\" height=\"400px\"></p>\n<ul>\n<li>层序遍历：</li>\n</ul>\n<ol>\n<li>队列Q初始化；</li>\n<li>如果二叉树非空，将根指针入队；</li>\n<li>循环直到队列Q为空<br>3.1 q=队列Q的队头元素出队；<br>3.2 访问结点q的数据域；<br>3.3 若结点q存在左孩子，则将左孩子指针入队；<br>3.4 若结点q存在右孩子，则将右孩子指针入队；</li>\n</ol>\n<h6 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h6><ul>\n<li>1、已知先序中序确定二叉树：</li>\n</ul>\n<p>遍历前序序列的每个节点A【i】，在中序序列中找到相同节点B【j】，<br>​    如果栈为空，将下标 j 入栈；<br>​    否则，栈不为空：<br>​        如果 j 小于当前栈顶元素，则中序序列B【top】左孩子为 j，下标 j 入栈；否则，当 j 大于栈顶元素时且栈不为空，弹栈，循环后的栈顶top，B【top】的右孩子为 j ， j 入栈</p>\n<p><img src=\"/img/ds/已知先序中序构二叉树.PNG\" height=\"450px\"></p>\n<ul>\n<li>2、求二叉树任意两节点公共祖先：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;<span class=\"comment\">//如果当前节点为NULL说明走到了叶节点都没有找到两个节点中的其中一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == p || root == q) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;<span class=\"comment\">//如果当前节点为p,q之中的一个，那么返回当前找到的节点中的一个</span></span><br><span class=\"line\">    TreeNode *L = lowestCommonAncestor(root-&gt;left, p, q);<span class=\"comment\">//左子树中是否能最先找到p,q中的一个节点</span></span><br><span class=\"line\">    TreeNode *R = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L &amp;&amp; R) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;  <span class=\"comment\">//如果当前节点左右节点都各找到一个，那么返回当前节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> L ? L : R; <span class=\"comment\">//只在左节 点或者右节点找到一个，说明还有一个节点是在当前节点的下面</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>3、求二叉树宽度：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>  front=<span class=\"number\">-1</span>,rear=<span class=\"number\">-1</span>,count=<span class=\"number\">0</span>,max=<span class=\"number\">0</span>,right</span><br><span class=\"line\"><span class=\"keyword\">if</span> (T!=<span class=\"literal\">NULL</span>) </span><br><span class=\"line\">\tq[++rear]=T;max=<span class=\"number\">1</span>;right=rear; </span><br><span class=\"line\"><span class=\"keyword\">while</span>(front!=rear) &#123;</span><br><span class=\"line\">\tT=q[++front];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;lc!=<span class=\"literal\">NULL</span>)q[++rear]=T-&gt;lc; count++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(T-&gt;rc!=<span class=\"literal\">NULL</span> q[++rear]=T-&gt;rc; count++; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(front==right) &#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(max&lt;count)max=count; count=<span class=\"number\">0</span>;right=rear;&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>4、线索树：</li>\n</ul>\n<p>1）在中序线索二叉树中求一个结点p的中序后继p：</p>\n<p>​    当p-&gt;rtag==False时，p-&gt;rchild 即为所求(线索)。</p>\n<pre><code>当p-&gt;rtag==True时，p为p 的右子树的最左结点\n</code></pre><p>2）利用InNext（求中序后继节点）算法，中序遍历线索二叉树</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">void</span> ThInOrder(ThTree HEAD) &#123;  </span><br><span class=\"line\"><span class=\"attribute\">ThTree</span>   tmp ; <span class=\"attribute\">tmp</span> = HEAD ; </span><br><span class=\"line\">  <span class=\"section\">do</span> &#123; </span><br><span class=\"line\">  \t<span class=\"attribute\">tmp</span> = InNext ( tmp ) ; </span><br><span class=\"line\"> <span class=\"attribute\">if</span> ( tmp != HEAD ) visit ( tmp -&gt; data ) ;</span><br><span class=\"line\">&#125; <span class=\"attribute\">while</span> ( tmp != HEAD ) ; &#125;</span><br></pre></td></tr></table></figure>\n<p>  3）求中序线索二叉树中结点p 的先序顺序后继结点p* </p>\n<p>(1) p 的左子树不空时，p 的左儿子p-&gt;lchild 即为 p<em>；<br>(2) p 的左子树空但右子树不空时，p 的p-&gt;rchild 为p</em>；<br>(3) p 的左右子树均空时，右线索序列中第一个有右孩子 结点的右儿子或头结点即为p*.</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">THTREE PreNext( ThTree p) &#123;   </span><br><span class=\"line\">\tThTree Q ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p-&gt;ltag = = <span class=\"keyword\">True</span> ) Q=p-&gt;lchild ; </span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tQ = p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(Q-&gt;rtag = = <span class=\"keyword\">False</span>) Q = Q-&gt;rchild ; </span><br><span class=\"line\">\t\tQ = Q-&gt;rchild ;</span><br><span class=\"line\">\t&#125;  <span class=\"keyword\">return</span> ( Q ) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>相似二叉树:具有相同结构的二叉树为相似二叉树。 </p>\n</li>\n<li><p>相似且对应结点包含相同信息的二叉树称为等价二叉树。 </p>\n</li>\n</ul>\n<h5 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h5><p>最大堆：</p>\n<p>如果一棵完全二叉树的任意一个非终结结点的元素都不小于其 左儿子结点和右儿子结点（如果有的话）的元素，则称此完全二叉 树为最大堆</p>\n<ul>\n<li>大根堆插入：</li>\n</ul>\n<p>void Insert ( Heap &amp;heap，Elementtype x)//大根堆插入一个元素 {<br>​    int i;<br>​    if ( ! HeapFull ( heap ) ) {<br>​        i=heap.n+1;<br>​        while ( (i!=1)&amp;&amp;(x &gt;heap.ele [i/2] ) ) {<br>​            heap.ele [i]=heap.ele [i/2]; i=i/2;<br>     } heap.ele [i] = x;</p>\n<ul>\n<li>大根堆删除：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteMax</span> <span class=\"params\">(Heap &amp; heap )</span><span class=\"comment\">//大根堆删除 &#123;  </span></span></span><br><span class=\"line\"><span class=\"function\">\t<span class=\"keyword\">int</span> parent</span>=<span class=\"number\">1</span>, child=<span class=\"number\">2</span>;  Elementtype  ele,  tmp;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (! HeapEmpty(heap)) &#123; </span><br><span class=\"line\">\t\tele=heap.ele [<span class=\"number\">1</span>]; tmp=heap.ele [heap.n--];</span><br><span class=\"line\"> \t\t<span class=\"keyword\">while</span> (child&lt;= heap.n)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(child&lt;heap.n)&amp;&amp;(heap.ele [child]&lt;heap.ele [child+<span class=\"number\">1</span>])) \t\t\t\t\t\t\t\tchild++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp&gt;=heap.ele [child])  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\theap.ele [parent]=heap.ele [child]; </span><br><span class=\"line\">\t\t\tparent=child; child*=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"comment\">//while</span></span><br><span class=\"line\"> \t\theap.ele [parent]=tmp; <span class=\"keyword\">return</span> ele; </span><br><span class=\"line\">\t&#125;<span class=\"comment\">//if</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"选择树\"><a href=\"#选择树\" class=\"headerlink\" title=\"选择树\"></a>选择树</h5><p>​    胜者树、败者树</p>\n<h5 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h5><p>存储结构：</p>\n<p>双亲表示法（数组）、孩子链表表示法（邻接表）、双亲孩子表示法、二叉链表表示法（(左)孩子(右)兄弟链表表示））</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>树</th>\n<th>二叉树</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>节点关系</td>\n<td>兄弟关系</td>\n<td>双亲和右孩子</td>\n</tr>\n<tr>\n<td></td>\n<td>双亲和长子</td>\n<td>双亲和左孩子</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"森林与二叉树的相互转换\"><a href=\"#森林与二叉树的相互转换\" class=\"headerlink\" title=\"森林与二叉树的相互转换\"></a>森林与二叉树的相互转换</h5><ul>\n<li>森林转化成二叉树：</li>\n</ul>\n<p>1、连线： 把每株树的各兄弟结点连起来； 把各株树的根结点连起来（视为兄弟）</p>\n<p> 2、抹线： 对于每个结点，只保留与其最左儿子的连线，抹去该结 点与其它结点之间的连线 </p>\n<p>3、旋转： 按顺时针旋转45度角（左链竖画，右链横画）</p>\n<ul>\n<li>二叉树转化成森林（树）</li>\n</ul>\n<p>连线： 若某个结点 k 是其双亲结点的左孩子，则将该结点 k  的右孩子以及（当且仅当）连续地沿着右孩子的右链不 断搜索到的所有右孩子，都分别与结点k 的双亲结点相 连；</p>\n<p> 抹线： 把二叉树中的所有结点与其右孩子的连线以及（ 当且 仅当）连续地沿着右孩子的右链不断搜索到的所有右孩 子的连线全部抹去; </p>\n<p>旋转： 按逆时针旋转45度角（即把结点按层次排列）</p>\n<ul>\n<li>将一株树转换为二叉树，二叉树一定没有右子树</li>\n<li>一般结论：森林中的任何没有右兄弟的结点在对应的二叉 树中，该没有右子树；</li>\n<li><p>任何一个森林（树）对应唯一的一株二叉树，反之亦然。 且第一株树的根对应二叉树的根； 第一株树的所有子树对应二叉树的左子树； 其余子树森林对应二叉树的右子树；</p>\n</li>\n<li><p>森林(树)转换成二叉树的递归算法：</p>\n<p>F ={T1,T2, …,Tn}<br>二叉树B(F) 若n=0，则B(F)为空；否则，n〉0，则<br>B(F)的根就是root（T1）；<br>B(F)的左子树是F的第一棵树T1的子树森林；<br>B(F)的右子树F的其余子树森林。 </p>\n</li>\n<li><p>二叉树转换成森林(树) 的递归算法 ：</p>\n</li>\n</ul>\n<p>若B 为空，则F 为空；若B 不空，则<br> F中的第一株树T1 的根对应二叉树B 的根；<br> T1中根结点的子树森林F1是由B的左子树转换来的；<br> F中除T1之外其余子树组成的森林F’={T2,…Tn}是由B 的右子树转换而来的。</p>\n<h5 id=\"树的应用\"><a href=\"#树的应用\" class=\"headerlink\" title=\"树的应用\"></a>树的应用</h5><ul>\n<li><p>堆的复杂度：O(n)</p>\n</li>\n<li><p>败者树的复杂度：O(2n-1)</p>\n</li>\n</ul>\n<h6 id=\"用树结构表示集合：\"><a href=\"#用树结构表示集合：\" class=\"headerlink\" title=\"用树结构表示集合：\"></a>用树结构表示集合：</h6><p>等价分类算法： </p>\n<ol>\n<li><p>令S中的每一个元素自身构成一个等价类，S1,S2,…S7 </p>\n</li>\n<li><p>重复读入等价对（i,  j）<br>2.1对每个读入的等价对(i, j),求出i 和j 所在的集合Sk 和Sm （不失一般性）<br>2.2若Sk≠Sm,则将Sk并入Sm,并将Sk置空。</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Equivalence</span> <span class=\"params\">(MFSET S)</span>   <span class=\"comment\">//等价分类算法 &#123; </span></span></span><br><span class=\"line\">   int i ,j , k ,m; </span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n+<span class=\"number\">1</span>;i++) Initial(i,S);  <span class=\"comment\">//使集合S只包含元素i</span></span><br><span class=\"line\">   <span class=\"built_in\">cin</span>&gt;&gt;i&gt;&gt;j;        <span class=\"comment\">// 读入等价对</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(!(i==<span class=\"number\">0</span>&amp;&amp;j==<span class=\"number\">0</span>)&#123; <span class=\"comment\">// 等价对未读完</span></span><br><span class=\"line\">       k=Find(i,S);           <span class=\"comment\">//求i的根 </span></span><br><span class=\"line\">       m=Find(j,S);        <span class=\"comment\">// 求j的根</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(k!=m)          <span class=\"comment\">//if k==m,i,j已在一个树中，不需合并 </span></span><br><span class=\"line\">           Union(i,j,S);     <span class=\"comment\">//合并 </span></span><br><span class=\"line\">       <span class=\"built_in\">cin</span>&lt;&lt;i&lt;&lt;j;            &#125;  &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"判定树\"><a href=\"#判定树\" class=\"headerlink\" title=\"判定树\"></a>判定树</h6><p>判定树的特点：</p>\n<p> 一个判定树是一个算法的描述；<br>每个内部结点对应一个部分解； 每个叶子对应一个解；<br>每个内部结点连接与一个获得新信息的测试；<br> 从每个结点出发的分支标记着不同的测试结果；<br> 一个解决过程的执行对应于通过根到叶的一条路 一个判定树是所有可能的解的集合</p>\n<p>判断树高度：$h=\\frac{n+1}{n}log_2(n+1)-1$</p>\n<h6 id=\"哈夫曼树：\"><a href=\"#哈夫曼树：\" class=\"headerlink\" title=\"哈夫曼树：\"></a>哈夫曼树：</h6><ul>\n<li>内外路径：</li>\n</ul>\n<p><img src=\"/img/ds/内外路径.PNG\" alt=\"内外路径\"></p>\n<ul>\n<li>哈夫曼树性质：</li>\n</ul>\n<p>没有度数为1的结点 外结点数 =内结点数 + 1(为什么?) 有 n 个外结点的扩充二叉树共有 2n-1 个结点。</p>\n<p><img src=\"/img/ds/哈夫曼树性质1.PNG\" alt=\"哈夫曼树性质1\"></p>\n<ul>\n<li>码长计算：</li>\n</ul>\n<p><img src=\"/img/ds/码长计算.PNG\" alt=\"码长计算\"></p>\n<ul>\n<li>哈夫曼编码一定具有前缀性；<br>哈夫曼编码是最小冗余码;<br>哈夫曼编码方法，使出现概率大的字符对应的码长较短；<br>哈夫曼编码不唯一，可以用于加密；<br>哈夫曼编码译码简单唯一，没有二义性.</li>\n</ul>\n<h6 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h6><p>把中缀表达式转换为后缀表达式（栈结构、树结构）；根据后缀表 达式计算表达式的值</p>\n<p> 利用后序遍历算法，先计算左子树的值，然后再计算右子树的值。 当到达某结点时，该结点的左右操作数都以求出。</p>\n<h4 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h4><p>简单路径：若路径上各顶点 v1,v2,…,vm 均互不相同(第一个顶点和最后 一个顶点可以相同）, 则称这样的路径为简单路径。</p>\n<p> 简单回路：若路径上第一个顶点 v1与最后一个顶点vm重合, 则称这样 的简单路径为简单回路或环。 一条环路的长度至少为1（无向图为3），且起点和终点相同的简单路径。</p>\n<h5 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>空间性能</th>\n<th>时间性能</th>\n<th>唯一性</th>\n<th>适用范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>邻接矩阵</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>唯一</td>\n<td>稠密图</td>\n</tr>\n<tr>\n<td>邻接表</td>\n<td>O(n+e)</td>\n<td>O(n+e)</td>\n<td>不唯一</td>\n<td>稀疏图</td>\n</tr>\n</tbody>\n</table>\n<p>十字链表、邻接多重表</p>\n<h5 id=\"图的搜索\"><a href=\"#图的搜索\" class=\"headerlink\" title=\"图的搜索\"></a>图的搜索</h5><ul>\n<li>深度优先搜索</li>\n</ul>\n<p>从一个顶点出发的一次深度优先遍历算法：<br>实现步骤： </p>\n<ol>\n<li>访问顶点v; visited[v]=1; </li>\n<li>w=顶点v的第一个邻接点； </li>\n<li>while (w存在)<br>3.1 if (w未被访问) 从顶点w出发递归执行该算法;<br>3.2 w=顶点v的下一个邻接点;</li>\n</ol>\n<p>邻接矩阵：空间：O(n^2)       时间： O(n^2)</p>\n<p>邻接表：O(n)  O(V+E)</p>\n<ul>\n<li>广度优先搜索</li>\n</ul>\n<p>1 . 初始化队列Q;</p>\n<ol start=\"2\">\n<li>访问顶点v; visited [v]=1; 顶点v入队Q;</li>\n<li>while (队列Q非空)<br> 3.1 v=队列Q的队头元素出队;<br> 3.2 w=顶点v的第一个邻接点;<br> 3.3 while (w存在) <pre><code>3.3.1 如果w 未被访问，则 访问顶点w; visited[w]=1; 顶点w入队列Q；\n3.3.2 w=顶点v的下一个邻接点；\n</code></pre></li>\n</ol>\n<h5 id=\"图与树、最小生成树\"><a href=\"#图与树、最小生成树\" class=\"headerlink\" title=\"图与树、最小生成树\"></a>图与树、最小生成树</h5><h6 id=\"先深和先广生成森林\"><a href=\"#先深和先广生成森林\" class=\"headerlink\" title=\"先深和先广生成森林\"></a>先深和先广生成森林</h6><ul>\n<li>先深搜索对边的分类<br>两类:  树边—在搜索过程中所经过的边；回退边—图中的 其它边          特点: 树边是从先深编号较小的指向较大的顶点;回退边相 反;<br>结论:若G中存在环路,则在先广搜索过程中必遇到回退边;反之亦然</li>\n<li>先广搜索对边的分类<br>两类: 树边—在搜索过程中所经过的边；横边—图中的其 它边.            特点: 树边是从先深编号较小的指向较大的顶点; 而横边不一定与之相反，但可规定：大→小.<br>结论:若G中存在环路,则在先广搜索过程中必遇到横边;反之亦然</li>\n</ul>\n<h6 id=\"无向图与开放树\"><a href=\"#无向图与开放树\" class=\"headerlink\" title=\"无向图与开放树\"></a>无向图与开放树</h6><p>连通而无环路的无向图称作开放树（Free  Tree）</p>\n<p>（1）具有n≥1个顶点的开放树包含n-1条边； </p>\n<p>（2）如果在开放树中任意加上一条边，便得到一条回路</p>\n<h6 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h6><ul>\n<li>普里姆Prim算法：</li>\n</ul>\n<p>基本思想<br>① 首先从集合V中任取一顶点(如顶点v0)放入集合U中。这时U={v0}， 边集TE={ }<br>② 然后找出权值最小的边(u，v) ，且u∈U，v∈(V-U)，将边加入TE， 并将顶点v加入集合U<br>③ 重复上述操作直到U=V为止。这时TE中有n-1条边，T=(U，TE)就 是G的一棵最小生成树</p>\n<p>如何找到连接U和V-U的最短边 ：<br>利用MST性质，可以用下述方法构造候选最短边集：对于V-U 中的每个顶点，保存从该顶点到U中的各顶点的最短边。</p>\n<ol>\n<li><p>初始化两个辅助数组LOWCOST和CLOSEST；</p>\n</li>\n<li><p>输出顶点v0，将顶点v0加入集合U中；</p>\n</li>\n<li><p>重复执行下列操作n-1次<br>3.1 在LOWCOST中选取最短边，取CLOSEST中对应的顶点序号k；<br>3.2 输出顶点k和对应的权值；<br>3.3 将顶点k加入集合U中；<br>3.4 调整数组LOWCOST和CLOSEST；</p>\n<p>LOWCOST[j]=min { cost (vk，vj) | vj∈U, LOWCOST[j]}<br>CLOSEST[j]=k</p>\n</li>\n</ol>\n<p>时间复杂度：O(n^2)</p>\n<ul>\n<li>克鲁斯卡尔（Kruskal）算法</li>\n</ul>\n<p>注：边值各不相同时生成树唯一</p>\n<p>基本思想：<br>设无向连通网为G＝(V, E)，令G的最小生成树为T＝(U, TE)，其初 态为U＝V，TE＝{ }，<br>然后，按照边的权值由小到大的顺序，依次考察G的边集E中的各条 边。<br>若被考察的边连接的是两个不同连通分量，则将此边作为最小生成 树的边加入到T中，同时把两个连通分量连接为一个连通分量； 若被考察的边连接的是同一个连通分量，则舍去此边，以免造成回 路，<br>如此下去，当T中的连通分量个数为1时，此连通分量便为G的一棵 最小生成树。</p>\n<ol>\n<li>初始化：U=V； TE={ }； </li>\n<li>循环直到T中的连通分量个数为1<br> 2.1 在E中选择最短边(u，v);<br> 2.2 如果顶点u、v位于T的两个不同连通分量，则<br> ​    2.2.1 将边(u，v)并入TE；<br> ​    2.2.2 将这两个连通分量合为一个；<br> 2.3 在E中标记边(u，v)，使得(u，v)不参加后续最短边的选取</li>\n</ol>\n<p>时间复杂度：O(eloge)</p>\n<h5 id=\"无向图的双连通性\"><a href=\"#无向图的双连通性\" class=\"headerlink\" title=\"无向图的双连通性\"></a>无向图的双连通性</h5><p>若在删去顶点 v 以及与之相邻的边之后，将图的一个连通分量分割成两个或 两个以上的连通分量，则称该顶点为关节点。</p>\n<p>1、没有关节点的连通图称为双连通图。<br>2、双连通的无向图是连通的，但连通的无向图未必双连通。<br>3、一个连通的无向图是双连通的，当且仅当它没有关节点。<br>4、在双连通图上, 任何一对顶点之间至少存在有两条路径，在删去某个顶点 及与该顶点相关联的边时, 也不破坏图的连通性。<br>5、一个连通图G如果是重连通图，那么它可以包括几个双连通分量。</p>\n<ul>\n<li><p>由先深生成树可得出两类关节点的特性：</p>\n<p>1、若生成树的根有两株或两株以上子树，则此根结点必为关节（第一类关 节点）。因为图中不存在连接不同子树中顶点的边，因此，若删去根顶 点，生成树变成生成森林。 </p>\n</li>\n</ul>\n<p>2、若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向 v 的祖先的回退边，则v 是关节点（第二类关节点）。 因为删去v，则其 子树和图的其它部分被分割开来</p>\n<p>算法要点：<br> 1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成 先深生成树S＝（V,T）。<br> 2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：<br> (1)  dfn[v]；<br> (2)  dfn[w]，凡是有回退边（v,w）的任何结点w；<br> (3)  low[y]，对v的任何儿子y。<br> 3.求关节点： (1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）； (2)非树根结点v是关节点当且仅当v有某个儿子y，使 low[y]≥dnf[v]（第二类关节点）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//求双连通分量的算法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">count = <span class=\"number\">1</span>; <span class=\"keyword\">for</span> (all v ∈ V)  mark v “<span class=\"keyword\">new</span>”; searchB( v0 );&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//v0是V中任一结点,建立以v0为根的先深生成树,计算low(v)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">searchB</span><span class=\"params\">(v)</span> </span>&#123; </span><br><span class=\"line\">mark v “old”;</span><br><span class=\"line\">dfn[v] = count;count++; </span><br><span class=\"line\">low[v]=dfn[v]; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> (each w ∈ L[v])</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (w is marked “<span class=\"keyword\">new</span>”) &#123; </span><br><span class=\"line\">         father [w]=v；searchB (w); </span><br><span class=\"line\">         low [v]= min &#123; low [v], low [w] &#125;; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (low[w]&gt;=dfn[v]) <span class=\"comment\">//表明W及子孙均无指向V的祖先的回退边，v是关节点                   \t\t\tcout&lt;&lt;“a biconnected component”; &#125; </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (w != father [v]) <span class=\"comment\">//(v ,w)是回退边   </span></span><br><span class=\"line\">          low [v]= min &#123; low [v],  dfn [w] &#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h5><p>是由某个集合上的一个偏序得到该集合上的一个全序的过程。所得到 的线性序列称为拓扑序列。（不唯一） </p>\n<p>实质：广度优先搜索算法</p>\n<p>AOV网（有向图）</p>\n<ul>\n<li><p>利用队列算法：<br>1.建立入度为零的顶点排队<br>2.扫描顶点表，将入度为0的顶点入队；<br>3.while（排队不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入队 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n<li><p>利用栈算法：<br>1.建立入度为零的顶点栈<br>2.扫描顶点表，将入度为0的顶点栈；<br>3.while（栈不空）{<br>输出队头结点； 记下输出结点的数目；<br>删去与之关联的出边； 若有入度为0的结点，入栈 }<br>4.若输出结点个数小于n，则输出有环路；否则拓扑排序 正常结束。</p>\n</li>\n</ul>\n<p>注：图中还有未输出的顶 点, 但已跳出循环处 理。说明图中还剩下 一些顶点, 它们都有 直接前驱。这时网络 中必存在有向环；或 全部顶点均已输出， 拓扑有序序列形成， 拓扑排序完成。</p>\n<ul>\n<li>说明：<br>与先广搜索的差别：<br>​      搜索起点是入度为0的顶点；<br>​      需判断是否有环路；<br>​      需对访问并输出的顶点计数（引入计数器nodes）。<br>​      需删除邻接于 v 的边（引入数组indegree[ ]或在顶点表中增加一 个属性域indegree）。<br>也可以采用栈数据结构进行广度优先拓扑排序。<br>亦可采用无后继顶点优先的拓扑排序算法<br>也可以利用DFS遍历进行拓扑排序</li>\n<li>基于DFS的拓扑排序</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">topodfs</span> <span class=\"params\">( v )</span> </span>&#123;   </span><br><span class=\"line\">    Push( v ,S ) ; </span><br><span class=\"line\">    mark[v]=True; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( L[v] 中的每一个顶点w) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( mark[w] = False ) topodfs ( w ) ; </span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( Top( S ) ) ; </span><br><span class=\"line\">    Pop ( S ) ; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span>  dfs-topo ( GRAPH  L ) &#123;  </span><br><span class=\"line\">    MakeNull( S ); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n; u++) </span><br><span class=\"line\">        mark[u]=False; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>( u=<span class=\"number\">1</span>;u&lt;=n;u++) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !mark[u] ) </span><br><span class=\"line\">            topodfs( u ) ;</span><br></pre></td></tr></table></figure>\n<p>思想：借助栈，在DFS中，把第一次 遇到的顶点入栈，到达某一顶点递归 返回时，从栈中弹出顶点并输出。</p>\n<h5 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h5><p>AOE网：带权有向图，顶点表示事件，用边表示活动，边上权表示活 动的开销（如持续时间）</p>\n<p>最大长度的路径称为关键路径。<br>一个AOE中，关键路径可能不只一条。<br>关键活动：关键路径上的活动称为关键活动。</p>\n<p>关键路径算法步骤：</p>\n<p>（1）前进阶段：计算VE[j]。从源点V1出发，令VE(1) = 0，按拓扑序列 次序求出其余各顶点事件的最早发生时间: j∈T VE(j) = max{ VE(i)+ACT[i][j 】}<br>其中T是以顶点Vj为尾的所有边的头顶点的集合(2≤j≤n) 如果网中有回路，不能求出关键路径则算法中止；否则转（2）</p>\n<p>（２）回退阶段：计算VL[j]从汇点Vn出发，令VL(n) = VE(n)，按逆 拓扑有序求其余各顶点的最晚发生时间(用逆邻接矩阵ACT转置即可） ： VL(j) = min{ VL(i)-ACT[j][i】 }<br>其中S是以顶点Vj为头的所有边的尾顶点的集合(2≤j≤n-1) k∈S</p>\n<p>（３）计算E( i ) 和L( i ) 求每一项活动ai的最早开始时间: E( i ) = VE( j ) 求每一项活动ai的最晚开始时间: L( i ) = VL( k ) -ACT[j][k】 </p>\n<p>（４）若某条边满足E( i ) = L( i )，则它是关键活动。</p>\n<p>注：为了简化算法,  可以在求关键路径之前已经对各顶点实现拓扑排 序,  并按拓扑有序的顺序对各顶点重新进行了编号。</p>\n<h5 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h5><ul>\n<li>边上权值非负情形的单源最短路径问题 — Dijkstra算法 </li>\n</ul>\n<p>Dijkstra算法实现步骤：</p>\n<ol>\n<li>将Ｖ分为两个集合S（最短路径已经确定的顶点集合）和V-S（最短路径尚未确定的顶点集合。初始时，S={ 1 }，D[i]=C[1】[i】（i=2,3,…n ），P[i】=1(源点，i≠1) 。</li>\n<li>从S之外即V-S中选取一个顶点w，使D[w]最小（即选这样的w， D[w]=min{ D[i]| i∈V-S }） ，于是从源点到达w只通过S中的顶点，且是一条最短路径（选定路径），并把w加入集合S。</li>\n<li>调整D中记录的从源点到V-S中每个顶点的最短距离，即从原来的 D[v]和D[w]＋C[w】[v】中选择最小值作为D[v]的新值，且P[v]=w。 </li>\n<li>重复2和3，直到S中包含V的所有顶点为止。结果数组Ｄ就记录了 从源到V中各顶点的最短 距离（数组P记录最短路径）。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">costtype <span class=\"title\">MinCost</span> <span class=\"params\">(D, S)</span> </span>&#123; </span><br><span class=\"line\">temp = INFINITY ; w = <span class=\"number\">2</span> ;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n ; i++ )</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!S[i]&amp;&amp;D[i]&lt;temp)  &#123;</span><br><span class=\"line\">  \t\ttemp = D[i] ; w = i ; &#125; </span><br><span class=\"line\"><span class=\"keyword\">return</span>  w ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">Dijkstra</span><span class=\"params\">(GRAPH  C, costtype D[n+<span class=\"number\">1</span>] ，<span class=\"keyword\">int</span> P[n+<span class=\"number\">1</span>]，<span class=\"keyword\">bool</span> S[n+<span class=\"number\">1</span>])</span> </span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">for</span> ( i=<span class=\"number\">2</span> ; i&lt;=n; i++ ) &#123;  </span><br><span class=\"line\">\tD[i]=C[<span class=\"number\">1</span>】[i】 ; S[i]=False ;P[i]=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">S [<span class=\"number\">1</span>]= True ; </span><br><span class=\"line\"><span class=\"keyword\">for</span>( i=<span class=\"number\">1</span>; i&lt;=n<span class=\"number\">-1</span>; i++) &#123;  </span><br><span class=\"line\">\tw=MinCost ( D, S ) ; S[w]=True ; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( v=<span class=\"number\">2</span> ; v&lt;= n ; n++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( S[v]!=True ) &#123;  </span><br><span class=\"line\">        \t        sum=D[w] + C[w】[v】 ;</span><br><span class=\"line\"> \t\t\t<span class=\"keyword\">if</span> (sum &lt; D[v】 )&#123;D[v】 = sum ; P[v]=w;&#125;</span><br><span class=\"line\">\t\t&#125; &#125; &#125;<span class=\"comment\">//   时间复杂度：O（n^2）</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有顶点之间的最短路径问题 — Floyd算法 </li>\n</ul>\n<p>基本思想：动态规划</p>\n<p>求解过程：</p>\n<p>设 C  为 n 行 n 列的代价矩阵，c[ i, j ] 为 i —&gt; j 的权值。如果 i=j ；那么 c[ i, j ] = 0。如果 i 和 j 之间无有向边； 则 c[ i, j ] = ∞</p>\n<p> 1、使用 n  行 n 列的矩阵A 用于计算最短路径。 初始时，A[ i, j ] = c[ i, j ] </p>\n<p>2、进行 n 次迭代 在进行第 k 次迭代时，将使用如下的公式：  Ak[ i, j ] = min {Ak-1[ i, j ]，Ak-1[ i, k ]  +  Ak-1[ k, j ]  }注意：第 k 次迭代时，针对结点 k 进行。原Ak-1矩阵 的第 k行，第 k 列保持不变。左上至右下的对角线元素 也不 变。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Floyd</span><span class=\"params\">( costtype A[][], costtype C[][], <span class=\"keyword\">int</span> P[][], <span class=\"keyword\">int</span> n)</span> </span>&#123;   </span><br><span class=\"line\"><span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ )</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j&lt; n; j++ ) &#123;</span><br><span class=\"line\">\t\tA[i][j] = C[i][j];  P[i][j] = <span class=\"number\">-1</span>； &#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( k = <span class=\"number\">0</span>; k &lt; n; k++ ) </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; n; i++ ) </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt; n; j++ )</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( A[i][k] + A[k][j] &lt; A[i][j] ) \t\t\t\t&#123; A[i][j] = A[i][k] + A[k][j] ; P[i][j] = k;&#125; </span><br><span class=\"line\">&#125; <span class=\"comment\">/* 时间复杂度：O(n3) */</span></span><br><span class=\"line\">Warshall算法 求有向图邻接矩阵C的传递闭包D A[i][j]=A[i][j]∪(A[i][k]∩A[k][j]) ; 可以判定有向图任意两点间是否存在有向 路。</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><h5 id=\"线性查找\"><a href=\"#线性查找\" class=\"headerlink\" title=\"线性查找\"></a>线性查找</h5><p>插入和删除：从后往前</p>\n<p>第0个元素做为伪记录或哨兵 </p>\n<h5 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h5><p>折半查找只适合于静态查找</p>\n<ul>\n<li><p>数组：时间复杂度O(logn)</p>\n</li>\n<li><p>判定树:</p>\n</li>\n</ul>\n<p>高度： (n+1)/nlog2(n+1)-1</p>\n<p>当n 很大时，ASLbs≈ log2(n+1)-1作为查找成功时的平均查找长度；在查找不成功和最坏情况下查找成功所需关键字的比较次数都不超过判 定树的高度；折半查找的最坏性能与平均性能相当接近</p>\n<h5 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h5><p>基本思想：均匀分块，块间有序，块内无序</p>\n<p>索引表：建一个线性表，用以存放每块中最大(或最小)的关键 字，此线性表称为索引表，它是一个有序表.</p>\n<p>块内的平均查找长度： ASLblk=∑ pi · ci =  — ∑ j </p>\n<p>所以分块查找平均长度为： ASL(L)=ASLix+ ASLblk = (b+1)/2+(L+1)/2=(n/L+L)/2+1 可证明，当$L=\\sqrt{n}$时，ASL(L) = $\\sqrt{n +1}$ （最小值）。</p>\n<h5 id=\"BST-二叉查找树\"><a href=\"#BST-二叉查找树\" class=\"headerlink\" title=\"BST-二叉查找树\"></a>BST-二叉查找树</h5><ul>\n<li><p>插入：若二叉排序树为空树，则 新插入的结点为根结点； 否则，新插入的结点必为 一个新的叶结点. </p>\n</li>\n<li><p>删除：</p>\n</li>\n</ul>\n<ol>\n<li>若结点p是叶子，则直接删除结点p； </li>\n<li>若结点p只有左子树，则p的左子树继承；若结点p只有右子树，则p的右子树继承 ； </li>\n<li>若结点p的左右子树均不空，则<br> 3.1 查找结点p的右子树上的最左下结点s及其双亲结点par；<br> 3.2 将结点s数据域替换到被删结点p的数据域；<br> 3.3 若结点p的右孩子无左子树，则将s的右子树接到par的右子树上； 否则，将s的 右子树接到结点par的左子树上；<br> 3.4 删除结点s；</li>\n</ol>\n<ul>\n<li>性能：</li>\n</ul>\n<p>二叉排序树的查找性能取决于二叉排序树的形态，在 O (log2n )和 O ( n ) 之间。</p>\n<p> 在最坏情况下，二叉查找树是通过把有序表的n 个结点依次插入而生 成的，此时所得到的二叉查找树退化为一株高度为n 的单支树，它的 平均查找长度和单链表上的顺序查找相同，(n+1)/2。</p>\n<p> 在最好情况下，二叉查找树的形态比较均匀，最终得到一株形态与折 半查找的判定树相似，此时的平均查找长度约为log2n。 二叉查找树的平均高度为O(log2n)。因此平均情况下，三种操作的平均时间复杂性为O(log2n) </p>\n<p>就平均性能而言，二叉查找树上的查找与二分查找差不多 ；就维护表的有序性而言，二叉查找树更有效。</p>\n<h5 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a>AVL树</h5><p>AVL树或者是空二叉树，或者是具有如下性质的BST： 根结点的左、右子树高度之差的绝对值不超过1； 且根结点左子树和右子树仍然是AVL树。<br>令Nh是高为h的AVL树中结点个数的最小值，在最稀疏情况下，这棵 AVL树的一棵子树的高度为h–1，而另一棵子树的高度为h–2，这两棵子 树也都是AVL树。<br>因此， Nh =Nh-1+Nh-2+1，其中N0=0，N1=1，N2=2。 可以发现， Nh的递归定义与Fibonacci数的定义Fn = Fn-1 + Fn-2（其中 F0 = 0，F1 =1）相似 可以用数学归纳法证明，Nh = Fh+2–1 （h ≥ 0）<br>Fh≈φh/√5,其中φ=(1+√5 )/2，所以，Nh≈φh+2/√5-1<br>所以，一棵包含n个结点的AVL树，其高度h至多为logφ(√5(n+1))–2<br>因此，对于包含n个结点的AVL树，其最坏情况下的插入时间为O(log n)</p>\n<h5 id=\"B-树和B-树\"><a href=\"#B-树和B-树\" class=\"headerlink\" title=\"B-树和B+树\"></a>B-树和B+树</h5><ul>\n<li>B-树</li>\n</ul>\n<p>树中可容纳结点数量最大值，关键字个数最多：m^h-1</p>\n<p>树中每个结点至多有m棵子树； 根结点至少有 2 棵子树；</p>\n<p> 除根结点和失败结点外，所有结点至少有 m/2 棵子树； </p>\n<p>所有的终端结点和叶子结点（失败结点）都位于同一层。</p>\n<p>h 层 至少有2 *(m / 2)^( h-2)个结点(不算h+1层)</p>\n<p>关键字个数N：N +1 = 位于第 h+1 层的结点数 &gt;= 2 *(m / 2)^ (h -1)</p>\n<p>N+1&gt;= 2 *(m / 2)^ (h -1)  ;    h-1 &lt;= log(m / 2)(( N + 1 ) / 2 ) </p>\n<ul>\n<li>B+树</li>\n</ul>\n<p>(1) 有k个子结点的结点必然有k个关键字；</p>\n<p> (2)所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针， 且叶子结点本身依关键字的大小自小而大顺序链接。<br>3阶B+树<br>（3）所有的非终结结点可以看成是索引部分，结点中仅含其子树（根结点）中的 最大（或最小）关键字。<br>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>\n<p>（4）可对B+树进行两种查找操作： 一种是沿叶结点链顺序查找， 另一种是从根结点开始，进行自顶向下，直至叶结点的随机查找。</p>\n<h5 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h5><p>不同的关键字具有相同散列地址的现象称为散列冲突（碰撞）。而发 生冲突的两个关键字称为同义词</p>\n<p>散列函数的构造的原则： 计算简单、分布均匀</p>\n<ul>\n<li><p>构造方法：<br>直接定制法、质数除冗法、平方取中法、折叠法、数字分析法、随机数法、</p>\n</li>\n<li><p>冲突处理：</p>\n</li>\n</ul>\n<p>1、开放定址法：<br>–线性探测法 ：当发生冲突时，从冲突位置的下一个位置起，依次寻找空的 散列地址                                                                                                                               –线性补偿探测法：当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1c，2c，…）<br>–二次探测法:当发生冲突时，寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （di=1^2，－1^2，2^2，－2^2，…，q^2，－q^2且q≤B/2）<br>–随机探测法：当发生冲突时，下一个散列地址的位移量是一个随机数列， 即寻找下一个散列地址的公式为： hi=(h(key)＋di) % B （其中，d1, d2, …,dB-1是1, 2, …, B-1的随机序列。） </p>\n<p>2、带溢出表的内散列法：（一个）主表及其溢出表元素的散列地址相同; 空间利用率不高</p>\n<p>3、拉链法\\链地址法：</p>\n<h4 id=\"内部排序\"><a href=\"#内部排序\" class=\"headerlink\" title=\"内部排序\"></a>内部排序</h4><h5 id=\"气泡排序\"><a href=\"#气泡排序\" class=\"headerlink\" title=\"气泡排序\"></a>气泡排序</h5><p>最好情况（正序）: 比较次数：n-1 移动次数：0 时间复杂度： O(n)； </p>\n<p>最坏情况（反序）： 比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2         时间复杂度： O(n^2)</p>\n<p>平均情况：时间复杂度为O(n^2)  </p>\n<p>空间复杂度： O(1)</p>\n<h5 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h5><p>对气泡排序的改进</p>\n<p>最好情况： 时间复杂度为O(nlog2n) 空间复杂度为O(log2n)</p>\n<p>最坏情况： 时间复杂度为O(n^2)   空间复杂度为O(n)</p>\n<p>平均情况： 时间复杂度为O(nlog2n)     空间复杂度为O(log2n)</p>\n<h5 id=\"直接选择排序\"><a href=\"#直接选择排序\" class=\"headerlink\" title=\"直接选择排序\"></a>直接选择排序</h5><p>移动次数： 最好情况（正序）：0次   最坏情况：3(n-1)次</p>\n<p>比较次数：n(n-1)/2</p>\n<p>时间复杂度为O(n^2)</p>\n<p> 空间复杂度为O(1)</p>\n<h5 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h5><p>对直接选择排序的改进</p>\n<p>首先将待排序的记录序列用完全二叉树表示；<br>然后完全二叉树构造成一个堆，此时，选出了堆中所有记录关键字的最小者；<br>最后将关键字最小者从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的关键字记录，以此类推，直到堆中只有一个记录。</p>\n<p>堆排序：令i = n, n-1 ,…, 2 </p>\n<p>1.交换：把堆顶元素(当前最小的)与位置 i(当前最大的叶结点下标) 的元素交换，即执行swap(A[1],A[i])；<br>2.整理:把剩余的 i-1个元素整理成堆，即执行PushDown(1 , i-1)；<br>3.重复执行完这一过程之后，则A[1],A[2],…,A[n]是按关键字不增顺 序的有序序列。</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(1)</p>\n<h5 id=\"（直接）插入排序\"><a href=\"#（直接）插入排序\" class=\"headerlink\" title=\"（直接）插入排序\"></a>（直接）插入排序</h5><p>最好情况下（正序）： 比较次数：n-1 移动次数：0 时间复杂度为O(n)</p>\n<p>最坏情况下（反序）：  比较次数：（n+2)(n-1)/2 移动次数：(n+4)(n-1)/2 时间复杂度为O(n^2)</p>\n<p>最好情况下（正序）： 比较次数：(n+2)(n-1)/4 移动次数：(n+4)(n-1)/4  时间复杂度为O(n^2)</p>\n<h5 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h5><p>对直接插入排序的改进</p>\n<p>时间性能：在O(n^2)和O(nlog2n)之间。</p>\n<p>当n在某个 特定范围内，希尔排序所需的比较次数和记录的移动次数约为O(n^1.3 ) </p>\n<h5 id=\"二路-归并排序\"><a href=\"#二路-归并排序\" class=\"headerlink\" title=\"(二路)归并排序\"></a>(二路)归并排序</h5><p>基本思想：自底向上的非递归算法</p>\n<p>时间复杂度：O(nlog2n)</p>\n<p>空间复杂度：O(n)</p>\n<h5 id=\"基数排序–多关键字排序\"><a href=\"#基数排序–多关键字排序\" class=\"headerlink\" title=\"基数排序–多关键字排序\"></a>基数排序–多关键字排序</h5><p>次序：从最低位排序，使用了队列</p>\n<p>改进：桶—-链式排队</p>\n<p>时间复杂度：O(d(n+r))    （n—记录数，d—-关键字(分量)个数，r—-基数）</p>\n<p>空间复杂度：O((n+r)) </p>\n<h5 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h5><p>数组记录对应关键字出现的最后一个位置</p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>快排</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n^2)</td>\n<td>O(log2n)~O(n)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>直接选择</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/2,2,1</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(1)</td>\n<td>否/1,2,2(最小堆)</td>\n</tr>\n<tr>\n<td>直接插入</td>\n<td>O(n^2)</td>\n<td>O(n)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>O(nlog2n)</td>\n<td>O(n^1.3)</td>\n<td>O(n^2)</td>\n<td>O(1)</td>\n<td>否/3,2,2(d=2/1)</td>\n</tr>\n<tr>\n<td>二路归并</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(n)</td>\n<td>是</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(d(n+r))</td>\n<td>O(n+r)</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p>最坏：</p>\n<p> 气泡排序：比较次数：n<em>(n-1)/2           移动次数：3n</em>(n-1)/2  </p>\n<p>选择排序： 比较次数：n(n-1)/2      移动次数：3(n-1)   </p>\n<p>插入排序：  比较次数:（n+2)(n-1)/2   移动次数：(n+4)(n-1)/2  时间复杂度为O(n^2)</p>\n<h4 id=\"七、外排序\"><a href=\"#七、外排序\" class=\"headerlink\" title=\"七、外排序\"></a>七、外排序</h4><h5 id=\"磁盘文件的归并排序\"><a href=\"#磁盘文件的归并排序\" class=\"headerlink\" title=\"磁盘文件的归并排序\"></a>磁盘文件的归并排序</h5><p>方法：多路归并 、 I/O并行处理  、生成初始归并段</p>\n<ul>\n<li>磁盘文件的归并排序</li>\n</ul>\n<p>第一阶段：初始归并段形成 </p>\n<p>第二阶段：多路归并 </p>\n<ul>\n<li>多路归并-减少归并遍数</li>\n</ul>\n<p>一般地，m 个初始段，采用K路归并，需要 logKm 遍归并。</p>\n<p>在 K路归并时，从 K 个关键字中选择最小记录时，要比较 K-1 次。若记录总数为 n ，每遍要比较的次数为： （n-1）<em>(K-1)</em>[logkm]=（n-1）<em>(K-1) </em>[log2(m/log2K)]</p>\n<ul>\n<li>K 路平衡归并与选择树</li>\n</ul>\n<p>第一次建立选择树的比较所花时间为: O( k-1 ) = O ( k) </p>\n<p>而后每次重新建造选择树所需时间为： O( log2k ) </p>\n<p>n 个记录处理时间为初始建立选择树的时间加上 n-1 次重新选择树的时间：                                    O((n-1)  ·log2k)+O(k) = O ( n  ·log2k )   这就是k路归并一遍所需的CPU处理时间。 </p>\n<p>归并遍数为 logkm，总时间为：                                                                                             O(n  ·log2k  ·logkm)=O(n  ·log2m)          ( k 路归并 CPU 时间与 k 无关 )</p>\n<ul>\n<li><p>并行操作的缓冲区处理</p>\n<p>​                    ——-使输入、输出和CPU处理尽可能重叠</p>\n</li>\n</ul>\n<p>对k个归并段进行 k 路归并至少需要k个输入和1个输出 缓冲区。 要使输入、输出和归并同时进行，k+1个缓冲区是不够的，需要2K个缓冲区实现并行操作</p>\n<ul>\n<li>生成初始归并段（使用选择树法）：多路平衡归并</li>\n</ul>\n<p>假设初始待排序文件为输入文件FI，初始归并段文件为输出文件FO，内 存缓冲区为W，可容纳P个记录。FO,W初始为空，则置换-选择如下：<br>(1) 从FI输入P个记录到缓冲区W;<br>(2)从W中选择出关键字最小的记录MIN；<br>(3)将MIN记录输出到FO中去；<br>(4)若FI不空，则从FI输入下一个记录到W;<br>(5)从W中所有关键字比MIN关键字大的记录中选出最小关键字记录，作 为新的MIN;<br>(6)重复(3)~(5)，直到在W中选不出新的MIN为止。得到一个初始归并段， 输出归并段结束标志到FO中<br>(7)重复(2)~(6)，直到W为空，由此得到全部初始归并段</p>\n<p>生成的初始归并段的平均长度是缓冲区长度的两倍</p>\n<p>最佳归并树：使外存读写次数最少，是一棵正则树</p>\n<p>对 K 路归并而言，设初始归并段为 m，若： ( m－1 ) % ( K－1) ＝0 则不需要加虚段，否则需要加虚段的个数为： K－( m－1 ) % ( K－1)－1</p>\n<p>加入细节点：</p>\n<ul>\n<li>已知前序和后序不能确定唯一二叉树</li>\n<li>//判断完全二叉树：k层的最后一个叶节点序号/2是否等于k-1层最后一个叶节点编号</li>\n<li><p>树转化为二叉树根一定没有右子树，森林转化为二叉树根节点可以有有子树</p>\n</li>\n<li><p>解决冲突的方法：线性再散列、内散列表、外散列表</p>\n</li>\n<li><p>左右链表示的二叉树共有2n个指针，其中，n+1个空指针，n-1个指向孩子的指针</p>\n</li>\n<li><p>折半查找树高度： (n+1)/nlog2(n+1)-1</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjswg915l0004qcu3kqje48gn","tag_id":"cjswg915s0005qcu3zgqgrsx9","_id":"cjswg915v0007qcu3x99vcxgo"},{"post_id":"cjswg915l0004qcu3kqje48gn","tag_id":"cjswg915u0006qcu3mh1vwd3n","_id":"cjswg915w0008qcu32i048mi1"},{"post_id":"cjswg919w0009qcu3uvdkywyv","tag_id":"cjswg919y000aqcu3uutncvrz","_id":"cjswg919z000bqcu3358qxlad"},{"post_id":"cjswg919w0009qcu3uvdkywyv","tag_id":"cjswg915u0006qcu3mh1vwd3n","_id":"cjswg919z000cqcu3319hua0j"}],"Tag":[{"name":"计算机系统","_id":"cjswg915s0005qcu3zgqgrsx9"},{"name":"期末复习","_id":"cjswg915u0006qcu3mh1vwd3n"},{"name":"数据结构","_id":"cjswg919y000aqcu3uutncvrz"}]}}